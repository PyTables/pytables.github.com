<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Introduction &mdash; PyTables 3.7.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Installation" href="installation.html" />
    <link rel="prev" title="PyTables User’s Guide" href="index.html" />
 
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-111342564-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-111342564-1');
</script>


</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html">
            <img src="../_static/logo-pytables-small.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                3.7.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">User’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cookbook/index.html">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../other_material.html">Other Material</a></li>
<li class="toctree-l1"><a class="reference internal" href="../MIGRATING_TO_3.x.html">Migrating from 2.x to 3.x</a></li>
<li class="toctree-l1"><a class="reference internal" href="../downloads.html">Downloads</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../project_pointers.html">Project pointers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev_team.html">Development Team</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PyTables</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">PyTables User’s Guide</a> &raquo;</li>
      <li>Introduction</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/usersguide/introduction.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<blockquote class="epigraph">
<div><p>La sabiduría no vale la pena si no es posible servirse de ella para
inventar una nueva manera de preparar los garbanzos.</p>
<p>[Wisdom isn’t worth anything if you can’t use it to come up with a new
way to cook garbanzos.]</p>
<p class="attribution">—Gabriel García Márquez, A wise Catalan in <em>“Cien años de soledad”</em></p>
</div></blockquote>
<p>The goal of PyTables is to enable the end user to manipulate easily data
<em>tables</em> and <em>array</em> objects in a hierarchical structure. The foundation of
the underlying hierarchical data organization is the excellent HDF5 library
(see <a class="reference internal" href="bibliography.html#hdfg1"><span class="std std-ref">[HDGF1]</span></a>).</p>
<p>It should be noted that this package is not intended to serve as a complete
wrapper for the entire HDF5 API, but only to provide a flexible, <em>very
pythonic</em> tool to deal with (arbitrarily) large amounts of data (typically
bigger than available memory) in tables and arrays organized in a
hierarchical and persistent disk storage structure.</p>
<p>A table is defined as a collection of records whose values are stored in
<em>fixed-length</em> fields. All records have the same structure and all values in
each field have the same <em>data type</em>. The terms <em>fixed-length</em> and strict
<em>data types</em> may seem to be a strange requirement for an interpreted language
like Python, but they serve a useful function if the goal is to save very
large quantities of data (such as is generated by many data acquisition
systems, Internet services or scientific applications, for example) in an
efficient manner that reduces demand on CPU time and I/O.</p>
<p>In order to emulate in Python records mapped to HDF5 C structs PyTables
implements a special class so as to easily define all its fields and other
properties. PyTables also provides a powerful interface to mine data in
tables. Records in tables are also known in the HDF5 naming scheme as
<em>compound</em> data types.</p>
<p>For example, you can define arbitrary tables in Python simply by declaring a
class with named fields and type information, such as in the following
example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Particle</span><span class="p">(</span><span class="n">IsDescription</span><span class="p">):</span>
    <span class="n">name</span>      <span class="o">=</span> <span class="n">StringCol</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>   <span class="c1"># 16-character String</span>
    <span class="n">idnumber</span>  <span class="o">=</span> <span class="n">Int64Col</span><span class="p">()</span>      <span class="c1"># signed 64-bit integer</span>
    <span class="n">ADCcount</span>  <span class="o">=</span> <span class="n">UInt16Col</span><span class="p">()</span>     <span class="c1"># unsigned short integer</span>
    <span class="n">TDCcount</span>  <span class="o">=</span> <span class="n">UInt8Col</span><span class="p">()</span>      <span class="c1"># unsigned byte</span>
    <span class="n">grid_i</span>    <span class="o">=</span> <span class="n">Int32Col</span><span class="p">()</span>      <span class="c1"># integer</span>
    <span class="n">grid_j</span>    <span class="o">=</span> <span class="n">Int32Col</span><span class="p">()</span>      <span class="c1"># integer</span>

    <span class="c1"># A sub-structure (nested data-type)</span>
    <span class="k">class</span> <span class="nc">Properties</span><span class="p">(</span><span class="n">IsDescription</span><span class="p">):</span>
        <span class="n">pressure</span> <span class="o">=</span> <span class="n">Float32Col</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="c1"># 2-D float array (single-precision)</span>
        <span class="n">energy</span>   <span class="o">=</span> <span class="n">Float64Col</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span> <span class="c1"># 3-D float array (double-precision)</span>
</pre></div>
</div>
<p>You then pass this class to the table constructor, fill its rows with your
values, and save (arbitrarily large) collections of them to a file for
persistent storage. After that, the data can be retrieved and post-processed
quite easily with PyTables or even with another HDF5 application (in C,
Fortran, Java or whatever language that provides a library to interface with
HDF5).</p>
<p>Other important entities in PyTables are <em>array</em> objects, which are analogous
to tables with the difference that all of their components are homogeneous.
They come in different flavors, like <em>generic</em> (they provide a quick and fast
way to deal with for numerical arrays), <em>enlargeable</em> (arrays can be extended
along a single dimension) and <em>variable length</em> (each row in the array can
have a different number of elements).</p>
<p>The next section describes the most interesting capabilities of PyTables.</p>
<section id="main-features">
<h2>Main Features<a class="headerlink" href="#main-features" title="Permalink to this headline">¶</a></h2>
<p>PyTables takes advantage of the object orientation and introspection
capabilities offered by Python, the powerful data management features of
HDF5, and NumPy’s flexibility and Numexpr’s high-performance manipulation of
large sets of objects organized in a grid-like fashion to provide these
features:</p>
<ul class="simple">
<li><p><em>Support for table entities:</em> You can tailor your data adding or deleting
records in your tables. Large numbers of rows (up to 2**63, much more than
will fit into memory) are supported as well.</p></li>
<li><p><em>Multidimensional and nested table cells:</em> You can declare a column to
consist of values having any number of dimensions besides scalars, which is
the only dimensionality allowed by the majority of relational databases.
You can even declare columns that are made of other columns (of different
types).</p></li>
<li><p><em>Indexing support for columns of tables:</em>
Very useful if you have large tables and you want to quickly look up for
values in columns satisfying some criteria.</p></li>
<li><p><em>Support for numerical arrays:</em>
NumPy (see <a class="reference internal" href="bibliography.html#numpy"><span class="std std-ref">[NUMPY]</span></a>) arrays can be used as a useful
complement of tables to store homogeneous data.</p></li>
<li><p><em>Enlargeable arrays:</em> You can add new
elements to existing arrays on disk in any dimension you want (but only
one). Besides, you are able to access just a slice of your datasets by
using the powerful extended slicing mechanism, without need to load all
your complete dataset in memory.</p></li>
<li><p><em>Variable length arrays:</em> The number of elements in these arrays can vary
from row to row. This provides a lot of flexibility when dealing with
complex data.</p></li>
<li><p><em>Supports a hierarchical data model:</em>
Allows the user to clearly structure all data. PyTables builds up an
<em>object tree</em> in memory that replicates the underlying file data structure.
Access to objects in the file is achieved by walking through and
manipulating this object tree.
Besides, this object tree is built in a lazy way, for efficiency purposes.</p></li>
<li><p><em>User defined metadata:</em> Besides
supporting system metadata (like the number of rows of a table, shape,
flavor, etc.) the user may specify arbitrary metadata (as for example, room
temperature, or protocol for IP traffic that was collected) that complement
the meaning of actual data.</p></li>
<li><p><em>Ability to read/modify generic HDF5 files:</em> PyTables can access a wide
range of objects in generic HDF5 files, like compound type datasets (that
can be mapped to Table objects), homogeneous datasets (that can be mapped
to Array objects) or variable length record datasets (that can be mapped to
VLArray objects). Besides, if a dataset is not supported, it will be mapped
to a special UnImplemented class (see <a class="reference internal" href="libref/helper_classes.html#unimplementedclassdescr"><span class="std std-ref">The UnImplemented class</span></a>), that
will let the user see that the data is there, although it will be
unreachable (still, you will be able to access the attributes and some
metadata in the dataset). With that, PyTables probably can access and
<em>modify</em> most of the HDF5 files out there.</p></li>
<li><p><em>Data compression:</em> Supports data compression (using the <em>Zlib</em>, <em>LZO</em>,
<em>bzip2</em> and <em>Blosc</em> compression libraries) out of the box. This is
important when you have repetitive data patterns and don’t want to spend
time searching for an optimized way to store them (saving you time spent
analyzing your data organization).</p></li>
<li><p><em>High performance I/O:</em> On modern systems storing large amounts of data,
tables and array objects can be read and written at a speed only limited by
the performance of the underlying I/O subsystem. Moreover, if your data is
compressible, even that limit is surmountable!</p></li>
<li><p><em>Support of files bigger than 2 GB:</em>
PyTables automatically inherits this capability from the underlying HDF5
library (assuming your platform supports the C long long integer, or, on
Windows, __int64).</p></li>
<li><p><em>Architecture-independent:</em> PyTables has been carefully coded (as HDF5
itself) with little-endian/big-endian byte ordering issues in mind. So, you
can write a file on a big-endian machine (like a Sparc or MIPS) and read it
on other little-endian machine (like an Intel or Alpha) without problems.
In addition, it has been tested successfully with 64 bit platforms
(Intel-64, AMD-64, PowerPC-G5, MIPS, UltraSparc) using code generated with
64 bit aware compilers.</p></li>
</ul>
</section>
<section id="the-object-tree">
<span id="objecttreesection"></span><h2>The Object Tree<a class="headerlink" href="#the-object-tree" title="Permalink to this headline">¶</a></h2>
<p>The hierarchical model of the underlying HDF5 library allows PyTables to
manage tables and arrays in a tree-like structure. In order to achieve this,
an <em>object tree</em> entity is <em>dynamically</em> created imitating the HDF5 structure
on disk. The HDF5 objects are read by walking through this object tree. You
can get a good picture of what kind of data is kept in the object by
examining the <em>metadata</em> nodes.</p>
<p>The different nodes in the object tree are instances of PyTables classes.
There are several types of classes, but the most important ones are the Node,
Group and Leaf classes. All nodes in a PyTables tree are instances of the
Node class. The Group and Leaf classes are descendants of Node. Group
instances (referred to as <em>groups</em> from now on) are a grouping structure
containing instances of zero or more groups or leaves, together with
supplementary metadata. Leaf instances (referred to as <em>leaves</em>) are
containers for actual data and can not contain further groups or leaves. The
Table, Array, CArray, EArray, VLArray and UnImplemented classes are
descendants of Leaf, and inherit all its properties.</p>
<p>Working with groups and leaves is similar in many ways to working with
directories and files on a Unix filesystem, i.e. a node (file or directory)
is always a <em>child</em> of one and only one group (directory), its <em>parent group</em>
<a class="footnote-reference brackets" href="#id5" id="id1">1</a>.
Inside of that group, the node is accessed by its <em>name</em>. As is the case with
Unix directories and files, objects in the object tree are often referenced
by giving their full (absolute) path names. In PyTables this full path can be
specified either as string (such as ‘/subgroup2/table3’, using / as a
parent/child separator) or as a complete object path written in a format
known as the <em>natural name</em> schema (such as file.root.subgroup2.table3).</p>
<p>Support for <em>natural naming</em> is a key aspect of PyTables. It means that the
names of instance variables of the node objects are the same as the names of
its children <a class="footnote-reference brackets" href="#id6" id="id2">2</a>. This is very <em>Pythonic</em> and intuitive in many cases. Check
the tutorial <a class="reference internal" href="tutorials.html#readingandselectingusage"><span class="std std-ref">Reading (and selecting) data in a table</span></a> for usage examples.</p>
<p>You should also be aware that not all the data present in a file is loaded
into the object tree. The <em>metadata</em> (i.e. special data that describes the
structure of the actual data) is loaded only when the user want to access to
it (see later). Moreover, the actual data is not read until she request it
(by calling a method on a particular node). Using the object tree (the
metadata) you can retrieve information about the objects on disk such as
table names, titles, column names, data types in columns, numbers of rows,
or, in the case of arrays, their shapes, typecodes, etc. You can also search
through the tree for specific kinds of data then read it and process it. In a
certain sense, you can think of PyTables as a tool that applies the same
introspection capabilities of Python objects to large amounts of data in
persistent storage.</p>
<p>It is worth noting that PyTables sports a <em>metadata cache system</em> that loads
nodes <em>lazily</em> (i.e. on-demand), and unloads nodes that have not been used
for some time (following a <em>Least Recently Used</em> schema). It is important to
stress out that the nodes enter the cache after they have been unreferenced
(in the sense of Python reference counting), and that they can be revived (by
referencing them again) directly from the cache without performing the
de-serialization process from disk. This feature allows dealing with files
with large hierarchies very quickly and with low memory consumption, while
retaining all the powerful browsing capabilities of the previous
implementation of the object tree. See <a class="reference internal" href="bibliography.html#optim"><span class="std std-ref">[OPTIM]</span></a> for more facts
about the advantages introduced by this new metadata cache system.</p>
<p>To better understand the dynamic nature of this object tree entity, let’s
start with a sample PyTables script (which you can find in
examples/objecttree.py) to create an HDF5 file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tables</span> <span class="k">as</span> <span class="nn">tb</span>

<span class="k">class</span> <span class="nc">Particle</span><span class="p">(</span><span class="n">tb</span><span class="o">.</span><span class="n">IsDescription</span><span class="p">):</span>
    <span class="n">identity</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">StringCol</span><span class="p">(</span><span class="n">itemsize</span><span class="o">=</span><span class="mi">22</span><span class="p">,</span> <span class="n">dflt</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># character String</span>
    <span class="n">idnumber</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">Int16Col</span><span class="p">(</span><span class="n">dflt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># short integer</span>
    <span class="n">speed</span>    <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">Float32Col</span><span class="p">(</span><span class="n">dflt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># single-precision</span>

<span class="c1"># Open a file in &quot;w&quot;rite mode</span>
<span class="n">fileh</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">open_file</span><span class="p">(</span><span class="s2">&quot;objecttree.h5&quot;</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>

<span class="c1"># Get the HDF5 root group</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">fileh</span><span class="o">.</span><span class="n">root</span>

<span class="c1"># Create the groups</span>
<span class="n">group1</span> <span class="o">=</span> <span class="n">fileh</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;group1&quot;</span><span class="p">)</span>
<span class="n">group2</span> <span class="o">=</span> <span class="n">fileh</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;group2&quot;</span><span class="p">)</span>

<span class="c1"># Now, create an array in root group</span>
<span class="n">array1</span> <span class="o">=</span> <span class="n">fileh</span><span class="o">.</span><span class="n">create_array</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;array1&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;string&quot;</span><span class="p">,</span> <span class="s2">&quot;array&quot;</span><span class="p">],</span> <span class="s2">&quot;String array&quot;</span><span class="p">)</span>

<span class="c1"># Create 2 new tables in group1</span>
<span class="n">table1</span> <span class="o">=</span> <span class="n">fileh</span><span class="o">.</span><span class="n">create_table</span><span class="p">(</span><span class="n">group1</span><span class="p">,</span> <span class="s2">&quot;table1&quot;</span><span class="p">,</span> <span class="n">Particle</span><span class="p">)</span>
<span class="n">table2</span> <span class="o">=</span> <span class="n">fileh</span><span class="o">.</span><span class="n">create_table</span><span class="p">(</span><span class="s2">&quot;/group2&quot;</span><span class="p">,</span> <span class="s2">&quot;table2&quot;</span><span class="p">,</span> <span class="n">Particle</span><span class="p">)</span>

<span class="c1"># Create the last table in group2</span>
<span class="n">array2</span> <span class="o">=</span> <span class="n">fileh</span><span class="o">.</span><span class="n">create_array</span><span class="p">(</span><span class="s2">&quot;/group1&quot;</span><span class="p">,</span> <span class="s2">&quot;array2&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>

<span class="c1"># Now, fill the tables</span>
<span class="k">for</span> <span class="n">table</span> <span class="ow">in</span> <span class="p">(</span><span class="n">table1</span><span class="p">,</span> <span class="n">table2</span><span class="p">):</span>
    <span class="c1"># Get the record object associated with the table:</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">row</span>

    <span class="c1"># Fill the table with 10 records</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="c1"># First, assign the values to the Particle record</span>
        <span class="n">row</span><span class="p">[</span><span class="s1">&#39;identity&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;This is particle: </span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s1">2d</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">row</span><span class="p">[</span><span class="s1">&#39;idnumber&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">row</span><span class="p">[</span><span class="s1">&#39;speed&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">2.</span>

        <span class="c1"># This injects the Record values</span>
        <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">()</span>

    <span class="c1"># Flush the table buffers</span>
    <span class="n">table</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

<span class="c1"># Finally, close the file (this also will flush all the remaining buffers!)</span>
<span class="n">fileh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>This small program creates a simple HDF5 file called objecttree.h5 with the
structure that appears in <a class="reference internal" href="#objecttree-h5"><span class="std std-ref">Figure 1</span></a> <a class="footnote-reference brackets" href="#id7" id="id3">3</a>.
When the file is created, the metadata in the object tree is updated in
memory while the actual data is saved to disk. When you close the file the
object tree is no longer available. However, when you reopen this file the
object tree will be reconstructed in memory from the metadata on disk (this
is done in a lazy way, in order to load only the objects that are required by
the user), allowing you to work with it in exactly the same way as when you
originally created it.</p>
<figure class="align-center" id="id9">
<span id="objecttree-h5"></span><img alt="../_images/objecttree-h5.png" src="../_images/objecttree-h5.png" />
<figcaption>
<p><span class="caption-text"><strong>Figure 1: An HDF5 example with 2 subgroups, 2 tables and 1 array.</strong></span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>In <a class="reference internal" href="#objecttree"><span class="std std-ref">Figure2</span></a>, you can see an example of the object tree
created when the above objecttree.h5 file is read (in fact, such an object
tree is always created when reading any supported generic HDF5 file).
It is worthwhile to take your time to understand it <a class="footnote-reference brackets" href="#id8" id="id4">4</a>.
It will help you understand the relationships of in-memory PyTables objects.</p>
<figure class="align-center" id="id10">
<span id="objecttree"></span><a class="reference internal image-reference" href="../_images/objecttree.png"><img alt="../_images/objecttree.png" src="../_images/objecttree.png" style="width: 100%;" /></a>
<figcaption>
<p><span class="caption-text"><strong>Figure 2: A PyTables object tree example.</strong></span><a class="headerlink" href="#id10" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<hr class="docutils" />
<dl class="footnote brackets">
<dt class="label" id="id5"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>PyTables does not support hard links - for the moment.</p>
</dd>
<dt class="label" id="id6"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>I got this simple but powerful idea from the excellent Objectify
module by David Mertz (see <a class="reference internal" href="bibliography.html#mertz"><span class="std std-ref">[MERTZ]</span></a>).</p>
</dd>
<dt class="label" id="id7"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>We have used ViTables (see <a class="reference internal" href="bibliography.html#vitables"><span class="std std-ref">[VITABLES]</span></a>) in order to
create this snapshot.</p>
</dd>
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>Bear in mind, however, that this diagram is <em>not</em> a standard UML class
diagram; it is rather meant to show the connections between the
PyTables objects and some of its most important attributes and
methods.</p>
</dd>
</dl>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="PyTables User’s Guide" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="installation.html" class="btn btn-neutral float-right" title="Installation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2011–2021, PyTables maintainers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>