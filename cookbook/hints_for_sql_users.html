<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hints for SQL users &mdash; PyTables 3.7.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="How to integrate PyTables in your application by using py2exe" href="py2exe_howto.html" />
    <link rel="prev" title="PyTables Cookbook" href="index.html" />
 
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-111342564-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-111342564-1');
</script>


</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html">
            <img src="../_static/logo-pytables-small.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                3.7.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../usersguide/index.html">User’s Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Cookbook</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#contents">Contents</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Hints for SQL users</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#creating-a-new-database">Creating a new database</a></li>
<li class="toctree-l4"><a class="reference internal" href="#creating-a-table">Creating a table</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-a-description">Using a description</a></li>
<li class="toctree-l4"><a class="reference internal" href="#creating-an-index">Creating an index</a></li>
<li class="toctree-l4"><a class="reference internal" href="#altering-a-table">Altering a table</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dropping-a-table">Dropping a table</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inserting-data">Inserting data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#updating-data">Updating data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#deleting-data">Deleting data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reading-data">Reading data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#selecting-data">Selecting data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#summary-of-row-selection-methods">Summary of row selection methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sorting-the-results-of-a-selection">Sorting the results of a selection</a></li>
<li class="toctree-l4"><a class="reference internal" href="#grouping-the-results-of-a-selection">Grouping the results of a selection</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="py2exe_howto.html">PyTables &amp; py2exe Howto (by Tommy Edvardsen)</a></li>
<li class="toctree-l3"><a class="reference internal" href="no_root_install.html">How to install PyTables when you're not root (by Koen van de Sande)</a></li>
<li class="toctree-l3"><a class="reference internal" href="tailoring_atexit_hooks.html">Tailoring <cite>atexit</cite> hooks</a></li>
<li class="toctree-l3"><a class="reference internal" href="custom_data_types.html">Using your own custom data types</a></li>
<li class="toctree-l3"><a class="reference internal" href="simple_table.html">SimpleTable: simple wrapper around the Table object</a></li>
<li class="toctree-l3"><a class="reference internal" href="inmemory_hdf5_files.html">In-memory HDF5 files</a></li>
<li class="toctree-l3"><a class="reference internal" href="threading.html">Threading</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../other_material.html">Other Material</a></li>
<li class="toctree-l1"><a class="reference internal" href="../MIGRATING_TO_3.x.html">Migrating from 2.x to 3.x</a></li>
<li class="toctree-l1"><a class="reference internal" href="../downloads.html">Downloads</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../project_pointers.html">Project pointers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev_team.html">Development Team</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PyTables</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">PyTables Cookbook</a> &raquo;</li>
      <li>Hints for SQL users</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/cookbook/hints_for_sql_users.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="hints-for-sql-users">
<h1>Hints for SQL users<a class="headerlink" href="#hints-for-sql-users" title="Permalink to this headline">¶</a></h1>
<p>This page is intended to be <strong>a guide to new PyTables for users who are used
to writing SQL code</strong> to access their relational databases.
It will cover the most usual SQL statements.
If you are missing a particular statement or usage example, you can ask at the
<a class="reference external" href="https://lists.sourceforge.net/lists/listinfo/pytables-users">PyTables users’ list</a> <a class="footnote-reference brackets" href="#id1" id="id2">1</a> for it.
If you know some examples yourself, you can also write them here!</p>
<p>This page is under development: you can come back frequently to check for new
examples.
Also, this is no replacement for the <a class="reference external" href="https://www.pytables.org/usersguide">User’s Guide</a> <a class="footnote-reference brackets" href="#id3" id="id4">2</a>;
if you don’t read the manual, you’ll be missing lots of features not available
in relational databases!</p>
<p>Examples in Python assume that you have imported the PyTables package like
this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tables</span>
</pre></div>
</div>
<section id="creating-a-new-database">
<h2>Creating a new database<a class="headerlink" href="#creating-a-new-database" title="Permalink to this headline">¶</a></h2>
<p>RDBMs happen to have several syntaxes for creating a database.
A usual syntax is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CREATE</span> <span class="n">DATABASE</span> <span class="n">database_name</span>
</pre></div>
</div>
<p>In PyTables, each database goes to a different <a class="reference external" href="http://www.hdfgroup.org/HDF5">HDF5</a> <a class="footnote-reference brackets" href="#id6" id="id7">3</a> file (much like
<a class="reference external" href="http://www.sqlite.org">SQLite</a> <a class="footnote-reference brackets" href="#id9" id="id10">4</a> or MS Access).
To create a new <a class="reference external" href="http://www.hdfgroup.org/HDF5">HDF5</a> <a class="footnote-reference brackets" href="#id6" id="id8">3</a> file, you use the <a class="reference internal" href="../usersguide/libref/top_level.html#tables.open_file" title="tables.open_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">tables.open_file()</span></code></a> function with
the <code class="docutils literal notranslate"><span class="pre">'w'</span></code> mode (which deletes the database if it already exists), like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">h5f</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">open_file</span><span class="p">(</span><span class="s1">&#39;database_name.h5&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In this way you get the <code class="docutils literal notranslate"><span class="pre">h5f</span></code> PyTables file handle (an instance of the
<a class="reference internal" href="../usersguide/libref/file_class.html#tables.File" title="tables.File"><code class="xref py py-class docutils literal notranslate"><span class="pre">tables.File</span></code></a> class), which is a concept similar to a <em>database
connection</em>, and a new <code class="file docutils literal notranslate"><span class="pre">database_name.h5</span></code> file is created in the current
directory (you can use full paths here).
You can close the handle (like you close the connection) with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">h5f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>This is important for PyTables to dump pending changes to the database.
In case you forget to do it, PyTables closes all open database handles for
you when you exit your program or interactive session, but it is always safer
to close your files explicitly.
If you want to use the database after closing it, you just call
<code class="xref py py-func docutils literal notranslate"><span class="pre">open_file()</span></code> again, but using the <code class="docutils literal notranslate"><span class="pre">'r+'</span></code> or <code class="docutils literal notranslate"><span class="pre">'r'</span></code> modes, depending on
whether you do or don’t need to modify the database, respectively.</p>
<p>You may use several PyTables databases simultaneously in a program, so you
must be explicit on which database you want to act upon (by using its handle).</p>
<section id="a-note-on-concurrency-under-pytables">
<h3>A note on concurrency under PyTables<a class="headerlink" href="#a-note-on-concurrency-under-pytables" title="Permalink to this headline">¶</a></h3>
<p>Unlike most RDBMs, PyTables is not intended to serve concurrent accesses to a
database.
It has no protections whatsoever against corruption for different (or even the
same) programs accessing the same database.
Opening several handles to the same database in read-only mode is safe, though.</p>
</section>
</section>
<section id="creating-a-table">
<h2>Creating a table<a class="headerlink" href="#creating-a-table" title="Permalink to this headline">¶</a></h2>
<p>PyTables supports some other <em>datasets</em> besides tables, and they’re not
arranged in a flat namespace, but rather into a <em>hierarchical</em> one (see an
introduction to the _ref:<cite>object tree &lt;ObjectTreeSection&gt;</cite>);
however, due to the nature of these recipes, we’ll limit ourselves to tables
in the <em>root group</em>.
The basic syntax for table creation under SQL is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">table_name</span> <span class="p">(</span>
    <span class="n">column_name1</span> <span class="n">column_type1</span><span class="p">,</span>
    <span class="n">column_name2</span> <span class="n">column_type2</span><span class="p">,</span>
    <span class="o">...</span>
    <span class="n">column_nameN</span> <span class="n">column_typeN</span>
<span class="p">)</span>
</pre></div>
</div>
<section id="table-descriptions">
<h3>Table descriptions<a class="headerlink" href="#table-descriptions" title="Permalink to this headline">¶</a></h3>
<p>In PyTables, one first <em>describes</em> the structure of a table.
PyTables allows you to <em>reuse a description</em> for creating several tables with
the same structure, just by using the description object (<code class="docutils literal notranslate"><span class="pre">description_name</span></code>
below) or getting it from a created table.
This is specially useful for creating temporary tables holding query results.</p>
<p>You can create a table description using a dictionary:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">description_name</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;column_name1&#39;</span><span class="p">:</span> <span class="n">column_type1</span><span class="p">,</span>
    <span class="s1">&#39;column_name2&#39;</span><span class="p">:</span> <span class="n">column_type2</span><span class="p">,</span>
    <span class="s1">&#39;column_name3&#39;</span><span class="p">:</span> <span class="n">column_type3</span><span class="p">,</span>
    <span class="o">...</span>
    <span class="s1">&#39;column_nameN&#39;</span><span class="p">:</span> <span class="n">column_typeN</span>
<span class="p">}</span>
</pre></div>
</div>
<p>or a subclass of <a class="reference internal" href="../usersguide/libref/declarative_classes.html#tables.IsDescription" title="tables.IsDescription"><code class="xref py py-class docutils literal notranslate"><span class="pre">tables.IsDescription</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">description_name</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">IsDescription</span><span class="p">):</span>
    <span class="n">column_name1</span> <span class="o">=</span> <span class="n">column_type1</span>
    <span class="n">column_name2</span> <span class="o">=</span> <span class="n">column_type2</span>
    <span class="n">column_name3</span> <span class="o">=</span> <span class="n">column_type3</span>
    <span class="o">...</span>
    <span class="n">column_nameN</span> <span class="o">=</span> <span class="n">column_typeN</span>
</pre></div>
</div>
<p>Please note that dictionaries are the only way of describing structures with
names which cannot be Python identifiers.
Also, if an explicit order is desired for columns, it must be specified through
the column type declarations (see below), since dictionary keys and class
attributes aren’t ordered.
Otherwise, columns are ordered in alphabetic increasing order.
It is important to note that PyTables doesn’t have a concept of primary or
foreign keys, so relationships between tables are left to the user.</p>
</section>
<section id="column-type-declarations">
<h3>Column type declarations<a class="headerlink" href="#column-type-declarations" title="Permalink to this headline">¶</a></h3>
<p>PyTables supports lots of types (including nested and multidimensional
columns).
Non-nested columns are declared through instances of <a class="reference internal" href="../usersguide/libref/declarative_classes.html#tables.Col" title="tables.Col"><code class="xref py py-class docutils literal notranslate"><span class="pre">tables.Col</span></code></a>
subclasses (which you can also reuse).
These are some correspondences with SQL:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 43%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>SQL type declaration</p></th>
<th class="head"><p>PyTables type declaration</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>INTEGER(digits)</p></td>
<td><p>tables.IntCol(itemsize)</p></td>
</tr>
<tr class="row-odd"><td><p>REAL</p></td>
<td><p>tables.FloatCol()</p></td>
</tr>
<tr class="row-even"><td><p>VARCHAR(length)</p></td>
<td><p>tables.StringCol(itemsize)</p></td>
</tr>
<tr class="row-odd"><td><p>DATE</p></td>
<td><p>tables.Time32Col()</p></td>
</tr>
<tr class="row-even"><td><p>TIMESTAMP</p></td>
<td><p>tables.Time64Col()</p></td>
</tr>
</tbody>
</table>
<p>See a complete description of <a class="reference internal" href="../usersguide/datatypes.html#datatypes"><span class="std std-ref">PyTables types</span></a>.
Note that some types admit different <em>item sizes</em>, which are specified in
bytes.
For types with a limited set of supported item sizes, you may also use specific
subclasses which are named after the type and its <em>precision</em>, e.g. <code class="docutils literal notranslate"><span class="pre">Int32Col</span></code>
for 4-byte (32 bit) item size.</p>
<p>Cells in a PyTables’ table always have a value of the cell type, so there is
no <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.
Instead, cells take a <em>default value</em> (zero or empty) which can be changed in
the type declaration, like this: <code class="docutils literal notranslate"><span class="pre">col_name</span> <span class="pre">=</span> <span class="pre">StringCol(10,</span> <span class="pre">dflt='nothing')</span></code>
(<code class="docutils literal notranslate"><span class="pre">col_name</span></code> takes the value <code class="docutils literal notranslate"><span class="pre">'nothing'</span></code> if unset).
The declaration also allows you to set <em>column order</em> via the <code class="docutils literal notranslate"><span class="pre">pos</span></code> argument,
like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ParticleDescription</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">IsDescription</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">StringCol</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">FloatCol</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">FloatCol</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">temperature</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">FloatCol</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="using-a-description">
<h2>Using a description<a class="headerlink" href="#using-a-description" title="Permalink to this headline">¶</a></h2>
<p>Once you have a table description <code class="docutils literal notranslate"><span class="pre">description_name</span></code> and a writeable file
handle <code class="docutils literal notranslate"><span class="pre">h5f</span></code>, creating a table with that description is as easy as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tbl</span> <span class="o">=</span> <span class="n">h5f</span><span class="o">.</span><span class="n">create_table</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;table_name&#39;</span><span class="p">,</span> <span class="n">description_name</span><span class="p">)</span>
</pre></div>
</div>
<p>PyTables is very object-oriented, and database is usually done through
methods of <a class="reference internal" href="../usersguide/libref/file_class.html#tables.File" title="tables.File"><code class="xref py py-class docutils literal notranslate"><span class="pre">tables.File</span></code></a>.
The first argument indicates the <em>path</em> where the table will be created,
i.e. the root path (HDF5 uses Unix-like paths).
The <a class="reference internal" href="../usersguide/libref/file_class.html#tables.File.create_table" title="tables.File.create_table"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.File.create_table()</span></code></a> method has many options e.g. for setting
a table title or compression properties. What you get back is an instance of
<a class="reference internal" href="../usersguide/libref/structured_storage.html#tables.Table" title="tables.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">tables.Table</span></code></a>, a handle for accessing the data in that table.</p>
<p>As with files, table handles can also be closed with <code class="docutils literal notranslate"><span class="pre">tbl.close()</span></code>.
If you want to access an already created table, you can use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tbl</span> <span class="o">=</span> <span class="n">h5f</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;table_name&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>(PyTables uses the concept of <em>node</em> for datasets -tables and others- and
groups in the object tree) or, using <em>natural naming</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tbl</span> <span class="o">=</span> <span class="n">h5f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">table_name</span>
</pre></div>
</div>
<p>Once you have created a table, you can access (and reuse) its description by
accessing the <code class="docutils literal notranslate"><span class="pre">description</span></code> attribute of its handle.</p>
</section>
<section id="creating-an-index">
<h2>Creating an index<a class="headerlink" href="#creating-an-index" title="Permalink to this headline">¶</a></h2>
<p>RDBMs use to allow named indexes on any set of columns (or all of them) in a
table, using a syntax like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CREATE</span> <span class="n">INDEX</span> <span class="n">index_name</span>
<span class="n">ON</span> <span class="n">table_name</span> <span class="p">(</span><span class="n">column_name1</span><span class="p">,</span> <span class="n">column_name2</span><span class="p">,</span> <span class="n">column_name3</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>and</p>
<blockquote>
<div><p>DROP INDEX index_name</p>
</div></blockquote>
<p>Indexing is supported in the versions of PyTables &gt;= 2.3 (and in PyTablesPro).
However, indexes don’t have names and they are bound to single columns.
Following the object-oriented philosophy of PyTables, index creation is a
method (<a class="reference internal" href="../usersguide/libref/structured_storage.html#tables.Column.create_index" title="tables.Column.create_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.Column.create_index()</span></code></a>) of a <a class="reference internal" href="../usersguide/libref/structured_storage.html#tables.Column" title="tables.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">tables.Column</span></code></a> object
of a table, which you can access trough its <code class="docutils literal notranslate"><span class="pre">cols</span></code> accessor.</p>
<dl class="simple">
<dt>::</dt><dd><p>tbl.cols.column_name.create_index()</p>
</dd>
</dl>
<p>For dropping an index on a column:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tbl</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">column_name</span><span class="o">.</span><span class="n">remove_index</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="altering-a-table">
<h2>Altering a table<a class="headerlink" href="#altering-a-table" title="Permalink to this headline">¶</a></h2>
<p>The first case of table alteration is renaming:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ALTER</span> <span class="n">TABLE</span> <span class="n">old_name</span> <span class="n">RENAME</span> <span class="n">TO</span> <span class="n">new_name</span>
</pre></div>
</div>
<p>This is accomplished in !PyTables with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">h5f</span><span class="o">.</span><span class="n">rename_node</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;old_name&#39;</span><span class="p">,</span> <span class="n">newname</span><span class="o">=</span><span class="s1">&#39;new_name&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>or through the table handle:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tbl</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;new_name&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>A handle to a table is still usable after renaming.
The second alteration, namely column addition, is currently not supported in
PyTables.</p>
</section>
<section id="dropping-a-table">
<h2>Dropping a table<a class="headerlink" href="#dropping-a-table" title="Permalink to this headline">¶</a></h2>
<p>In SQL you can remove a table using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DROP</span> <span class="n">TABLE</span> <span class="n">table_name</span>
</pre></div>
</div>
<p>In PyTables, tables are removed as other nodes, using the
<a class="reference internal" href="../usersguide/libref/file_class.html#tables.File.remove_node" title="tables.File.remove_node"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.File.remove_node()</span></code></a> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">h5f</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;table_name&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>or through the table handle:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tbl</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
</pre></div>
</div>
<p>When you remove a table, its associated indexes are automatically removed.</p>
</section>
<section id="inserting-data">
<h2>Inserting data<a class="headerlink" href="#inserting-data" title="Permalink to this headline">¶</a></h2>
<p>In SQL you can insert data one row at a time (fetching from a selection will
be covered later) using a syntax like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">INSERT</span> <span class="n">INTO</span> <span class="n">table_name</span> <span class="p">(</span><span class="n">column_name1</span><span class="p">,</span> <span class="n">column_name2</span><span class="o">...</span><span class="p">)</span>
<span class="n">VALUES</span> <span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>In PyTables, rows in a table form a <em>sequence</em>, so data isn’t <em>inserted</em> into
a set, but rather <em>appended</em> to the end of the sequence.
This also implies that identical rows may exist in a table (but they have a
different <em>row number</em>).
There are two ways of appending rows: one at a time or in a block.
The first one is conceptually similar to the SQL case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tbl</span><span class="o">.</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;column_name1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value1</span>
<span class="n">tbl</span><span class="o">.</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;column_name2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value2</span>
<span class="o">...</span>
<span class="n">tbl</span><span class="o">.</span><span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">()</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">tbl.row</span></code> accessor represents a <em>new row</em> in the table.
You just set the values you want to set (the others take the default value
from their column declarations - see above) and the effectively append the
new row.
This code is usually enclosed in some kind of loop, like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">row</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">.</span><span class="n">row</span>
<span class="k">while</span> <span class="n">some_condition</span><span class="p">:</span>
    <span class="n">row</span><span class="p">[</span><span class="s1">&#39;column_name1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value1</span>
    <span class="o">...</span>
    <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">()</span>
</pre></div>
</div>
<p>For appending a block of rows in a single shot, <a class="reference internal" href="../usersguide/libref/structured_storage.html#tables.Table.append" title="tables.Table.append"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.Table.append()</span></code></a>
is more adequate.
You just pass a <a class="reference external" href="http://www.numpy.org">NumPy</a> <a class="footnote-reference brackets" href="#id11" id="id12">5</a> record array or Python sequence with elements which
match the expected columns.
For example, given the <code class="docutils literal notranslate"><span class="pre">tbl</span></code> handle for a table with the <code class="docutils literal notranslate"><span class="pre">ParticleDescription</span></code>
structure described above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rows</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">150.0</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>  <span class="mf">25.0</span><span class="p">)</span>
<span class="p">]</span>
<span class="n">tbl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>

<span class="c1"># Using a NumPy container.</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="n">rows</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
<span class="n">tbl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
</pre></div>
</div>
<section id="a-note-on-transactions">
<h3>A note on transactions<a class="headerlink" href="#a-note-on-transactions" title="Permalink to this headline">¶</a></h3>
<p>PyTables doesn’t support transactions nor checkpointing or rolling back (there
is undo support for operations performed on the object tree, but this is
unrelated).
Changes to the database are optimised for maximum performance and reasonable
memory requirements, which means that you can’t tell whether e.g.
<code class="docutils literal notranslate"><span class="pre">tbl.append()</span></code> has actually committed all, some or no data to disk when it ends.</p>
<p>However, you can <em>force</em> PyTables to commit changes to disk using the <code class="docutils literal notranslate"><span class="pre">flush()</span></code>
method of table and file handles:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tbl</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>  <span class="c1"># flush data in the table</span>
<span class="n">h5f</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>  <span class="c1"># flush all pending data</span>
</pre></div>
</div>
<p>Closing a table or a database actually flushes it, but it is recommended that
you explicitly flush frequently (specially with tables).</p>
</section>
</section>
<section id="updating-data">
<h2>Updating data<a class="headerlink" href="#updating-data" title="Permalink to this headline">¶</a></h2>
<p>We’re now looking for alternatives to the SQL <code class="docutils literal notranslate"><span class="pre">UPDATE</span></code> statement:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">UPDATE</span> <span class="n">table_name</span>
<span class="n">SET</span> <span class="n">column_name1</span> <span class="o">=</span> <span class="n">expression1</span><span class="p">,</span> <span class="n">column_name2</span> <span class="o">=</span> <span class="n">expression2</span><span class="o">...</span>
<span class="p">[</span><span class="n">WHERE</span> <span class="n">condition</span><span class="p">]</span>
</pre></div>
</div>
<p>There are different ways of approaching this, depending on your needs.
If you aren’t using a condition, then the <code class="docutils literal notranslate"><span class="pre">SET</span></code> clause updates all rows,
something you can do in PyTables by iterating over the table:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">tbl</span><span class="p">:</span>
    <span class="n">row</span><span class="p">[</span><span class="s1">&#39;column_name1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">expression1</span>
    <span class="n">row</span><span class="p">[</span><span class="s1">&#39;column_name2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">expression2</span>
    <span class="o">...</span>
    <span class="n">row</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
</pre></div>
</div>
<p>Don’t forget to call <code class="docutils literal notranslate"><span class="pre">update()</span></code> or no value will be changed!
Also, since the used iterator allows you to read values from the current row,
you can implement a simple <em>conditional update</em>, like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">tbl</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">condition</span> <span class="n">on</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;column_name1&#39;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;column_name2&#39;</span><span class="p">]</span><span class="o">...</span><span class="p">:</span>
        <span class="n">row</span><span class="p">[</span><span class="s1">&#39;column_name1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">expression1</span>
        <span class="n">row</span><span class="p">[</span><span class="s1">&#39;column_name2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">expression2</span>
        <span class="o">...</span>
        <span class="n">row</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
</pre></div>
</div>
<p>There are substantially more efficient ways of locating rows fulfilling a
condition.
Given the main PyTables usage scenarios, querying and modifying data are
quite decoupled operations, so we will have a look at querying later and
assume that you already know the set of rows you want to update.</p>
<p>If the set happens to be a slice of the table, you may use the
:<cite>meth:`tables.Table.modify_rows</cite> method or its equivalent
<a class="reference internal" href="../usersguide/libref/structured_storage.html#tables.Table.__setitem__" title="tables.Table.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.Table.__setitem__()</span></code></a> notation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rows</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">150.0</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>  <span class="mf">25.0</span><span class="p">)</span>
<span class="p">]</span>
<span class="n">tbl</span><span class="o">.</span><span class="n">modifyRows</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">13</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">)</span>
<span class="n">tbl</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">13</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">rows</span>  <span class="c1"># this is the same</span>
</pre></div>
</div>
<p>If you just want to update some columns in the slice, use the
<a class="reference internal" href="../usersguide/libref/structured_storage.html#tables.Table.modify_columns" title="tables.Table.modify_columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.Table.modify_columns()</span></code></a> or <a class="reference internal" href="../usersguide/libref/structured_storage.html#tables.Table.modify_column" title="tables.Table.modify_column"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.Table.modify_column()</span></code></a>
methods:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cols</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mf">150.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mf">25.0</span><span class="p">]</span>
<span class="p">]</span>
<span class="c1"># These are all equivalent.</span>
<span class="n">tbl</span><span class="o">.</span><span class="n">modify_columns</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">13</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">])</span>
<span class="n">tbl</span><span class="o">.</span><span class="n">modify_column</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">13</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">colname</span><span class="o">=</span><span class="s1">&#39;temperature&#39;</span><span class="p">)</span>
<span class="n">tbl</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">temperature</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">13</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>The last line shows an example of using the <code class="docutils literal notranslate"><span class="pre">cols</span></code> accessor to get to the
desired <a class="reference internal" href="../usersguide/libref/structured_storage.html#tables.Column" title="tables.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">tables.Column</span></code></a> of the table using natural naming and apply
<code class="docutils literal notranslate"><span class="pre">setitem</span></code> on it.</p>
<p>If the set happens to be an array of sparse coordinates, you can also use
PyTables’ extended slice notation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rows</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">150.0</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>  <span class="mf">25.0</span><span class="p">)</span>
<span class="p">]</span>
<span class="n">rownos</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">735</span><span class="p">,</span> <span class="mi">371913476</span><span class="p">]</span>
<span class="n">tbl</span><span class="p">[</span><span class="n">rownos</span><span class="p">]</span> <span class="o">=</span> <span class="n">rows</span>
</pre></div>
</div>
<p>instead of the traditional:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">row_id</span><span class="p">,</span> <span class="n">datum</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rownos</span><span class="p">,</span> <span class="n">rows</span><span class="p">):</span>
     <span class="n">tbl</span><span class="p">[</span><span class="n">row_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">datum</span>
</pre></div>
</div>
<p>Since you are modifying table data in all cases, you should also remember to
<code class="docutils literal notranslate"><span class="pre">flush()</span></code> the table when you’re done.</p>
</section>
<section id="deleting-data">
<h2>Deleting data<a class="headerlink" href="#deleting-data" title="Permalink to this headline">¶</a></h2>
<p>Rows are deleted from a table with the following SQL syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DELETE</span> <span class="n">FROM</span> <span class="n">table_name</span>
<span class="p">[</span><span class="n">WHERE</span> <span class="n">condition</span><span class="p">]</span>
</pre></div>
</div>
<p><a class="reference internal" href="../usersguide/libref/structured_storage.html#tables.Table.remove_rows" title="tables.Table.remove_rows"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.Table.remove_rows()</span></code></a> is the method used for deleting rows in
PyTables.
However, it is very simple (only contiguous blocks of rows can be deleted) and
quite inefficient, and one should consider whether <em>dumping filtered data from
one table into another</em> isn’t a much more convenient approach.
This is a far more optimized operation under PyTables which will be covered
later.</p>
<p>Anyway, using <code class="docutils literal notranslate"><span class="pre">remove_row()</span></code> or <code class="docutils literal notranslate"><span class="pre">remove_rows()</span></code> is quite straightforward:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tbl</span><span class="o">.</span><span class="n">remove_row</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>  <span class="c1"># delete one single row (12)</span>
<span class="n">tbl</span><span class="o">.</span><span class="n">remove_rows</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>  <span class="c1"># delete all rows from 12 to 19 (included)</span>
<span class="n">tbl</span><span class="o">.</span><span class="n">remove_rows</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tbl</span><span class="o">.</span><span class="n">nrows</span><span class="p">)</span>  <span class="c1"># delete all rows unconditionally</span>
<span class="n">tbl</span><span class="o">.</span><span class="n">remove_rows</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="n">tbl</span><span class="o">.</span><span class="n">nrows</span><span class="p">)</span>  <span class="c1"># delete the last 4 rows</span>
</pre></div>
</div>
</section>
<section id="reading-data">
<h2>Reading data<a class="headerlink" href="#reading-data" title="Permalink to this headline">¶</a></h2>
<p>The most basic syntax in SQL for reading rows in a table without using a
condition is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="p">(</span><span class="n">column_name1</span><span class="p">,</span> <span class="n">column_name2</span><span class="o">...</span> <span class="o">|</span> <span class="o">*</span><span class="p">)</span> <span class="n">FROM</span> <span class="n">table_name</span>
</pre></div>
</div>
<p>Which reads all rows (though maybe not all columns) from a table.
In PyTables there are two ways of retrieving data: <em>iteratively</em> or <em>at once</em>.
You’ll notice some similarities with how we appended and updated data above,
since this dichotomy is widespread here.</p>
<p>For a clearer separation with conditional queries (covered further below),
and since the concept of <em>row number</em> doesn’t exist in relational databases,
we’ll be including here the cases where you want to read a <strong>known</strong> <em>slice</em>
or <em>sequence</em> of rows, besides the case of reading <em>all</em> rows.</p>
<section id="iterating-over-rows">
<h3>Iterating over rows<a class="headerlink" href="#iterating-over-rows" title="Permalink to this headline">¶</a></h3>
<p>This is similar to using the <code class="docutils literal notranslate"><span class="pre">fetchone()</span></code> method of a DB <code class="docutils literal notranslate"><span class="pre">cursor</span></code> in a
<a class="reference external" href="http://www.python.org/dev/peps/pep-0249">Python DBAPI</a> <a class="footnote-reference brackets" href="#id14" id="id15">6</a>-compliant package, i.e. you <em>iterate</em> over the list of wanted
rows, getting one <em>row handle</em> at a time.
In this case, the handle is an instance of the <code class="xref py py-class docutils literal notranslate"><span class="pre">tables.Row</span></code> class,
which allows access to individual columns as items accessed by key (so there
is no special way of selecting columns: you just use the ones you want
whenever you want).</p>
<p>This way of reading rows is recommended when you want to perform operations
on individual rows in a simple manner, and specially if you want to process
a lot of rows in the table (i.e. when loading them all at once would take too
much memory).
Iterators are also handy for using with the <code class="docutils literal notranslate"><span class="pre">itertools</span></code> Python module for
grouping, sorting and other operations.</p>
<p>For iterating over <em>all</em> rows, use plain iteration or the
<a class="reference internal" href="../usersguide/libref/structured_storage.html#tables.Table.iterrows" title="tables.Table.iterrows"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.Table.iterrows()</span></code></a> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">tbl</span><span class="p">:</span>  <span class="c1"># or tbl.iterrows()</span>
    <span class="n">do</span> <span class="n">something</span> <span class="k">with</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;column_name1&#39;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;column_name2&#39;</span><span class="p">]</span><span class="o">...</span>
</pre></div>
</div>
<p>For iterating over a <em>slice</em> of rows, use the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.Table.iterrows|Table.iterrows()</span></code> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">tbl</span><span class="o">.</span><span class="n">iterrows</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">13</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">do</span> <span class="n">something</span> <span class="k">with</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;column_name1&#39;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;column_name2&#39;</span><span class="p">]</span><span class="o">...</span>
</pre></div>
</div>
<p>For iterating over a <em>sequence</em> of rows, use the
<a class="reference internal" href="../usersguide/libref/structured_storage.html#tables.Table.itersequence" title="tables.Table.itersequence"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.Table.itersequence()</span></code></a> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">tbl</span><span class="o">.</span><span class="n">itersequence</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">]):</span>
    <span class="n">do</span> <span class="n">something</span> <span class="k">with</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;column_name1&#39;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;column_name2&#39;</span><span class="p">]</span><span class="o">...</span>
</pre></div>
</div>
</section>
<section id="reading-rows-at-once">
<h3>Reading rows at once<a class="headerlink" href="#reading-rows-at-once" title="Permalink to this headline">¶</a></h3>
<p>In contrast with iteration, you can fetch all desired rows into a single
<em>container</em> in memory (usually an efficient <a class="reference external" href="http://www.numpy.org">NumPy</a> <a class="footnote-reference brackets" href="#id11" id="id13">5</a> record-array) in a single
operation, like the <code class="docutils literal notranslate"><span class="pre">fetchall()</span></code> or <code class="docutils literal notranslate"><span class="pre">fetchmany()</span></code> methods of a DBAPI <code class="docutils literal notranslate"><span class="pre">cursor</span></code>.
This is specially useful when you want to transfer the read data to another
component in your program, avoiding loops to construct your own containers.
However, you should be careful about the amount of data you are fetching into
memory, since it can be quite large (and even exceed its physical capacity).</p>
<p>You can choose between the <code class="docutils literal notranslate"><span class="pre">Table.read*()</span></code> methods or the
<a class="reference internal" href="../usersguide/libref/structured_storage.html#tables.Table.__getitem__" title="tables.Table.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.Table.__getitem__()</span></code></a> syntax for this kind of reads.
The <code class="docutils literal notranslate"><span class="pre">read*()</span></code> methods offer you the chance to choose a single column to read
via their <code class="docutils literal notranslate"><span class="pre">field</span></code> argument (which isn’t still as powerful as the SQL <code class="docutils literal notranslate"><span class="pre">SELECT</span></code>
column spec).</p>
<p>For reading <em>all</em> rows, use <code class="docutils literal notranslate"><span class="pre">[:]</span></code> or the <a class="reference internal" href="../usersguide/libref/structured_storage.html#tables.Table.read" title="tables.Table.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.Table.read()</span></code></a> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rows</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">rows</span> <span class="o">=</span> <span class="n">tbl</span><span class="p">[:]</span>  <span class="c1"># equivalent</span>
</pre></div>
</div>
<p>For reading a <em>slice</em> of rows, use <code class="docutils literal notranslate"><span class="pre">[slice]</span></code> or the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.Table.read|Table.read()</span></code> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rows</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">13</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">rows</span> <span class="o">=</span> <span class="n">tbl</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">13</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># equivalent</span>
</pre></div>
</div>
<p>For reading a <em>sequence</em> of rows, use the <a class="reference internal" href="../usersguide/libref/structured_storage.html#tables.Table.read_coordinates" title="tables.Table.read_coordinates"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.Table.read_coordinates()</span></code></a>
method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rows</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">.</span><span class="n">read_coordinates</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">])</span>
</pre></div>
</div>
<p>Please note that you can add a <code class="docutils literal notranslate"><span class="pre">field='column_name'</span></code> argument to <code class="docutils literal notranslate"><span class="pre">read*()</span></code>
methods in order to get only the given column instead of them all.</p>
</section>
</section>
<section id="selecting-data">
<h2>Selecting data<a class="headerlink" href="#selecting-data" title="Permalink to this headline">¶</a></h2>
<p>When you want to read a subset of rows which match a given condition from a
table you use a syntax like this in SQL:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">column_specification</span> <span class="n">FROM</span> <span class="n">table_name</span>
<span class="n">WHERE</span> <span class="n">condition</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">condition</span></code> is an expression yielding a boolean value based on a
combination of column names and constants with functions and operators.
If the condition holds true for a given row, the <code class="docutils literal notranslate"><span class="pre">column_specification</span></code> is
applied on it and the resulting row is added to the result.</p>
<p>In PyTables, you may filter rows using two approaches: the first one is
achieved through standard Python comparisons (similar to what we used for
conditional update), like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">tbl</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">condition</span> <span class="n">on</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;column_name1&#39;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;column_name2&#39;</span><span class="p">]</span><span class="o">...</span><span class="p">:</span>
        <span class="n">do</span> <span class="n">something</span> <span class="k">with</span> <span class="n">row</span>
</pre></div>
</div>
<p>This is easy for newcomers, but not very efficient. That’s why PyTables offers
another approach: <strong>in-kernel</strong> searches, which are much more efficient than
standard searches, and can take advantage of indexing (under PyTables &gt;= 2.3).</p>
<p>In-kernel searches are used through the <em>where methods</em> in <code class="docutils literal notranslate"><span class="pre">Table</span></code>, which are
passed a <em>condition string</em> describing the condition in a Python-like syntax.
For instance, with the <code class="docutils literal notranslate"><span class="pre">ParticleDescription</span></code> we defined above, we may specify
a condition for selecting particles at most 1 unit apart from the origin with
a temperature under 100 with a condition string like this one:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;(sqrt(x**2 + y**2) &lt;= 1) &amp; (temperature &lt; 100)&#39;</span>
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">temperature</span></code> are the names of columns in the table.
The operators and functions you may use in a condition string are described
in the <a class="reference internal" href="../usersguide/condition_syntax.html#condition-syntax"><span class="std std-ref">appendix on condition syntax</span></a> in the
<a class="reference external" href="https://www.pytables.org/usersguide">User’s Guide</a> <a class="footnote-reference brackets" href="#id3" id="id5">2</a>.</p>
<section id="iterating-over-selected-rows">
<h3>Iterating over selected rows<a class="headerlink" href="#iterating-over-selected-rows" title="Permalink to this headline">¶</a></h3>
<p>You can iterate over the rows in a table which fulfill a condition (a la DBAPI
<code class="docutils literal notranslate"><span class="pre">fetchone()</span></code>) by using the <a class="reference internal" href="../usersguide/libref/structured_storage.html#tables.Table.where" title="tables.Table.where"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.Table.where()</span></code></a> method, which is very
similar to the <a class="reference internal" href="../usersguide/libref/structured_storage.html#tables.Table.iterrows" title="tables.Table.iterrows"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.Table.iterrows()</span></code></a> one discussed above, and which
can be used in the same circumstances (i.e. performing operations on individual
rows or having results exceeding available memory).</p>
<p>Here is an example of using <code class="docutils literal notranslate"><span class="pre">where()</span></code> with the previous example condition:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">tbl</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s1">&#39;(sqrt(x**2 + y**2) &lt;= 1) &amp; (temperature &lt; 100)&#39;</span><span class="p">):</span>
    <span class="n">do</span> <span class="n">something</span> <span class="k">with</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">...</span>
</pre></div>
</div>
</section>
<section id="reading-selected-rows-at-once">
<h3>Reading selected rows at once<a class="headerlink" href="#reading-selected-rows-at-once" title="Permalink to this headline">¶</a></h3>
<p>Like the aforementioned <a class="reference internal" href="../usersguide/libref/structured_storage.html#tables.Table.read" title="tables.Table.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.Table.read()</span></code></a>,
<a class="reference internal" href="../usersguide/libref/structured_storage.html#tables.Table.read_where" title="tables.Table.read_where"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.Table.read_where()</span></code></a> gets all the rows fulfilling the given
condition and packs them in a single container (a la DBAPI <code class="docutils literal notranslate"><span class="pre">fetchmany()</span></code>).
The same warning applies: be careful on how many rows you expect to retrieve,
or you may run out of memory!</p>
<p>Here is an example of using <code class="docutils literal notranslate"><span class="pre">read_where()</span></code> with the previous example
condition:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rows</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">.</span><span class="n">read_where</span><span class="p">(</span><span class="s1">&#39;(sqrt(x**2 + y**2) &lt;= 1) &amp; (temperature &lt; 100)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Please note that both <a class="reference internal" href="../usersguide/libref/structured_storage.html#tables.Table.where" title="tables.Table.where"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.Table.where()</span></code></a> and
<a class="reference internal" href="../usersguide/libref/structured_storage.html#tables.Table.read_where" title="tables.Table.read_where"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.Table.read_where()</span></code></a> can also take slicing arguments.</p>
</section>
<section id="getting-the-coordinates-of-selected-rows">
<h3>Getting the coordinates of selected rows<a class="headerlink" href="#getting-the-coordinates-of-selected-rows" title="Permalink to this headline">¶</a></h3>
<p>There is yet another method for querying tables:
<a class="reference internal" href="../usersguide/libref/structured_storage.html#tables.Table.get_where_list" title="tables.Table.get_where_list"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.Table.get_where_list()</span></code></a>.
It returns just a sequence of the numbers of the rows which fulfil the given
condition.
You may pass that sequence to <a class="reference internal" href="../usersguide/libref/structured_storage.html#tables.Table.read_coordinates" title="tables.Table.read_coordinates"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.Table.read_coordinates()</span></code></a>, e.g. to
retrieve data from a different table where rows with the same number as the
queried one refer to the same first-class object or entity.</p>
</section>
<section id="a-note-on-table-joins">
<h3>A note on table joins<a class="headerlink" href="#a-note-on-table-joins" title="Permalink to this headline">¶</a></h3>
<p>You may have noticed that queries in PyTables only cover one table.
In fact, there is no way of directly performing a join between two tables in
PyTables (remember that it’s not a relational database).
You may however work around this limitation depending on your case:</p>
<ul>
<li><p>If one table is an <em>extension</em> of another (i.e. it contains additional
columns for the same entities), your best bet is to arrange rows of the
same entity so that they are placed in the same positions in both tables.
For instance, if <code class="docutils literal notranslate"><span class="pre">tbl1</span></code> and <code class="docutils literal notranslate"><span class="pre">tbl2</span></code> follow this rule, you may do something
like this to emulate a natural join:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> for row1 in tbl1.where(&#39;condition&#39;):
     row2 = tbl2[row1.nrow]
     if condition on row2[&#39;column_name1&#39;], row2[&#39;column_name2&#39;]...:
         do something with row1 and row2...

(Note that ``row1`` is a ``Row`` instance and ``row2`` is a record of the current
flavor.)
</pre></div>
</div>
</li>
<li><p>If rows in both tables are linked by a common value (e.g. acting as an
identifier), you’ll need to split your condition in one for the first table
and one for the second table, and then nest your queries, placing the most
restrictive one first. For instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">clients</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">bills</span><span class="o">.</span><span class="n">item_id</span> <span class="n">FROM</span> <span class="n">clients</span><span class="p">,</span> <span class="n">bills</span>
<span class="n">WHERE</span> <span class="n">clients</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">bills</span><span class="o">.</span><span class="n">client_id</span> <span class="ow">and</span> <span class="n">clients</span><span class="o">.</span><span class="n">age</span> <span class="o">&gt;</span> <span class="mi">50</span> <span class="ow">and</span> <span class="n">bills</span><span class="o">.</span><span class="n">price</span> <span class="o">&gt;</span> <span class="mi">200</span>
</pre></div>
</div>
<p>could be written as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">client</span> <span class="ow">in</span> <span class="n">clients</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s1">&#39;age &gt; 50&#39;</span><span class="p">):</span>
    <span class="c1"># Note that the following query is different for each client.</span>
    <span class="k">for</span> <span class="n">bill</span> <span class="ow">in</span> <span class="n">bills</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s1">&#39;(client_id == </span><span class="si">%r</span><span class="s1">) &amp; (price &gt; 200)&#39;</span> <span class="o">%</span> <span class="n">client</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]):</span>
        <span class="n">do</span> <span class="n">something</span> <span class="k">with</span> <span class="n">client</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">bill</span><span class="p">[</span><span class="s1">&#39;item_id&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>In this example, indexing the <code class="docutils literal notranslate"><span class="pre">client_id</span></code> column of <code class="docutils literal notranslate"><span class="pre">bills</span></code> could speed up
the inner query quite a lot.
Also, you could avoid parsing the inner condition each time by using
<em>condition variables</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">client</span> <span class="ow">in</span> <span class="n">clients</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s1">&#39;age &gt; 50&#39;</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">bill</span> <span class="ow">in</span> <span class="n">bills</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s1">&#39;(client_id == cid) &amp; (price &gt; 200)&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;cid&#39;</span><span class="p">:</span> <span class="n">client</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]}):</span>
        <span class="n">do</span> <span class="n">something</span> <span class="k">with</span> <span class="n">client</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">bill</span><span class="p">[</span><span class="s1">&#39;item_id&#39;</span><span class="p">]</span>
</pre></div>
</div>
</li>
</ul>
</section>
</section>
<section id="summary-of-row-selection-methods">
<h2>Summary of row selection methods<a class="headerlink" href="#summary-of-row-selection-methods" title="Permalink to this headline">¶</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 16%" />
<col style="width: 19%" />
<col style="width: 21%" />
<col style="width: 23%" />
</colgroup>
<tbody>
<tr class="row-odd"><td></td>
<td><p><strong>All rows</strong></p></td>
<td><p><strong>Range of rows</strong></p></td>
<td><p><strong>Sequence of rows</strong></p></td>
<td><p><strong>Condition</strong></p></td>
</tr>
<tr class="row-even"><td><p><strong>Iterative access</strong></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__iter__()</span></code>,
<code class="docutils literal notranslate"><span class="pre">iterrows()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">iterrows(range)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">itersequence()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">where(condition)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><strong>Block access</strong></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[:]</span></code>,
<code class="docutils literal notranslate"><span class="pre">read()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[range]</span></code>,
<code class="docutils literal notranslate"><span class="pre">read(range)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">readCoordinates()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">read_where(condition)</span></code></p></td>
</tr>
</tbody>
</table>
</section>
<section id="sorting-the-results-of-a-selection">
<h2>Sorting the results of a selection<a class="headerlink" href="#sorting-the-results-of-a-selection" title="Permalink to this headline">¶</a></h2>
<p><em>Do you feel like writing this section? Your contribution is welcome!</em></p>
</section>
<section id="grouping-the-results-of-a-selection">
<h2>Grouping the results of a selection<a class="headerlink" href="#grouping-the-results-of-a-selection" title="Permalink to this headline">¶</a></h2>
<p>By making use of the <code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.groupby()</span></code> utility, you can group results
by field:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">group</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># dictionary to put results grouped by &#39;pressure&#39;</span>
<span class="k">def</span> <span class="nf">pressure_selector</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;pressure&#39;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">pressure</span><span class="p">,</span> <span class="n">rows_grouped_by_pressure</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">mytable</span><span class="p">,</span> <span class="n">pressure_selector</span><span class="p">):</span>
    <span class="n">group</span><span class="p">[</span><span class="n">pressure</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="s1">&#39;ADCcount&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rows_grouped_by_pressure</span><span class="p">))</span>
</pre></div>
</div>
<p>However, <code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.groupby()</span></code> assumes the incoming array is sorted by the
grouping field.
If not, there are multiple groups with the same grouper returned.
In the example, mytable thus has to be sorted on pressure, or the last line
should be changed to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">group</span><span class="p">[</span><span class="n">pressure</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">((</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="s1">&#39;ADCcount&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rows_grouped_by_pressure</span><span class="p">))</span>
</pre></div>
</div>
<hr class="docutils" />
<dl class="footnote brackets">
<dt class="label" id="id1"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p><a class="reference external" href="https://lists.sourceforge.net/lists/listinfo/pytables-users">https://lists.sourceforge.net/lists/listinfo/pytables-users</a></p>
</dd>
<dt class="label" id="id3"><span class="brackets">2</span><span class="fn-backref">(<a href="#id4">1</a>,<a href="#id5">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://www.pytables.org/usersguide">https://www.pytables.org/usersguide</a></p>
</dd>
<dt class="label" id="id6"><span class="brackets">3</span><span class="fn-backref">(<a href="#id7">1</a>,<a href="#id8">2</a>)</span></dt>
<dd><p><a class="reference external" href="http://www.hdfgroup.org/HDF5">http://www.hdfgroup.org/HDF5</a></p>
</dd>
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id10">4</a></span></dt>
<dd><p><a class="reference external" href="http://www.sqlite.org">http://www.sqlite.org</a></p>
</dd>
<dt class="label" id="id11"><span class="brackets">5</span><span class="fn-backref">(<a href="#id12">1</a>,<a href="#id13">2</a>)</span></dt>
<dd><p><a class="reference external" href="http://www.numpy.org">http://www.numpy.org</a></p>
</dd>
<dt class="label" id="id14"><span class="brackets"><a class="fn-backref" href="#id15">6</a></span></dt>
<dd><p><a class="reference external" href="http://www.python.org/dev/peps/pep-0249">http://www.python.org/dev/peps/pep-0249</a></p>
</dd>
</dl>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="PyTables Cookbook" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="py2exe_howto.html" class="btn btn-neutral float-right" title="How to integrate PyTables in your application by using py2exe" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2011–2021, PyTables maintainers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>