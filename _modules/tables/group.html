

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>tables.group &mdash; PyTables 3.4.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="PyTables 3.4.1 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/logo-pytables-small.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                3.4.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../usersguide/index.html">Userâ€™s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cookbook/index.html">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../other_material.html">Other Material</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../MIGRATING_TO_3.x.html">Migrating from 2.x to 3.x</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../downloads.html">Downloads</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release_notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../project_pointers.html">Project pointers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev_team.html">Development Team</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PyTables</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>tables.group</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for tables.group</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="c1">########################################################################</span>
<span class="c1">#</span>
<span class="c1"># License: BSD</span>
<span class="c1"># Created: September 4, 2002</span>
<span class="c1"># Author: Francesc Alted - faltet@pytables.com</span>
<span class="c1">#</span>
<span class="c1"># $Id$</span>
<span class="c1">#</span>
<span class="c1">########################################################################</span>

<span class="sd">&quot;&quot;&quot;Here is defined the Group class.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">.misc.proxydict</span> <span class="k">import</span> <span class="n">ProxyDict</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">hdf5extension</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">utilsextension</span>
<span class="kn">from</span> <span class="nn">.registry</span> <span class="k">import</span> <span class="n">class_id_dict</span>
<span class="kn">from</span> <span class="nn">.exceptions</span> <span class="k">import</span> <span class="n">NodeError</span><span class="p">,</span> <span class="n">NoSuchNodeError</span><span class="p">,</span> <span class="n">NaturalNameWarning</span><span class="p">,</span> <span class="n">PerformanceWarning</span>
<span class="kn">from</span> <span class="nn">.filters</span> <span class="k">import</span> <span class="n">Filters</span>
<span class="kn">from</span> <span class="nn">.registry</span> <span class="k">import</span> <span class="n">get_class_by_name</span>
<span class="kn">from</span> <span class="nn">.path</span> <span class="k">import</span> <span class="n">check_name_validity</span><span class="p">,</span> <span class="n">join_path</span><span class="p">,</span> <span class="n">isvisiblename</span>
<span class="kn">from</span> <span class="nn">.node</span> <span class="k">import</span> <span class="n">Node</span><span class="p">,</span> <span class="n">NotLoggedMixin</span>
<span class="kn">from</span> <span class="nn">.leaf</span> <span class="k">import</span> <span class="n">Leaf</span>
<span class="kn">from</span> <span class="nn">.unimplemented</span> <span class="k">import</span> <span class="n">UnImplemented</span><span class="p">,</span> <span class="n">Unknown</span>

<span class="kn">from</span> <span class="nn">.link</span> <span class="k">import</span> <span class="n">Link</span><span class="p">,</span> <span class="n">SoftLink</span><span class="p">,</span> <span class="n">ExternalLink</span>
<span class="kn">import</span> <span class="nn">six</span>


<span class="n">obversion</span> <span class="o">=</span> <span class="s2">&quot;1.0&quot;</span>


<span class="k">class</span> <span class="nc">_ChildrenDict</span><span class="p">(</span><span class="n">ProxyDict</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_get_value_from_container</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">container</span><span class="o">.</span><span class="n">_f_get_child</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>


<span class="nd">@six</span><span class="o">.</span><span class="n">python_2_unicode_compatible</span>
<div class="viewcode-block" id="Group"><a class="viewcode-back" href="../../usersguide/libref/hierarchy_classes.html#tables.Group">[docs]</a><span class="k">class</span> <span class="nc">Group</span><span class="p">(</span><span class="n">hdf5extension</span><span class="o">.</span><span class="n">Group</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Basic PyTables grouping structure.</span>

<span class="sd">    Instances of this class are grouping structures containing *child*</span>
<span class="sd">    instances of zero or more groups or leaves, together with</span>
<span class="sd">    supporting metadata. Each group has exactly one *parent* group.</span>

<span class="sd">    Working with groups and leaves is similar in many ways to working</span>
<span class="sd">    with directories and files, respectively, in a Unix filesystem.</span>
<span class="sd">    As with Unix directories and files, objects in the object tree are</span>
<span class="sd">    often described by giving their full (or absolute) path names.</span>
<span class="sd">    This full path can be specified either as a string (like in</span>
<span class="sd">    &#39;/group1/group2&#39;) or as a complete object path written in *natural</span>
<span class="sd">    naming* schema (like in file.root.group1.group2).</span>

<span class="sd">    A collateral effect of the *natural naming* schema is that the</span>
<span class="sd">    names of members in the Group class and its instances must be</span>
<span class="sd">    carefully chosen to avoid colliding with existing children node</span>
<span class="sd">    names.  For this reason and to avoid polluting the children</span>
<span class="sd">    namespace all members in a Group start with some reserved prefix,</span>
<span class="sd">    like _f_ (for public methods), _g_ (for private ones), _v_ (for</span>
<span class="sd">    instance variables) or _c_ (for class variables). Any attempt to</span>
<span class="sd">    create a new child node whose name starts with one of these</span>
<span class="sd">    prefixes will raise a ValueError exception.</span>

<span class="sd">    Another effect of natural naming is that children named after</span>
<span class="sd">    Python keywords or having names not valid as Python identifiers</span>
<span class="sd">    (e.g.  class, $a or 44) can not be accessed using the node.child</span>
<span class="sd">    syntax. You will be forced to use node._f_get_child(child) to</span>
<span class="sd">    access them (which is recommended for programmatic accesses).</span>

<span class="sd">    You will also need to use _f_get_child() to access an existing</span>
<span class="sd">    child node if you set a Python attribute in the Group with the</span>
<span class="sd">    same name as that node (you will get a NaturalNameWarning when</span>
<span class="sd">    doing this).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parentnode</span>
<span class="sd">        The parent :class:`Group` object.</span>

<span class="sd">        .. versionchanged:: 3.0</span>
<span class="sd">           Renamed from *parentNode* to *parentnode*</span>

<span class="sd">    name : str</span>
<span class="sd">        The name of this node in its parent group.</span>
<span class="sd">    title</span>
<span class="sd">        The title for this group</span>
<span class="sd">    new</span>
<span class="sd">        If this group is new or has to be read from disk</span>
<span class="sd">    filters : Filters</span>
<span class="sd">        A Filters instance</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The following documentation includes methods that are automatically</span>
<span class="sd">    called when a Group instance is accessed in a special way.</span>

<span class="sd">    For instance, this class defines the __setattr__, __getattr__, and</span>
<span class="sd">    __delattr__ methods, and they set, get and delete *ordinary Python</span>
<span class="sd">    attributes* as normally intended. In addition to that, __getattr__</span>
<span class="sd">    allows getting *child nodes* by their name for the sake of easy</span>
<span class="sd">    interaction on the command line, as long as there is no Python</span>
<span class="sd">    attribute with the same name. Groups also allow the interactive</span>
<span class="sd">    completion (when using readline) of the names of child nodes.</span>
<span class="sd">    For instance::</span>

<span class="sd">        # get a Python attribute</span>
<span class="sd">        nchild = group._v_nchildren</span>

<span class="sd">        # Add a Table child called &#39;table&#39; under &#39;group&#39;.</span>
<span class="sd">        h5file.create_table(group, &#39;table&#39;, myDescription)</span>
<span class="sd">        table = group.table          # get the table child instance</span>
<span class="sd">        group.table = &#39;foo&#39;          # set a Python attribute</span>

<span class="sd">        # (PyTables warns you here about using the name of a child node.)</span>
<span class="sd">        foo = group.table            # get a Python attribute</span>
<span class="sd">        del group.table              # delete a Python attribute</span>
<span class="sd">        table = group.table          # get the table child instance again</span>


<span class="sd">    .. rubric:: Group attributes</span>

<span class="sd">    The following instance variables are provided in addition to those</span>
<span class="sd">    in Node (see :ref:`NodeClassDescr`):</span>

<span class="sd">    .. attribute:: _v_children</span>

<span class="sd">        Dictionary with all nodes hanging from this group.</span>

<span class="sd">    .. attribute:: _v_groups</span>

<span class="sd">        Dictionary with all groups hanging from this group.</span>

<span class="sd">    .. attribute:: _v_hidden</span>

<span class="sd">        Dictionary with all hidden nodes hanging from this group.</span>

<span class="sd">    .. attribute:: _v_leaves</span>

<span class="sd">        Dictionary with all leaves hanging from this group.</span>

<span class="sd">    .. attribute:: _v_links</span>

<span class="sd">        Dictionary with all links hanging from this group.</span>

<span class="sd">    .. attribute:: _v_unknown</span>

<span class="sd">        Dictionary with all unknown nodes hanging from this group.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Class identifier.</span>
    <span class="n">_c_classid</span> <span class="o">=</span> <span class="s1">&#39;GROUP&#39;</span>


    <span class="c1"># Children containers that should be loaded only in a lazy way.</span>
    <span class="c1"># These are documented in the ``Group._g_add_children_names`` method.</span>
    <span class="n">_c_lazy_children_attrs</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;__members__&#39;</span><span class="p">,</span> <span class="s1">&#39;_v_children&#39;</span><span class="p">,</span> <span class="s1">&#39;_v_groups&#39;</span><span class="p">,</span> <span class="s1">&#39;_v_leaves&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_v_links&#39;</span><span class="p">,</span> <span class="s1">&#39;_v_unknown&#39;</span><span class="p">,</span> <span class="s1">&#39;_v_hidden&#39;</span><span class="p">)</span>

    <span class="c1"># `_v_nchildren` is a direct read-only shorthand</span>
    <span class="c1"># for the number of *visible* children in a group.</span>
    <span class="k">def</span> <span class="nf">_g_getnchildren</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;The number of children hanging from this group.&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_children</span><span class="p">)</span>

    <span class="n">_v_nchildren</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_g_getnchildren</span><span class="p">)</span>

    <span class="c1"># `_v_filters` is a direct read-write shorthand for the ``FILTERS``</span>
    <span class="c1"># attribute with the default `Filters` instance as a default value.</span>
    <span class="k">def</span> <span class="nf">_g_getfilters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">filters</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="p">,</span> <span class="s1">&#39;FILTERS&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filters</span> <span class="o">=</span> <span class="n">Filters</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">filters</span>

    <span class="k">def</span> <span class="nf">_g_setfilters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Filters</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;value is not an instance of `Filters`: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">,))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">FILTERS</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_g_delfilters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">FILTERS</span>

    <span class="n">_v_filters</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span>
        <span class="n">_g_getfilters</span><span class="p">,</span> <span class="n">_g_setfilters</span><span class="p">,</span> <span class="n">_g_delfilters</span><span class="p">,</span>
        <span class="sd">&quot;&quot;&quot;Default filter properties for child nodes.</span>

<span class="sd">        You can (and are encouraged to) use this property to get, set and</span>
<span class="sd">        delete the FILTERS HDF5 attribute of the group, which stores a Filters</span>
<span class="sd">        instance (see :ref:`FiltersClassDescr`). When the group has no such</span>
<span class="sd">        attribute, a default Filters instance is used.</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parentnode</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                 <span class="n">title</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">_log</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="c1"># Remember to assign these values in the root group constructor</span>
        <span class="c1"># if it does not use this one!</span>

        <span class="c1"># First, set attributes belonging to group objects.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_v_version</span> <span class="o">=</span> <span class="n">obversion</span>
        <span class="sd">&quot;&quot;&quot;The object version of this group.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_v_new</span> <span class="o">=</span> <span class="n">new</span>
        <span class="sd">&quot;&quot;&quot;Is this the first time the node has been created?&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_v_new_title</span> <span class="o">=</span> <span class="n">title</span>
        <span class="sd">&quot;&quot;&quot;New title for this node.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_v_new_filters</span> <span class="o">=</span> <span class="n">filters</span>
        <span class="sd">&quot;&quot;&quot;New default filter properties for child nodes.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_v_max_group_width</span> <span class="o">=</span> <span class="n">parentnode</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;MAX_GROUP_WIDTH&#39;</span><span class="p">]</span>
        <span class="sd">&quot;&quot;&quot;Maximum number of children on each group before warning the user.</span>

<span class="sd">        .. versionchanged:: 3.0</span>
<span class="sd">           The *_v_maxGroupWidth* attribute has been renamed into</span>
<span class="sd">           *_v_max_group_width*.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Finally, set up this object as a node.</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Group</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parentnode</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">_log</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_g_post_init_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_new</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;PYTABLES_SYS_ATTRS&#39;</span><span class="p">]:</span>
                <span class="c1"># Save some attributes for the new group on disk.</span>
                <span class="n">set_attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">_g__setattr</span>
                <span class="c1"># Set the title, class and version attributes.</span>
                <span class="n">set_attr</span><span class="p">(</span><span class="s1">&#39;TITLE&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_new_title</span><span class="p">)</span>
                <span class="n">set_attr</span><span class="p">(</span><span class="s1">&#39;CLASS&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_classid</span><span class="p">)</span>
                <span class="n">set_attr</span><span class="p">(</span><span class="s1">&#39;VERSION&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_version</span><span class="p">)</span>

                <span class="c1"># Set the default filter properties.</span>
                <span class="n">newfilters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_new_filters</span>
                <span class="k">if</span> <span class="n">newfilters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># If no filters have been passed in the constructor,</span>
                    <span class="c1"># inherit them from the parent group, but only if they</span>
                    <span class="c1"># have been inherited or explicitly set.</span>
                    <span class="n">newfilters</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_v_parent</span><span class="o">.</span><span class="n">_v_attrs</span><span class="p">,</span> <span class="s1">&#39;FILTERS&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">newfilters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">set_attr</span><span class="p">(</span><span class="s1">&#39;FILTERS&#39;</span><span class="p">,</span> <span class="n">newfilters</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If the file has PyTables format, get the VERSION attr</span>
            <span class="k">if</span> <span class="s1">&#39;VERSION&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">_v_attrnamessys</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_v_version</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">VERSION</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_v_version</span> <span class="o">=</span> <span class="s2">&quot;0.0 (unknown)&quot;</span>
            <span class="c1"># We don&#39;t need to get more attributes from disk,</span>
            <span class="c1"># since the most important ones are defined as properties.</span>


    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_isopen</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_node_manager</span><span class="o">.</span><span class="n">registry</span> <span class="ow">and</span>
                <span class="s1">&#39;_v_children&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">):</span>
            <span class="c1"># The group is going to be killed.  Rebuild weak references</span>
            <span class="c1"># (that Python cancelled just before calling this method) so</span>
            <span class="c1"># that they are still usable if the object is revived later.</span>
            <span class="n">selfref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_children</span><span class="o">.</span><span class="n">containerref</span> <span class="o">=</span> <span class="n">selfref</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_groups</span><span class="o">.</span><span class="n">containerref</span> <span class="o">=</span> <span class="n">selfref</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_leaves</span><span class="o">.</span><span class="n">containerref</span> <span class="o">=</span> <span class="n">selfref</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_links</span><span class="o">.</span><span class="n">containerref</span> <span class="o">=</span> <span class="n">selfref</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_unknown</span><span class="o">.</span><span class="n">containerref</span> <span class="o">=</span> <span class="n">selfref</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_hidden</span><span class="o">.</span><span class="n">containerref</span> <span class="o">=</span> <span class="n">selfref</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">Group</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__del__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_g_get_child_group_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">childname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the class of a not-yet-loaded group child.</span>

<span class="sd">        `childname` must be the name of a *group* child.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">childCID</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g_get_gchild_attr</span><span class="p">(</span><span class="n">childname</span><span class="p">,</span> <span class="s1">&#39;CLASS&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">childCID</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">childCID</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">childCID</span> <span class="o">=</span> <span class="n">childCID</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">childCID</span> <span class="ow">in</span> <span class="n">class_id_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">class_id_dict</span><span class="p">[</span><span class="n">childCID</span><span class="p">]</span>  <span class="c1"># look up group class</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Group</span>  <span class="c1"># default group class</span>


    <span class="k">def</span> <span class="nf">_g_get_child_leaf_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">childname</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the class of a not-yet-loaded leaf child.</span>

<span class="sd">        `childname` must be the name of a *leaf* child.  If the child</span>
<span class="sd">        belongs to an unknown kind of leaf, or if its kind can not be</span>
<span class="sd">        guessed, `UnImplemented` will be returned and a warning will be</span>
<span class="sd">        issued if `warn` is true.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;PYTABLES_SYS_ATTRS&#39;</span><span class="p">]:</span>
            <span class="n">childCID</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g_get_lchild_attr</span><span class="p">(</span><span class="n">childname</span><span class="p">,</span> <span class="s1">&#39;CLASS&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">childCID</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">childCID</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">childCID</span> <span class="o">=</span> <span class="n">childCID</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">childCID</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">childCID</span> <span class="ow">in</span> <span class="n">class_id_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">class_id_dict</span><span class="p">[</span><span class="n">childCID</span><span class="p">]</span>  <span class="c1"># look up leaf class</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Unknown or no ``CLASS`` attribute, try a guess.</span>
            <span class="n">childCID2</span> <span class="o">=</span> <span class="n">utilsextension</span><span class="o">.</span><span class="n">which_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_objectid</span><span class="p">,</span> <span class="n">childname</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">childCID2</span> <span class="o">==</span> <span class="s1">&#39;UNSUPPORTED&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">warn</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">childCID</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="s2">&quot;leaf ``</span><span class="si">%s</span><span class="s2">`` is of an unsupported type; &quot;</span>
                            <span class="s2">&quot;it will become an ``UnImplemented`` node&quot;</span>
                            <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g_join</span><span class="p">(</span><span class="n">childname</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="p">(</span><span class="s2">&quot;leaf ``</span><span class="si">%s</span><span class="s2">`` has an unknown class ID ``</span><span class="si">%s</span><span class="s2">``; &quot;</span>
                             <span class="s2">&quot;it will become an ``UnImplemented`` node&quot;</span><span class="p">)</span>
                            <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_g_join</span><span class="p">(</span><span class="n">childname</span><span class="p">),</span> <span class="n">childCID</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">UnImplemented</span>
            <span class="k">assert</span> <span class="n">childCID2</span> <span class="ow">in</span> <span class="n">class_id_dict</span>
            <span class="k">return</span> <span class="n">class_id_dict</span><span class="p">[</span><span class="n">childCID2</span><span class="p">]</span>  <span class="c1"># look up leaf class</span>


    <span class="k">def</span> <span class="nf">_g_add_children_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add children names to this group taking into account their</span>
<span class="sd">        visibility and kind.&quot;&quot;&quot;</span>

        <span class="n">mydict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>

        <span class="c1"># The names of the lazy attributes</span>
        <span class="n">mydict</span><span class="p">[</span><span class="s1">&#39;__members__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">members</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="sd">&quot;&quot;&quot;The names of visible children nodes for readline-style completion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mydict</span><span class="p">[</span><span class="s1">&#39;_v_children&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">children</span> <span class="o">=</span> <span class="n">_ChildrenDict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The number of children hanging from this group.&quot;&quot;&quot;</span>
        <span class="n">mydict</span><span class="p">[</span><span class="s1">&#39;_v_groups&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">groups</span> <span class="o">=</span> <span class="n">_ChildrenDict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;Dictionary with all groups hanging from this group.&quot;&quot;&quot;</span>
        <span class="n">mydict</span><span class="p">[</span><span class="s1">&#39;_v_leaves&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">leaves</span> <span class="o">=</span> <span class="n">_ChildrenDict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;Dictionary with all leaves hanging from this group.&quot;&quot;&quot;</span>
        <span class="n">mydict</span><span class="p">[</span><span class="s1">&#39;_v_links&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">links</span> <span class="o">=</span> <span class="n">_ChildrenDict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;Dictionary with all links hanging from this group.&quot;&quot;&quot;</span>
        <span class="n">mydict</span><span class="p">[</span><span class="s1">&#39;_v_unknown&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unknown</span> <span class="o">=</span> <span class="n">_ChildrenDict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;Dictionary with all unknown nodes hanging from this group.&quot;&quot;&quot;</span>
        <span class="n">mydict</span><span class="p">[</span><span class="s1">&#39;_v_hidden&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hidden</span> <span class="o">=</span> <span class="n">_ChildrenDict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;Dictionary with all hidden nodes hanging from this group.&quot;&quot;&quot;</span>

        <span class="c1"># Get the names of *all* child groups and leaves.</span>
        <span class="p">(</span><span class="n">group_names</span><span class="p">,</span> <span class="n">leaf_names</span><span class="p">,</span> <span class="n">link_names</span><span class="p">,</span> <span class="n">unknown_names</span><span class="p">)</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_g_list_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_parent</span><span class="p">)</span>

        <span class="c1"># Separate groups into visible groups and hidden nodes,</span>
        <span class="c1"># and leaves into visible leaves and hidden nodes.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">childnames</span><span class="p">,</span> <span class="n">childdict</span><span class="p">)</span> <span class="ow">in</span> <span class="p">((</span><span class="n">group_names</span><span class="p">,</span> <span class="n">groups</span><span class="p">),</span>
                                        <span class="p">(</span><span class="n">leaf_names</span><span class="p">,</span> <span class="n">leaves</span><span class="p">),</span>
                                        <span class="p">(</span><span class="n">link_names</span><span class="p">,</span> <span class="n">links</span><span class="p">),</span>
                                        <span class="p">(</span><span class="n">unknown_names</span><span class="p">,</span> <span class="n">unknown</span><span class="p">)):</span>

            <span class="k">for</span> <span class="n">childname</span> <span class="ow">in</span> <span class="n">childnames</span><span class="p">:</span>
                <span class="c1"># See whether the name implies that the node is hidden.</span>
                <span class="c1"># (Assigned values are entirely irrelevant.)</span>
                <span class="k">if</span> <span class="n">isvisiblename</span><span class="p">(</span><span class="n">childname</span><span class="p">):</span>
                    <span class="c1"># Visible node.</span>
                    <span class="n">members</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">childname</span><span class="p">)</span>
                    <span class="n">children</span><span class="p">[</span><span class="n">childname</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">childdict</span><span class="p">[</span><span class="n">childname</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Hidden node.</span>
                    <span class="n">hidden</span><span class="p">[</span><span class="n">childname</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>


    <span class="k">def</span> <span class="nf">_g_check_has_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether &#39;name&#39; is a children of &#39;self&#39; and return its type.&quot;&quot;&quot;</span>

        <span class="c1"># Get the HDF5 name matching the PyTables name.</span>
        <span class="n">node_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g_get_objinfo</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node_type</span> <span class="o">==</span> <span class="s2">&quot;NoSuchNode&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoSuchNodeError</span><span class="p">(</span>
                <span class="s2">&quot;group ``</span><span class="si">%s</span><span class="s2">`` does not have a child named ``</span><span class="si">%s</span><span class="s2">``&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">node_type</span>


<div class="viewcode-block" id="Group.__iter__"><a class="viewcode-back" href="../../usersguide/libref/hierarchy_classes.html#tables.Group.__iter__">[docs]</a>    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over the child nodes hanging directly from the group.</span>

<span class="sd">        This iterator is *not* recursive.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            # Non-recursively list all the nodes hanging from &#39;/detector&#39;</span>
<span class="sd">            print(&quot;Nodes in &#39;/detector&#39; group:&quot;)</span>
<span class="sd">            for node in h5file.root.detector:</span>
<span class="sd">                print(node)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f_iter_nodes</span><span class="p">()</span></div>

<div class="viewcode-block" id="Group.__contains__"><a class="viewcode-back" href="../../usersguide/libref/hierarchy_classes.html#tables.Group.__contains__">[docs]</a>    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Is there a child with that `name`?</span>

<span class="sd">        Returns a true value if the group has a child node (visible or</span>
<span class="sd">        hidden) with the given `name` (a string), false otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_open</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_has_child</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">NoSuchNodeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Group._f_walknodes"><a class="viewcode-back" href="../../usersguide/libref/hierarchy_classes.html#tables.Group._f_walknodes">[docs]</a>    <span class="k">def</span> <span class="nf">_f_walknodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">classname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over descendant nodes.</span>

<span class="sd">        This method recursively walks *self* top to bottom (preorder),</span>
<span class="sd">        iterating over child groups in alphanumerical order, and yielding</span>
<span class="sd">        nodes.  If classname is supplied, only instances of the named class are</span>
<span class="sd">        yielded.</span>

<span class="sd">        If *classname* is Group, it behaves like :meth:`Group._f_walk_groups`,</span>
<span class="sd">        yielding only groups.  If you don&#39;t want a recursive behavior,</span>
<span class="sd">        use :meth:`Group._f_iter_nodes` instead.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            # Recursively print all the arrays hanging from &#39;/&#39;</span>
<span class="sd">            print(&quot;Arrays in the object tree &#39;/&#39;:&quot;)</span>
<span class="sd">            for array in h5file.root._f_walknodes(&#39;Array&#39;, recursive=True):</span>
<span class="sd">                print(array)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_open</span><span class="p">()</span>

        <span class="c1"># For compatibility with old default arguments.</span>
        <span class="k">if</span> <span class="n">classname</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">classname</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">classname</span> <span class="o">==</span> <span class="s2">&quot;Group&quot;</span><span class="p">:</span>
            <span class="c1"># Recursive algorithm</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f_walk_groups</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">group</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f_walk_groups</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">group</span><span class="o">.</span><span class="n">_f_iter_nodes</span><span class="p">(</span><span class="n">classname</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">leaf</span></div>


    <span class="k">def</span> <span class="nf">_g_join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper method to correctly concatenate a name child object with the</span>
<span class="sd">        pathname of this group.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;/&quot;</span><span class="p">:</span>
            <span class="c1"># This case can happen when doing copies</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span>
        <span class="k">return</span> <span class="n">join_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_g_width_warning</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Issue a :exc:`PerformanceWarning` on too many children.&quot;&quot;&quot;</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">group ``</span><span class="si">%s</span><span class="s2">`` is exceeding the recommended maximum number of children (</span><span class="si">%d</span><span class="s2">); </span><span class="se">\</span>
<span class="s2">be ready to see PyTables asking for *lots* of memory and possibly slow I/O.&quot;&quot;&quot;</span>
                      <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_max_group_width</span><span class="p">),</span>
                      <span class="n">PerformanceWarning</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_g_refnode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">childnode</span><span class="p">,</span> <span class="n">childname</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Insert references to a `childnode` via a `childname`.</span>

<span class="sd">        Checks that the `childname` is valid and does not exist, then</span>
<span class="sd">        creates references to the given `childnode` by that `childname`.</span>
<span class="sd">        The validation of the name can be omitted by setting `validate`</span>
<span class="sd">        to a false value (this may be useful for adding already existing</span>
<span class="sd">        nodes to the tree).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check for name validity.</span>
        <span class="k">if</span> <span class="n">validate</span><span class="p">:</span>
            <span class="n">check_name_validity</span><span class="p">(</span><span class="n">childname</span><span class="p">)</span>
            <span class="n">childnode</span><span class="o">.</span><span class="n">_g_check_name</span><span class="p">(</span><span class="n">childname</span><span class="p">)</span>

        <span class="c1"># Check if there is already a child with the same name.</span>
        <span class="c1"># This can be triggered because of the user</span>
        <span class="c1"># (via node construction or renaming/movement).</span>
        <span class="c1"># Links are not checked here because they are copied and referenced</span>
        <span class="c1"># using ``File.get_node`` so they already exist in `self`.</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">childnode</span><span class="p">,</span> <span class="n">Link</span><span class="p">))</span> <span class="ow">and</span> <span class="n">childname</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NodeError</span><span class="p">(</span>
                <span class="s2">&quot;group ``</span><span class="si">%s</span><span class="s2">`` already has a child node named ``</span><span class="si">%s</span><span class="s2">``&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span> <span class="n">childname</span><span class="p">))</span>

        <span class="c1"># Show a warning if there is an object attribute with that name.</span>
        <span class="k">if</span> <span class="n">childname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;group ``</span><span class="si">%s</span><span class="s2">`` already has an attribute named ``</span><span class="si">%s</span><span class="s2">``; &quot;</span>
                <span class="s2">&quot;you will not be able to use natural naming &quot;</span>
                <span class="s2">&quot;to access the child node&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span> <span class="n">childname</span><span class="p">),</span> <span class="n">NaturalNameWarning</span><span class="p">)</span>

        <span class="c1"># Check group width limits.</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_children</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_hidden</span><span class="p">)</span> <span class="o">&gt;=</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_v_max_group_width</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_g_width_warning</span><span class="p">()</span>

        <span class="c1"># Update members information.</span>
        <span class="c1"># Insert references to the new child.</span>
        <span class="c1"># (Assigned values are entirely irrelevant.)</span>
        <span class="k">if</span> <span class="n">isvisiblename</span><span class="p">(</span><span class="n">childname</span><span class="p">):</span>
            <span class="c1"># Visible node.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__members__</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">childname</span><span class="p">)</span>  <span class="c1"># enable completion</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_children</span><span class="p">[</span><span class="n">childname</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># insert node</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">childnode</span><span class="p">,</span> <span class="n">Unknown</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_v_unknown</span><span class="p">[</span><span class="n">childname</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">childnode</span><span class="p">,</span> <span class="n">Link</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_v_links</span><span class="p">[</span><span class="n">childname</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">childnode</span><span class="p">,</span> <span class="n">Leaf</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_v_leaves</span><span class="p">[</span><span class="n">childname</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">childnode</span><span class="p">,</span> <span class="n">Group</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_v_groups</span><span class="p">[</span><span class="n">childname</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Hidden node.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_hidden</span><span class="p">[</span><span class="n">childname</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># insert node</span>


    <span class="k">def</span> <span class="nf">_g_unrefnode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">childname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove references to a node.</span>

<span class="sd">        Removes all references to the named node.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># This can *not* be triggered because of the user.</span>
        <span class="k">assert</span> <span class="n">childname</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">,</span> \
            <span class="p">(</span><span class="s2">&quot;group ``</span><span class="si">%s</span><span class="s2">`` does not have a child node named ``</span><span class="si">%s</span><span class="s2">``&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span> <span class="n">childname</span><span class="p">))</span>

        <span class="c1"># Update members information, if needed</span>
        <span class="k">if</span> <span class="s1">&#39;_v_children&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">childname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_children</span><span class="p">:</span>
                <span class="c1"># Visible node.</span>
                <span class="n">members</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__members__</span>
                <span class="n">member_index</span> <span class="o">=</span> <span class="n">members</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">childname</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">members</span><span class="p">[</span><span class="n">member_index</span><span class="p">]</span>  <span class="c1"># disables completion</span>

                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_children</span><span class="p">[</span><span class="n">childname</span><span class="p">]</span>  <span class="c1"># remove node</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_v_unknown</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">childname</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_v_links</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">childname</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_v_leaves</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">childname</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_v_groups</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">childname</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Hidden node.</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_hidden</span><span class="p">[</span><span class="n">childname</span><span class="p">]</span>  <span class="c1"># remove node</span>


    <span class="k">def</span> <span class="nf">_g_move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newparent</span><span class="p">,</span> <span class="n">newname</span><span class="p">):</span>
        <span class="c1"># Move the node to the new location.</span>
        <span class="n">oldpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Group</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_g_move</span><span class="p">(</span><span class="n">newparent</span><span class="p">,</span> <span class="n">newname</span><span class="p">)</span>
        <span class="n">newpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span>

        <span class="c1"># Update location information in children.  This node shouldn&#39;t</span>
        <span class="c1"># be affected since it has already been relocated.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_update_node_locations</span><span class="p">(</span><span class="n">oldpath</span><span class="p">,</span> <span class="n">newpath</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_g_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newparent</span><span class="p">,</span> <span class="n">newname</span><span class="p">,</span> <span class="n">recursive</span><span class="p">,</span> <span class="n">_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Compute default arguments.</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_title</span><span class="p">)</span>
        <span class="n">filters</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;filters&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;stats&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Fix arguments with explicit None values for backwards compatibility.</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_title</span>
        <span class="c1"># If no filters have been passed to the call, copy them from the</span>
        <span class="c1"># source group, but only if inherited or explicitly set.</span>
        <span class="k">if</span> <span class="n">filters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filters</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="p">,</span> <span class="s1">&#39;FILTERS&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Create a copy of the object.</span>
        <span class="n">new_node</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">newparent</span><span class="p">,</span> <span class="n">newname</span><span class="p">,</span>
                         <span class="n">title</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">,</span> <span class="n">_log</span><span class="o">=</span><span class="n">_log</span><span class="p">)</span>

        <span class="c1"># Copy user attributes if needed.</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;copyuserattrs&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">_g_copy</span><span class="p">(</span><span class="n">new_node</span><span class="o">.</span><span class="n">_v_attrs</span><span class="p">,</span> <span class="n">copyclass</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Update statistics if needed.</span>
        <span class="k">if</span> <span class="n">stats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;groups&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">recursive</span><span class="p">:</span>
            <span class="c1"># Copy child nodes if a recursive copy was requested.</span>
            <span class="c1"># Some arguments should *not* be passed to children copy ops.</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_g_copy_children</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_node</span>

    <span class="k">def</span> <span class="nf">_g_copy_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newparent</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy child nodes.</span>

<span class="sd">        Copies all nodes descending from this one into the specified</span>
<span class="sd">        `newparent`.  If the new parent has a child node with the same</span>
<span class="sd">        name as one of the nodes in this group, the copy fails with a</span>
<span class="sd">        `NodeError`, maybe resulting in a partial copy.  Nothing is</span>
<span class="sd">        logged.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Recursive version of children copy.</span>
        <span class="c1"># for srcchild in self._v_children.itervalues():</span>
        <span class="c1">##    srcchild._g_copy_as_child(newparent, **kwargs)</span>

        <span class="c1"># Non-recursive version of children copy.</span>
        <span class="n">use_hardlinks</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;use_hardlinks&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_hardlinks</span><span class="p">:</span>
            <span class="n">address_map</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;address_map&#39;</span><span class="p">,</span> <span class="p">{})</span>

        <span class="n">parentstack</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newparent</span><span class="p">)]</span>  <span class="c1"># [(source, destination), ...]</span>
        <span class="k">while</span> <span class="n">parentstack</span><span class="p">:</span>
            <span class="p">(</span><span class="n">srcparent</span><span class="p">,</span> <span class="n">dstparent</span><span class="p">)</span> <span class="o">=</span> <span class="n">parentstack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">use_hardlinks</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">srcchild</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">srcparent</span><span class="o">.</span><span class="n">_v_children</span><span class="p">):</span>
                    <span class="n">addr</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">srcchild</span><span class="o">.</span><span class="n">_get_obj_info</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">rc</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">addr</span> <span class="ow">in</span> <span class="n">address_map</span><span class="p">:</span>
                        <span class="n">where</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">address_map</span><span class="p">[</span><span class="n">addr</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">localsrc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                        <span class="n">dstparent</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">create_hard_link</span><span class="p">(</span><span class="n">dstparent</span><span class="p">,</span>
                                                           <span class="n">srcchild</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                                           <span class="n">localsrc</span><span class="p">)</span>
                        <span class="n">address_map</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">dstparent</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span> <span class="n">srcchild</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                        <span class="p">)</span>

                        <span class="c1"># Update statistics if needed.</span>
                        <span class="n">stats</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;stats&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">stats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;hardlinks&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dstchild</span> <span class="o">=</span> <span class="n">srcchild</span><span class="o">.</span><span class="n">_g_copy_as_child</span><span class="p">(</span><span class="n">dstparent</span><span class="p">,</span>
                                                             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">srcchild</span><span class="p">,</span> <span class="n">Group</span><span class="p">):</span>
                            <span class="n">parentstack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">srcchild</span><span class="p">,</span> <span class="n">dstchild</span><span class="p">))</span>

                        <span class="k">if</span> <span class="n">rc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">address_map</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                                <span class="p">(</span><span class="n">dstparent</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span> <span class="n">srcchild</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                            <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">srcchild</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">srcparent</span><span class="o">.</span><span class="n">_v_children</span><span class="p">):</span>
                    <span class="n">dstchild</span> <span class="o">=</span> <span class="n">srcchild</span><span class="o">.</span><span class="n">_g_copy_as_child</span><span class="p">(</span><span class="n">dstparent</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">srcchild</span><span class="p">,</span> <span class="n">Group</span><span class="p">):</span>
                        <span class="n">parentstack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">srcchild</span><span class="p">,</span> <span class="n">dstchild</span><span class="p">))</span>


<div class="viewcode-block" id="Group._f_get_child"><a class="viewcode-back" href="../../usersguide/libref/hierarchy_classes.html#tables.Group._f_get_child">[docs]</a>    <span class="k">def</span> <span class="nf">_f_get_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">childname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the child called childname of this group.</span>

<span class="sd">        If the child exists (be it visible or not), it is returned.  Else, a</span>
<span class="sd">        NoSuchNodeError is raised.</span>

<span class="sd">        Using this method is recommended over getattr() when doing programmatic</span>
<span class="sd">        accesses to children if childname is unknown beforehand or when its</span>
<span class="sd">        name is not a valid Python identifier.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_open</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_has_child</span><span class="p">(</span><span class="n">childname</span><span class="p">)</span>

        <span class="n">childpath</span> <span class="o">=</span> <span class="n">join_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span> <span class="n">childname</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_get_node</span><span class="p">(</span><span class="n">childpath</span><span class="p">)</span></div>


<div class="viewcode-block" id="Group._f_list_nodes"><a class="viewcode-back" href="../../usersguide/libref/hierarchy_classes.html#tables.Group._f_list_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">_f_list_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">classname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a *list* with children nodes.</span>

<span class="sd">        This is a list-returning version of :meth:`Group._f_iter_nodes()`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f_iter_nodes</span><span class="p">(</span><span class="n">classname</span><span class="p">))</span></div>


<div class="viewcode-block" id="Group._f_iter_nodes"><a class="viewcode-back" href="../../usersguide/libref/hierarchy_classes.html#tables.Group._f_iter_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">_f_iter_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">classname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over children nodes.</span>

<span class="sd">        Child nodes are yielded alphanumerically sorted by node name.  If the</span>
<span class="sd">        name of a class derived from Node (see :ref:`NodeClassDescr`) is</span>
<span class="sd">        supplied in the classname parameter, only instances of that class (or</span>
<span class="sd">        subclasses of it) will be returned.</span>

<span class="sd">        This is an iterator version of :meth:`Group._f_list_nodes`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_open</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">classname</span><span class="p">:</span>
            <span class="c1"># Returns all the children alphanumerically sorted</span>
            <span class="n">names</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_children</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_children</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">classname</span> <span class="o">==</span> <span class="s1">&#39;Group&#39;</span><span class="p">:</span>
            <span class="c1"># Returns all the groups alphanumerically sorted</span>
            <span class="n">names</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_groups</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_groups</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">classname</span> <span class="o">==</span> <span class="s1">&#39;Leaf&#39;</span><span class="p">:</span>
            <span class="c1"># Returns all the leaves alphanumerically sorted</span>
            <span class="n">names</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_leaves</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_leaves</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">classname</span> <span class="o">==</span> <span class="s1">&#39;Link&#39;</span><span class="p">:</span>
            <span class="c1"># Returns all the links alphanumerically sorted</span>
            <span class="n">names</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_links</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_links</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">classname</span> <span class="o">==</span> <span class="s1">&#39;IndexArray&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;listing ``IndexArray`` nodes is not allowed&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">class_</span> <span class="o">=</span> <span class="n">get_class_by_name</span><span class="p">(</span><span class="n">classname</span><span class="p">)</span>

            <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_children</span>
            <span class="n">childnames</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">(</span><span class="n">children</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">childname</span> <span class="ow">in</span> <span class="n">childnames</span><span class="p">:</span>
                <span class="n">childnode</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">childname</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">childnode</span><span class="p">,</span> <span class="n">class_</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">childnode</span></div>


<div class="viewcode-block" id="Group._f_walk_groups"><a class="viewcode-back" href="../../usersguide/libref/hierarchy_classes.html#tables.Group._f_walk_groups">[docs]</a>    <span class="k">def</span> <span class="nf">_f_walk_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recursively iterate over descendent groups (not leaves).</span>

<span class="sd">        This method starts by yielding *self*, and then it goes on to</span>
<span class="sd">        recursively iterate over all child groups in alphanumerical order, top</span>
<span class="sd">        to bottom (preorder), following the same procedure.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_open</span><span class="p">()</span>

        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">yield</span> <span class="bp">self</span>
        <span class="c1"># Iterate over the descendants</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">objgroup</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">groupnames</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">(</span><span class="n">objgroup</span><span class="o">.</span><span class="n">_v_groups</span><span class="p">))</span>
            <span class="c1"># Sort the groups before delivering. This uses the groups names</span>
            <span class="c1"># for groups in tree (in order to sort() can classify them).</span>
            <span class="k">for</span> <span class="n">groupname</span> <span class="ow">in</span> <span class="n">groupnames</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">objgroup</span><span class="o">.</span><span class="n">_v_groups</span><span class="p">[</span><span class="n">groupname</span><span class="p">])</span>
                <span class="k">yield</span> <span class="n">objgroup</span><span class="o">.</span><span class="n">_v_groups</span><span class="p">[</span><span class="n">groupname</span><span class="p">]</span></div>


<div class="viewcode-block" id="Group.__delattr__"><a class="viewcode-back" href="../../usersguide/libref/hierarchy_classes.html#tables.Group.__delattr__">[docs]</a>    <span class="k">def</span> <span class="nf">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete a Python attribute called name.</span>

<span class="sd">        This method only provides a extra warning in case the user</span>
<span class="sd">        tries to delete a children node using __delattr__.</span>

<span class="sd">        To remove a children node from this group use</span>
<span class="sd">        :meth:`File.remove_node` or :meth:`Node._f_remove`. To delete</span>
<span class="sd">        a PyTables node attribute use :meth:`File.del_node_attr`,</span>
<span class="sd">        :meth:`Node._f_delattr` or :attr:`Node._v_attrs``.</span>

<span class="sd">        If there is an attribute and a child node with the same name,</span>
<span class="sd">        the child node will be made accessible again via natural naming.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">Group</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__delattr__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># nothing particular</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">ae</span><span class="p">:</span>
            <span class="n">hint</span> <span class="o">=</span> <span class="s2">&quot; (use ``node._f_remove()`` if you want to remove a node)&quot;</span>
            <span class="k">raise</span> <span class="n">ae</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ae</span><span class="p">)</span> <span class="o">+</span> <span class="n">hint</span><span class="p">)</span></div>

<div class="viewcode-block" id="Group.__getattr__"><a class="viewcode-back" href="../../usersguide/libref/hierarchy_classes.html#tables.Group.__getattr__">[docs]</a>    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a Python attribute or child node called name.</span>
<span class="sd">        If the node has a child node called name it is returned,</span>
<span class="sd">        else an AttributeError is raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_lazy_children_attrs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_g_add_children_names</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f_get_child</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Group.__setattr__"><a class="viewcode-back" href="../../usersguide/libref/hierarchy_classes.html#tables.Group.__setattr__">[docs]</a>    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set a Python attribute called name with the given value.</span>

<span class="sd">        This method stores an *ordinary Python attribute* in the object. It</span>
<span class="sd">        does *not* store new children nodes under this group; for that, use the</span>
<span class="sd">        File.create*() methods (see the File class</span>
<span class="sd">        in :ref:`FileClassDescr`). It does *neither* store a PyTables node</span>
<span class="sd">        attribute; for that,</span>
<span class="sd">        use :meth:`File.set_node_attr`, :meth`:Node._f_setattr`</span>
<span class="sd">        or :attr:`Node._v_attrs`.</span>

<span class="sd">        If there is already a child node with the same name, a</span>
<span class="sd">        NaturalNameWarning will be issued and the child node will not be</span>
<span class="sd">        accessible via natural naming nor getattr(). It will still be available</span>
<span class="sd">        via :meth:`File.get_node`, :meth:`Group._f_get_child` and children</span>
<span class="sd">        dictionaries in the group (if visible).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Show a warning if there is an child node with that name.</span>
        <span class="c1">#</span>
        <span class="c1"># ..note::</span>
        <span class="c1">#</span>
        <span class="c1">#   Using ``if name in self:`` is not right since that would</span>
        <span class="c1">#   require ``_v_children`` and ``_v_hidden`` to be already set</span>
        <span class="c1">#   when the very first attribute assignments are made.</span>
        <span class="c1">#   Moreover, this warning is only concerned about clashes with</span>
        <span class="c1">#   names used in natural naming, i.e. those in ``__members__``.</span>
        <span class="c1">#</span>
        <span class="c1"># ..note::</span>
        <span class="c1">#</span>
        <span class="c1">#   The check ``&#39;__members__&#39; in myDict`` allows attribute</span>
        <span class="c1">#   assignment to happen before calling `Group.__init__()`, by</span>
        <span class="c1">#   avoiding to look into the still not assigned ``__members__``</span>
        <span class="c1">#   attribute.  This allows subclasses to set up some attributes</span>
        <span class="c1">#   and then call the constructor of the superclass.  If the</span>
        <span class="c1">#   check above is disabled, that results in Python entering an</span>
        <span class="c1">#   endless loop on exit!</span>

        <span class="n">mydict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="k">if</span> <span class="s1">&#39;__members__&#39;</span> <span class="ow">in</span> <span class="n">mydict</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__members__</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;group ``</span><span class="si">%s</span><span class="s2">`` already has a child node named ``</span><span class="si">%s</span><span class="s2">``; &quot;</span>
                <span class="s2">&quot;you will not be able to use natural naming &quot;</span>
                <span class="s2">&quot;to access the child node&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span> <span class="n">NaturalNameWarning</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">Group</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_f_flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Flush this Group.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_open</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_g_flush_group</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_g_close_descendents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Close all the *loaded* descendent nodes of this group.&quot;&quot;&quot;</span>

        <span class="n">node_manager</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_node_manager</span>
        <span class="n">node_manager</span><span class="o">.</span><span class="n">close_subtree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_g_close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Close this (open) group.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_isopen</span><span class="p">:</span>
            <span class="c1"># hdf5extension operations:</span>
            <span class="c1">#   Close HDF5 group.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_g_close_group</span><span class="p">()</span>

        <span class="c1"># Close myself as a node.</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Group</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_f_close</span><span class="p">()</span>

<div class="viewcode-block" id="Group._f_close"><a class="viewcode-back" href="../../usersguide/libref/hierarchy_classes.html#tables.Group._f_close">[docs]</a>    <span class="k">def</span> <span class="nf">_f_close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Close this group and all its descendents.</span>

<span class="sd">        This method has the behavior described in :meth:`Node._f_close`.</span>
<span class="sd">        It should be noted that this operation closes all the nodes</span>
<span class="sd">        descending from this group.</span>

<span class="sd">        You should not need to close nodes manually because they are</span>
<span class="sd">        automatically opened/closed when they are loaded/evicted from</span>
<span class="sd">        the integrated LRU cache.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If the group is already closed, return immediately</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_isopen</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># First, close all the descendents of this group, unless a) the</span>
        <span class="c1"># group is being deleted (evicted from LRU cache) or b) the node</span>
        <span class="c1"># is being closed during an aborted creation, in which cases</span>
        <span class="c1"># this is not an explicit close issued by the user.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v__deleting</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_objectid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_g_close_descendents</span><span class="p">()</span>

        <span class="c1"># When all the descendents have been closed, close this group.</span>
        <span class="c1"># This is done at the end because some nodes may still need to</span>
        <span class="c1"># be loaded during the closing process; thus this node must be</span>
        <span class="c1"># open until the very end.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_g_close</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_g_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove (recursively if needed) the Group.</span>

<span class="sd">        This version correctly handles both visible and hidden nodes.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_nchildren</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">recursive</span> <span class="ow">or</span> <span class="n">force</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">NodeError</span><span class="p">(</span><span class="s2">&quot;group ``</span><span class="si">%s</span><span class="s2">`` has child nodes; &quot;</span>
                                <span class="s2">&quot;please set `recursive` or `force` to true &quot;</span>
                                <span class="s2">&quot;to remove it&quot;</span>
                                <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,))</span>

            <span class="c1"># First close all the descendents hanging from this group,</span>
            <span class="c1"># so that it is not possible to use a node that no longer exists.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_g_close_descendents</span><span class="p">()</span>

        <span class="c1"># Remove the node itself from the hierarchy.</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Group</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_g_remove</span><span class="p">(</span><span class="n">recursive</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span>

<div class="viewcode-block" id="Group._f_copy"><a class="viewcode-back" href="../../usersguide/libref/hierarchy_classes.html#tables.Group._f_copy">[docs]</a>    <span class="k">def</span> <span class="nf">_f_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newparent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">newname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">createparents</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy this node and return the new one.</span>

<span class="sd">        This method has the behavior described in :meth:`Node._f_copy`.</span>
<span class="sd">        In addition, it recognizes the following keyword arguments:</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        title</span>
<span class="sd">            The new title for the destination. If omitted or None, the</span>
<span class="sd">            original title is used. This only applies to the topmost</span>
<span class="sd">            node in recursive copies.</span>
<span class="sd">        filters : Filters</span>
<span class="sd">            Specifying this parameter overrides the original filter</span>
<span class="sd">            properties in the source node. If specified, it must be an</span>
<span class="sd">            instance of the Filters class (see :ref:`FiltersClassDescr`).</span>
<span class="sd">            The default is to copy the filter properties from the source</span>
<span class="sd">            node.</span>
<span class="sd">        copyuserattrs</span>
<span class="sd">            You can prevent the user attributes from being copied by setting</span>
<span class="sd">            thisparameter to False. The default is to copy them.</span>
<span class="sd">        stats</span>
<span class="sd">            This argument may be used to collect statistics on the copy</span>
<span class="sd">            process. When used, it should be a dictionary with keys &#39;groups&#39;,</span>
<span class="sd">            &#39;leaves&#39;, &#39;links&#39; and &#39;bytes&#39; having a numeric value. Their values</span>
<span class="sd">            willbe incremented to reflect the number of groups, leaves and</span>
<span class="sd">            bytes, respectively, that have been copied during the operation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Group</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_f_copy</span><span class="p">(</span>
            <span class="n">newparent</span><span class="p">,</span> <span class="n">newname</span><span class="p">,</span>
            <span class="n">overwrite</span><span class="p">,</span> <span class="n">recursive</span><span class="p">,</span> <span class="n">createparents</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Group._f_copy_children"><a class="viewcode-back" href="../../usersguide/libref/hierarchy_classes.html#tables.Group._f_copy_children">[docs]</a>    <span class="k">def</span> <span class="nf">_f_copy_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dstgroup</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">createparents</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy the children of this group into another group.</span>

<span class="sd">        Children hanging directly from this group are copied into dstgroup,</span>
<span class="sd">        which can be a Group (see :ref:`GroupClassDescr`) object or its</span>
<span class="sd">        pathname in string form. If createparents is true, the needed groups</span>
<span class="sd">        for the given destination group path to exist will be created.</span>

<span class="sd">        The operation will fail with a NodeError if there is a child node</span>
<span class="sd">        in the destination group with the same name as one of the copied</span>
<span class="sd">        children from this one, unless overwrite is true; in this case,</span>
<span class="sd">        the former child node is recursively removed before copying the</span>
<span class="sd">        later.</span>

<span class="sd">        By default, nodes descending from children groups of this node</span>
<span class="sd">        are not copied. If the recursive argument is true, all descendant</span>
<span class="sd">        nodes of this node are recursively copied.</span>

<span class="sd">        Additional keyword arguments may be passed to customize the</span>
<span class="sd">        copying process. For instance, title and filters may be changed,</span>
<span class="sd">        user attributes may be or may not be copied, data may be sub-sampled,</span>
<span class="sd">        stats may be collected, etc. Arguments unknown to nodes are simply</span>
<span class="sd">        ignored. Check the documentation for copying operations of nodes to</span>
<span class="sd">        see which options they support.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_open</span><span class="p">()</span>

        <span class="c1"># `dstgroup` is used instead of its path to avoid accepting</span>
        <span class="c1"># `Node` objects when `createparents` is true.  Also, note that</span>
        <span class="c1"># there is no risk of creating parent nodes and failing later</span>
        <span class="c1"># because of destination nodes already existing.</span>
        <span class="n">dstparent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_get_or_create_path</span><span class="p">(</span><span class="n">dstgroup</span><span class="p">,</span> <span class="n">createparents</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_group</span><span class="p">(</span><span class="n">dstparent</span><span class="p">)</span>  <span class="c1"># Is it a group?</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="c1"># Abort as early as possible when destination nodes exist</span>
            <span class="c1"># and overwriting is not enabled.</span>
            <span class="k">for</span> <span class="n">childname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_children</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">childname</span> <span class="ow">in</span> <span class="n">dstparent</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">NodeError</span><span class="p">(</span>
                        <span class="s2">&quot;destination group ``</span><span class="si">%s</span><span class="s2">`` already has &quot;</span>
                        <span class="s2">&quot;a node named ``</span><span class="si">%s</span><span class="s2">``; &quot;</span>
                        <span class="s2">&quot;you may want to use the ``overwrite`` argument&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">dstparent</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span> <span class="n">childname</span><span class="p">))</span>

        <span class="n">use_hardlinks</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;use_hardlinks&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_hardlinks</span><span class="p">:</span>
            <span class="n">address_map</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;address_map&#39;</span><span class="p">,</span> <span class="p">{})</span>

            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_children</span><span class="p">):</span>
                <span class="n">addr</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">_get_obj_info</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">rc</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">addr</span> <span class="ow">in</span> <span class="n">address_map</span><span class="p">:</span>
                    <span class="n">where</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">address_map</span><span class="p">[</span><span class="n">addr</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">localsrc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                    <span class="n">dstparent</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">create_hard_link</span><span class="p">(</span><span class="n">dstparent</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                                       <span class="n">localsrc</span><span class="p">)</span>
                    <span class="n">address_map</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">dstparent</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="p">)</span>

                    <span class="c1"># Update statistics if needed.</span>
                    <span class="n">stats</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;stats&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">stats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;hardlinks&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">child</span><span class="o">.</span><span class="n">_f_copy</span><span class="p">(</span><span class="n">dstparent</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">recursive</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">rc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">address_map</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="p">(</span><span class="n">dstparent</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                        <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_children</span><span class="p">):</span>
                <span class="n">child</span><span class="o">.</span><span class="n">_f_copy</span><span class="p">(</span><span class="n">dstparent</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">recursive</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Group.__str__"><a class="viewcode-back" href="../../usersguide/libref/hierarchy_classes.html#tables.Group.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a short string representation of the group.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            &gt;&gt;&gt; f=tables.open_file(&#39;data/test.h5&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(f.root.group0)</span>
<span class="sd">            /group0 (Group) &#39;First Group&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pathname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span>
        <span class="n">classname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">title</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_title</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">) </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pathname</span><span class="p">,</span> <span class="n">classname</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span></div>

<div class="viewcode-block" id="Group.__repr__"><a class="viewcode-back" href="../../usersguide/libref/hierarchy_classes.html#tables.Group.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a detailed string representation of the group.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            &gt;&gt;&gt; f = tables.open_file(&#39;data/test.h5&#39;)</span>
<span class="sd">            &gt;&gt;&gt; f.root.group0</span>
<span class="sd">            /group0 (Group) &#39;First Group&#39;</span>
<span class="sd">              children := [&#39;tuple1&#39; (Table), &#39;group1&#39; (Group)]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rep</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;</span><span class="si">%r</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">childname</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">childname</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_children</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">childlist</span> <span class="o">=</span> <span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rep</span><span class="p">))</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">  children := </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">childlist</span><span class="p">)</span></div></div>


<span class="c1"># Special definition for group root</span>
<span class="k">class</span> <span class="nc">RootGroup</span><span class="p">(</span><span class="n">Group</span><span class="p">):</span>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ptfile</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">filters</span><span class="p">):</span>
        <span class="n">mydict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>

        <span class="c1"># Set group attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_version</span> <span class="o">=</span> <span class="n">obversion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_new</span> <span class="o">=</span> <span class="n">new</span>
        <span class="k">if</span> <span class="n">new</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_new_title</span> <span class="o">=</span> <span class="n">title</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_new_filters</span> <span class="o">=</span> <span class="n">filters</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_new_title</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_new_filters</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Set node attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span> <span class="o">=</span> <span class="n">ptfile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_isopen</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># root is always open</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span> <span class="o">=</span> <span class="s1">&#39;/&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_name</span> <span class="o">=</span> <span class="s1">&#39;/&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_depth</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_max_group_width</span> <span class="o">=</span> <span class="n">ptfile</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;MAX_GROUP_WIDTH&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v__deleting</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_objectid</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># later</span>

        <span class="c1"># Only the root node has the file as a parent.</span>
        <span class="c1"># Bypass __setattr__ to avoid the ``Node._v_parent`` property.</span>
        <span class="n">mydict</span><span class="p">[</span><span class="s1">&#39;_v_parent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptfile</span>
        <span class="n">ptfile</span><span class="o">.</span><span class="n">_node_manager</span><span class="o">.</span><span class="n">register_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>

        <span class="c1"># hdf5extension operations (do before setting an AttributeSet):</span>
        <span class="c1">#   Update node attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_g_new</span><span class="p">(</span><span class="n">ptfile</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1">#   Open the node and get its object ID.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_objectid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g_open</span><span class="p">()</span>

        <span class="c1"># Set disk attributes and read children names.</span>
        <span class="c1">#</span>
        <span class="c1"># This *must* be postponed because this method needs the root node</span>
        <span class="c1"># to be created and bound to ``File.root``.</span>
        <span class="c1"># This is an exception to the rule, handled by ``File.__init()__``.</span>
        <span class="c1">#</span>
        <span class="c1"># self._g_post_init_hook()</span>

    <span class="k">def</span> <span class="nf">_g_load_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">childname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load a child node from disk.</span>

<span class="sd">        The child node `childname` is loaded from disk and an adequate</span>
<span class="sd">        `Node` object is created and returned.  If there is no such</span>
<span class="sd">        child, a `NoSuchNodeError` is raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">root_uep</span> <span class="o">!=</span> <span class="s2">&quot;/&quot;</span><span class="p">:</span>
            <span class="n">childname</span> <span class="o">=</span> <span class="n">join_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">root_uep</span><span class="p">,</span> <span class="n">childname</span><span class="p">)</span>
        <span class="c1"># Is the node a group or a leaf?</span>
        <span class="n">node_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_has_child</span><span class="p">(</span><span class="n">childname</span><span class="p">)</span>

        <span class="c1"># Nodes that HDF5 report as H5G_UNKNOWN</span>
        <span class="k">if</span> <span class="n">node_type</span> <span class="o">==</span> <span class="s1">&#39;Unknown&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Unknown</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">childname</span><span class="p">)</span>

        <span class="c1"># Guess the PyTables class suited to the node,</span>
        <span class="c1"># build a PyTables node and return it.</span>
        <span class="k">if</span> <span class="n">node_type</span> <span class="o">==</span> <span class="s2">&quot;Group&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;PYTABLES_SYS_ATTRS&#39;</span><span class="p">]:</span>
                <span class="n">ChildClass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g_get_child_group_class</span><span class="p">(</span><span class="n">childname</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Default is a Group class</span>
                <span class="n">ChildClass</span> <span class="o">=</span> <span class="n">Group</span>
            <span class="k">return</span> <span class="n">ChildClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">childname</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">node_type</span> <span class="o">==</span> <span class="s2">&quot;Leaf&quot;</span><span class="p">:</span>
            <span class="n">ChildClass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g_get_child_leaf_class</span><span class="p">(</span><span class="n">childname</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Building a leaf may still fail because of unsupported types</span>
            <span class="c1"># and other causes.</span>
            <span class="c1"># return ChildClass(self, childname)  # uncomment for debugging</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ChildClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">childname</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>  <span class="c1"># XXX</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;problems loading leaf ``</span><span class="si">%s</span><span class="s2">``::</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;  </span><span class="si">%s</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;The leaf will become an ``UnImplemented`` node.&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_g_join</span><span class="p">(</span><span class="n">childname</span><span class="p">),</span> <span class="n">exc</span><span class="p">))</span>
                <span class="c1"># If not, associate an UnImplemented object to it</span>
                <span class="k">return</span> <span class="n">UnImplemented</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">childname</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">node_type</span> <span class="o">==</span> <span class="s2">&quot;SoftLink&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SoftLink</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">childname</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">node_type</span> <span class="o">==</span> <span class="s2">&quot;ExternalLink&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ExternalLink</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">childname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">UnImplemented</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">childname</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_f_rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newname</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">NodeError</span><span class="p">(</span><span class="s2">&quot;the root node can not be renamed&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_f_move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newparent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">newname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">createparents</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">NodeError</span><span class="p">(</span><span class="s2">&quot;the root node can not be moved&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_f_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">NodeError</span><span class="p">(</span><span class="s2">&quot;the root node can not be removed&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TransactionGroupG</span><span class="p">(</span><span class="n">NotLoggedMixin</span><span class="p">,</span> <span class="n">Group</span><span class="p">):</span>
    <span class="n">_c_classid</span> <span class="o">=</span> <span class="s1">&#39;TRANSGROUP&#39;</span>


    <span class="k">def</span> <span class="nf">_g_width_warning</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">the number of transactions is exceeding the recommended maximum (</span><span class="si">%d</span><span class="s2">);</span><span class="se">\</span>
<span class="s2">be ready to see PyTables asking for *lots* of memory and possibly slow I/O&quot;&quot;&quot;</span>
                      <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_max_group_width</span><span class="p">,),</span> <span class="n">PerformanceWarning</span><span class="p">)</span>



<span class="k">class</span> <span class="nc">TransactionG</span><span class="p">(</span><span class="n">NotLoggedMixin</span><span class="p">,</span> <span class="n">Group</span><span class="p">):</span>
    <span class="n">_c_classid</span> <span class="o">=</span> <span class="s1">&#39;TRANSG&#39;</span>


    <span class="k">def</span> <span class="nf">_g_width_warning</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">transaction ``</span><span class="si">%s</span><span class="s2">`` is exceeding the recommended maximum number of marks (</span><span class="si">%d</span><span class="s2">);</span><span class="se">\</span>
<span class="s2">be ready to see PyTables asking for *lots* of memory and possibly slow I/O&quot;&quot;&quot;</span>
                      <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_max_group_width</span><span class="p">),</span>
                      <span class="n">PerformanceWarning</span><span class="p">)</span>



<span class="k">class</span> <span class="nc">MarkG</span><span class="p">(</span><span class="n">NotLoggedMixin</span><span class="p">,</span> <span class="n">Group</span><span class="p">):</span>
    <span class="c1"># Class identifier.</span>
    <span class="n">_c_classid</span> <span class="o">=</span> <span class="s1">&#39;MARKG&#39;</span>


    <span class="kn">import</span> <span class="nn">re</span>
    <span class="n">_c_shadow_name_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^a[0-9]+$&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_g_width_warning</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">mark ``</span><span class="si">%s</span><span class="s2">`` is exceeding the recommended maximum action storage (</span><span class="si">%d</span><span class="s2"> nodes);</span><span class="se">\</span>
<span class="s2">be ready to see PyTables asking for *lots* of memory and possibly slow I/O&quot;&quot;&quot;</span>
                      <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_max_group_width</span><span class="p">),</span>
                      <span class="n">PerformanceWarning</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_g_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Empty action storage (nodes and attributes).</span>

<span class="sd">        This method empties all action storage kept in this node: nodes</span>
<span class="sd">        and attributes.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Remove action storage nodes.</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_children</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">child</span><span class="o">.</span><span class="n">_g_remove</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Remove action storage attributes.</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span>
        <span class="n">shname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_shadow_name_re</span>
        <span class="k">for</span> <span class="n">attrname</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">_v_attrnamesuser</span><span class="p">[:]:</span>
            <span class="k">if</span> <span class="n">shname</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">attrname</span><span class="p">):</span>
                <span class="n">attrs</span><span class="o">.</span><span class="n">_g__delattr</span><span class="p">(</span><span class="n">attrname</span><span class="p">)</span>


<span class="c1">## Local Variables:</span>
<span class="c1">## mode: python</span>
<span class="c1">## py-indent-offset: 4</span>
<span class="c1">## tab-width: 4</span>
<span class="c1">## fill-column: 72</span>
<span class="c1">## End:</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2011-2016, PyTables maintainers.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'3.4.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>