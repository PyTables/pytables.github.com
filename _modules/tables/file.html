

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>tables.file &mdash; PyTables 3.4.2 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="PyTables 3.4.2 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/>
 
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-111342564-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-111342564-1');
</script>



  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/logo-pytables-small.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                3.4.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../usersguide/index.html">Userâ€™s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cookbook/index.html">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../other_material.html">Other Material</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../MIGRATING_TO_3.x.html">Migrating from 2.x to 3.x</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../downloads.html">Downloads</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release_notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../project_pointers.html">Project pointers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev_team.html">Development Team</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PyTables</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>tables.file</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for tables.file</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="c1">########################################################################</span>
<span class="c1">#</span>
<span class="c1"># License: BSD</span>
<span class="c1"># Created: September 4, 2002</span>
<span class="c1"># Author: Francesc Alted - faltet@pytables.com</span>
<span class="c1">#</span>
<span class="c1"># $Id$</span>
<span class="c1">#</span>
<span class="c1">########################################################################</span>

<span class="sd">&quot;&quot;&quot;Create PyTables files and the object tree.</span>

<span class="sd">This module support importing generic HDF5 files, on top of which</span>
<span class="sd">PyTables files are created, read or extended. If a file exists, an</span>
<span class="sd">object tree mirroring their hierarchical structure is created in memory.</span>
<span class="sd">File class offer methods to traverse the tree, as well as to create new</span>
<span class="sd">nodes.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">collections</span>

<span class="kn">import</span> <span class="nn">numexpr</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">hdf5extension</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">utilsextension</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">parameters</span>
<span class="kn">from</span> <span class="nn">.exceptions</span> <span class="k">import</span> <span class="p">(</span><span class="n">ClosedFileError</span><span class="p">,</span> <span class="n">FileModeError</span><span class="p">,</span> <span class="n">NodeError</span><span class="p">,</span>
                               <span class="n">NoSuchNodeError</span><span class="p">,</span> <span class="n">UndoRedoError</span><span class="p">,</span> <span class="n">ClosedNodeError</span><span class="p">,</span>
                               <span class="n">PerformanceWarning</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.registry</span> <span class="k">import</span> <span class="n">get_class_by_name</span>
<span class="kn">from</span> <span class="nn">.path</span> <span class="k">import</span> <span class="n">join_path</span><span class="p">,</span> <span class="n">split_path</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">undoredo</span>
<span class="kn">from</span> <span class="nn">.description</span> <span class="k">import</span> <span class="p">(</span><span class="n">IsDescription</span><span class="p">,</span> <span class="n">UInt8Col</span><span class="p">,</span> <span class="n">StringCol</span><span class="p">,</span>
                                <span class="n">descr_from_dtype</span><span class="p">,</span> <span class="n">dtype_from_descr</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.filters</span> <span class="k">import</span> <span class="n">Filters</span>
<span class="kn">from</span> <span class="nn">.node</span> <span class="k">import</span> <span class="n">Node</span><span class="p">,</span> <span class="n">NotLoggedMixin</span>
<span class="kn">from</span> <span class="nn">.group</span> <span class="k">import</span> <span class="n">Group</span><span class="p">,</span> <span class="n">RootGroup</span>
<span class="kn">from</span> <span class="nn">.group</span> <span class="k">import</span> <span class="n">TransactionGroupG</span><span class="p">,</span> <span class="n">TransactionG</span><span class="p">,</span> <span class="n">MarkG</span>
<span class="kn">from</span> <span class="nn">.leaf</span> <span class="k">import</span> <span class="n">Leaf</span>
<span class="kn">from</span> <span class="nn">.array</span> <span class="k">import</span> <span class="n">Array</span>
<span class="kn">from</span> <span class="nn">.carray</span> <span class="k">import</span> <span class="n">CArray</span>
<span class="kn">from</span> <span class="nn">.earray</span> <span class="k">import</span> <span class="n">EArray</span>
<span class="kn">from</span> <span class="nn">.vlarray</span> <span class="k">import</span> <span class="n">VLArray</span>
<span class="kn">from</span> <span class="nn">.table</span> <span class="k">import</span> <span class="n">Table</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">linkextension</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="n">detect_number_of_cores</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">lrucacheextension</span>
<span class="kn">from</span> <span class="nn">.flavor</span> <span class="k">import</span> <span class="n">flavor_of</span><span class="p">,</span> <span class="n">array_as_internal</span>
<span class="kn">from</span> <span class="nn">.atom</span> <span class="k">import</span> <span class="n">Atom</span>

<span class="kn">from</span> <span class="nn">.link</span> <span class="k">import</span> <span class="n">SoftLink</span><span class="p">,</span> <span class="n">ExternalLink</span>

<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">map</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">range</span>



<span class="c1"># format_version = &quot;1.0&quot;  # Initial format</span>
<span class="c1"># format_version = &quot;1.1&quot;  # Changes in ucl compression</span>
<span class="c1"># format_version = &quot;1.2&quot;  # Support for enlargeable arrays and VLA&#39;s</span>
<span class="c1">#                         # 1.2 was introduced in PyTables 0.8</span>
<span class="c1"># format_version = &quot;1.3&quot;  # Support for indexes in Tables</span>
<span class="c1">#                         # 1.3 was introduced in PyTables 0.9</span>
<span class="c1"># format_version = &quot;1.4&quot;  # Support for multidimensional attributes</span>
<span class="c1">#                         # 1.4 was introduced in PyTables 1.1</span>
<span class="c1"># format_version = &quot;1.5&quot;  # Support for persistent defaults in tables</span>
<span class="c1">#                         # 1.5 was introduced in PyTables 1.2</span>
<span class="c1"># format_version = &quot;1.6&quot;  # Support for NumPy objects and new flavors for</span>
<span class="c1">#                         # objects.</span>
<span class="c1">#                         # 1.6 was introduced in pytables 1.3</span>
<span class="c1">#format_version = &quot;2.0&quot;   # Pickles are not used anymore in system attrs</span>
<span class="c1">#                         # 2.0 was introduced in PyTables 2.0</span>
<span class="n">format_version</span> <span class="o">=</span> <span class="s2">&quot;2.1&quot;</span>  <span class="c1"># Numeric and numarray flavors are gone.</span>

<span class="n">compatible_formats</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Old format versions we can read</span>
                         <span class="c1"># Empty means that we support all the old formats</span>


<span class="k">class</span> <span class="nc">_FileRegistry</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name_mapping</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handlers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filenames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">handlers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#return set(self._handlers)  # return a copy</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handlers</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handlers</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">filename</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filenames</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name_mapping</span><span class="p">[</span><span class="n">handler</span><span class="o">.</span><span class="n">filename</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handlers</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">handler</span><span class="o">.</span><span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name_mapping</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>
        <span class="c1"># remove enpty keys</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name_mapping</span><span class="p">[</span><span class="n">filename</span><span class="p">]:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name_mapping</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handlers</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_handlers_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="c1">#return set(self._name_mapping[filename])  # return a copy</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name_mapping</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">close_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">are_open_files</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handlers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">are_open_files</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Closing remaining open files:&quot;</span><span class="p">)</span>
        <span class="n">handlers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handlers</span><span class="p">)</span>  <span class="c1"># make a copy</span>
        <span class="k">for</span> <span class="n">fileh</span> <span class="ow">in</span> <span class="n">handlers</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">...&quot;</span> <span class="o">%</span> <span class="n">fileh</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">fileh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;done&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">are_open_files</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="c1"># Dict of opened files (keys are filenames and values filehandlers)</span>
<span class="n">_open_files</span> <span class="o">=</span> <span class="n">_FileRegistry</span><span class="p">()</span>

<span class="c1"># Opcodes for do-undo actions</span>
<span class="n">_op_to_code</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;MARK&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="s2">&quot;CREATE&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="s2">&quot;REMOVE&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="s2">&quot;MOVE&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="s2">&quot;ADDATTR&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
    <span class="s2">&quot;DELATTR&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">_code_to_op</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;MARK&quot;</span><span class="p">,</span> <span class="s2">&quot;CREATE&quot;</span><span class="p">,</span> <span class="s2">&quot;REMOVE&quot;</span><span class="p">,</span> <span class="s2">&quot;MOVE&quot;</span><span class="p">,</span> <span class="s2">&quot;ADDATTR&quot;</span><span class="p">,</span> <span class="s2">&quot;DELATTR&quot;</span><span class="p">]</span>


<span class="c1"># Paths and names for hidden nodes related with transactions.</span>
<span class="n">_trans_version</span> <span class="o">=</span> <span class="s1">&#39;1.0&#39;</span>

<span class="n">_trans_group_parent</span> <span class="o">=</span> <span class="s1">&#39;/&#39;</span>
<span class="n">_trans_group_name</span> <span class="o">=</span> <span class="s1">&#39;_p_transactions&#39;</span>
<span class="n">_trans_group_path</span> <span class="o">=</span> <span class="n">join_path</span><span class="p">(</span><span class="n">_trans_group_parent</span><span class="p">,</span> <span class="n">_trans_group_name</span><span class="p">)</span>

<span class="n">_action_log_parent</span> <span class="o">=</span> <span class="n">_trans_group_path</span>
<span class="n">_action_log_name</span> <span class="o">=</span> <span class="s1">&#39;actionlog&#39;</span>
<span class="n">_action_log_path</span> <span class="o">=</span> <span class="n">join_path</span><span class="p">(</span><span class="n">_action_log_parent</span><span class="p">,</span> <span class="n">_action_log_name</span><span class="p">)</span>

<span class="n">_trans_parent</span> <span class="o">=</span> <span class="n">_trans_group_path</span>
<span class="n">_trans_name</span> <span class="o">=</span> <span class="s1">&#39;t</span><span class="si">%d</span><span class="s1">&#39;</span>  <span class="c1"># %d -&gt; transaction number</span>
<span class="n">_trans_path</span> <span class="o">=</span> <span class="n">join_path</span><span class="p">(</span><span class="n">_trans_parent</span><span class="p">,</span> <span class="n">_trans_name</span><span class="p">)</span>

<span class="n">_markParent</span> <span class="o">=</span> <span class="n">_trans_path</span>
<span class="n">_markName</span> <span class="o">=</span> <span class="s1">&#39;m</span><span class="si">%d</span><span class="s1">&#39;</span>  <span class="c1"># %d -&gt; mark number</span>
<span class="n">_markPath</span> <span class="o">=</span> <span class="n">join_path</span><span class="p">(</span><span class="n">_markParent</span><span class="p">,</span> <span class="n">_markName</span><span class="p">)</span>

<span class="n">_shadow_parent</span> <span class="o">=</span> <span class="n">_markPath</span>
<span class="n">_shadow_name</span> <span class="o">=</span> <span class="s1">&#39;a</span><span class="si">%d</span><span class="s1">&#39;</span>  <span class="c1"># %d -&gt; action number</span>
<span class="n">_shadow_path</span> <span class="o">=</span> <span class="n">join_path</span><span class="p">(</span><span class="n">_shadow_parent</span><span class="p">,</span> <span class="n">_shadow_name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_checkfilters</span><span class="p">(</span><span class="n">filters</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">filters</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">filters</span><span class="p">,</span> <span class="n">Filters</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;filter parameter has to be None or a Filter &quot;</span>
                        <span class="s2">&quot;instance and the passed type is: &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span>
                        <span class="nb">type</span><span class="p">(</span><span class="n">filters</span><span class="p">))</span>


<div class="viewcode-block" id="copy_file"><a class="viewcode-back" href="../../usersguide/libref/top_level.html#tables.copy_file">[docs]</a><span class="k">def</span> <span class="nf">copy_file</span><span class="p">(</span><span class="n">srcfilename</span><span class="p">,</span> <span class="n">dstfilename</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An easy way of copying one PyTables file to another.</span>

<span class="sd">    This function allows you to copy an existing PyTables file named</span>
<span class="sd">    srcfilename to another file called dstfilename. The source file</span>
<span class="sd">    must exist and be readable. The destination file can be</span>
<span class="sd">    overwritten in place if existing by asserting the overwrite</span>
<span class="sd">    argument.</span>

<span class="sd">    This function is a shorthand for the :meth:`File.copy_file` method,</span>
<span class="sd">    which acts on an already opened file. kwargs takes keyword</span>
<span class="sd">    arguments used to customize the copying process. See the</span>
<span class="sd">    documentation of :meth:`File.copy_file` for a description of those</span>
<span class="sd">    arguments.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Open the source file.</span>
    <span class="n">srcfileh</span> <span class="o">=</span> <span class="n">open_file</span><span class="p">(</span><span class="n">srcfilename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Copy it to the destination file.</span>
        <span class="n">srcfileh</span><span class="o">.</span><span class="n">copy_file</span><span class="p">(</span><span class="n">dstfilename</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="c1"># Close the source file.</span>
        <span class="n">srcfileh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>



<span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">utilsextension</span><span class="o">.</span><span class="n">get_hdf5_version</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)))</span> \
                                                                        <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span>
    <span class="n">_FILE_OPEN_POLICY</span> <span class="o">=</span> <span class="s1">&#39;strict&#39;</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">_FILE_OPEN_POLICY</span> <span class="o">=</span> <span class="s1">&#39;default&#39;</span>


<div class="viewcode-block" id="open_file"><a class="viewcode-back" href="../../usersguide/libref/top_level.html#tables.open_file">[docs]</a><span class="k">def</span> <span class="nf">open_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">root_uep</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Open a PyTables (or generic HDF5) file and return a File object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        The name of the file (supports environment variable expansion).</span>
<span class="sd">        It is suggested that file names have any of the .h5, .hdf or</span>
<span class="sd">        .hdf5 extensions, although this is not mandatory.</span>
<span class="sd">    mode : str</span>
<span class="sd">        The mode to open the file. It can be one of the</span>
<span class="sd">        following:</span>

<span class="sd">            * *&#39;r&#39;*: Read-only; no data can be modified.</span>
<span class="sd">            * *&#39;w&#39;*: Write; a new file is created (an existing file</span>
<span class="sd">              with the same name would be deleted).</span>
<span class="sd">            * *&#39;a&#39;*: Append; an existing file is opened for reading and</span>
<span class="sd">              writing, and if the file does not exist it is created.</span>
<span class="sd">            * *&#39;r+&#39;*: It is similar to &#39;a&#39;, but the file must already</span>
<span class="sd">              exist.</span>

<span class="sd">    title : str</span>
<span class="sd">        If the file is to be created, a TITLE string attribute will be</span>
<span class="sd">        set on the root group with the given value. Otherwise, the</span>
<span class="sd">        title will be read from disk, and this will not have any effect.</span>
<span class="sd">    root_uep : str</span>
<span class="sd">        The root User Entry Point. This is a group in the HDF5 hierarchy</span>
<span class="sd">        which will be taken as the starting point to create the object</span>
<span class="sd">        tree. It can be whatever existing group in the file, named by</span>
<span class="sd">        its HDF5 path. If it does not exist, an HDF5ExtError is issued.</span>
<span class="sd">        Use this if you do not want to build the *entire* object tree,</span>
<span class="sd">        but rather only a *subtree* of it.</span>

<span class="sd">        .. versionchanged:: 3.0</span>
<span class="sd">           The *rootUEP* parameter has been renamed into *root_uep*.</span>

<span class="sd">    filters : Filters</span>
<span class="sd">        An instance of the Filters (see :ref:`FiltersClassDescr`) class</span>
<span class="sd">        that provides information about the desired I/O filters</span>
<span class="sd">        applicable to the leaves that hang directly from the *root group*,</span>
<span class="sd">        unless other filter properties are specified for these leaves.</span>
<span class="sd">        Besides, if you do not specify filter properties for child groups,</span>
<span class="sd">        they will inherit these ones, which will in turn propagate to</span>
<span class="sd">        child nodes.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In addition, it recognizes the (lowercase) names of parameters</span>
<span class="sd">    present in :file:`tables/parameters.py` as additional keyword</span>
<span class="sd">    arguments.</span>
<span class="sd">    See :ref:`parameter_files` for a detailed info on the supported</span>
<span class="sd">    parameters.</span>

<span class="sd">    .. note::</span>

<span class="sd">        If you need to deal with a large number of nodes in an</span>
<span class="sd">        efficient way, please see :ref:`LRUOptim` for more info and</span>
<span class="sd">        advices about the integrated node cache engine.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># XXX filename normalization ??</span>

    <span class="c1"># Check already opened files</span>
    <span class="k">if</span> <span class="n">_FILE_OPEN_POLICY</span> <span class="o">==</span> <span class="s1">&#39;strict&#39;</span><span class="p">:</span>
        <span class="c1"># This policy do not allows to open the same file multiple times</span>
        <span class="c1"># even in read-only mode</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">_open_files</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The file &#39;</span><span class="si">%s</span><span class="s2">&#39; is already opened.  &quot;</span>
                <span class="s2">&quot;Please close it before reopening.  &quot;</span>
                <span class="s2">&quot;HDF5 v.</span><span class="si">%s</span><span class="s2">, FILE_OPEN_POLICY = &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">filename</span><span class="p">,</span> <span class="n">utilsextension</span><span class="o">.</span><span class="n">get_hdf5_version</span><span class="p">(),</span>
                    <span class="n">_FILE_OPEN_POLICY</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">filehandle</span> <span class="ow">in</span> <span class="n">_open_files</span><span class="o">.</span><span class="n">get_handlers_by_name</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
            <span class="n">omode</span> <span class="o">=</span> <span class="n">filehandle</span><span class="o">.</span><span class="n">mode</span>
            <span class="c1"># &#39;r&#39; is incompatible with everything except &#39;r&#39; itself</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span> <span class="ow">and</span> <span class="n">omode</span> <span class="o">!=</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The file &#39;</span><span class="si">%s</span><span class="s2">&#39; is already opened, but &quot;</span>
                    <span class="s2">&quot;not in read-only mode (as requested).&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
            <span class="c1"># &#39;a&#39; and &#39;r+&#39; are compatible with everything except &#39;r&#39;</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">omode</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The file &#39;</span><span class="si">%s</span><span class="s2">&#39; is already opened, but &quot;</span>
                    <span class="s2">&quot;in read-only mode.  Please close it before &quot;</span>
                    <span class="s2">&quot;reopening in append mode.&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
            <span class="c1"># &#39;w&#39; means that we want to destroy existing contents</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The file &#39;</span><span class="si">%s</span><span class="s2">&#39; is already opened.  Please &quot;</span>
                    <span class="s2">&quot;close it before reopening in write mode.&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>

    <span class="c1"># Finally, create the File instance, and return it</span>
    <span class="k">return</span> <span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">root_uep</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<span class="c1"># A dumb class that doesn&#39;t keep nothing at all</span>
<span class="k">class</span> <span class="nc">_NoCache</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">([])</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="n">__marker</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">__marker</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__marker</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_DictCache</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nslots</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nslots</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid number of slots: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">nslots</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nslots</span> <span class="o">=</span> <span class="n">nslots</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_DictCache</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># Check if we are running out of space</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslots</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;the dictionary of node cache is exceeding the recommended &quot;</span>
                <span class="s2">&quot;maximum number (</span><span class="si">%d</span><span class="s2">); be ready to see PyTables asking for &quot;</span>
                <span class="s2">&quot;*lots* of memory and possibly slow I/O.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nslots</span><span class="p">),</span> <span class="n">PerformanceWarning</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_DictCache</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">NodeManager</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nslots</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">node_factory</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NodeManager</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">registry</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakValueDictionary</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">nslots</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cache</span> <span class="o">=</span> <span class="n">lrucacheextension</span><span class="o">.</span><span class="n">NodeCache</span><span class="p">(</span><span class="n">nslots</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">nslots</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cache</span> <span class="o">=</span> <span class="n">_NoCache</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># nslots &lt; 0</span>
            <span class="n">cache</span> <span class="o">=</span> <span class="n">_DictCache</span><span class="p">(</span><span class="o">-</span><span class="n">nslots</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span>

        <span class="c1"># node_factory(node_path)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_factory</span> <span class="o">=</span> <span class="n">node_factory</span>

    <span class="k">def</span> <span class="nf">register_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_v_pathname</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">_v_isopen</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;trying to register a node with an &#39;</span>
                                   <span class="s1">&#39;existing key: ``</span><span class="si">%s</span><span class="s1">``&#39;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">cache_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_v_pathname</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">register_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="n">oldnode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">oldnode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">node</span> <span class="ow">and</span> <span class="n">oldnode</span><span class="o">.</span><span class="n">_v_isopen</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;trying to cache a node with an &#39;</span>
                                   <span class="s1">&#39;existing key: ``</span><span class="si">%s</span><span class="s1">``&#39;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">get_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">_v_isopen</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cache_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">node</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># this should not happen</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;a closed node found in the cache: ``</span><span class="si">%s</span><span class="s2">``&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># this should not happen since WeakValueDictionary drops all</span>
                <span class="c1"># dead weakrefs</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;None is stored in the registry for key: &quot;</span>
                              <span class="s2">&quot;``</span><span class="si">%s</span><span class="s2">``&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">_v_isopen</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cache_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">node</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># this should not happen</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;a closed node found in the registry: &quot;</span>
                              <span class="s2">&quot;``</span><span class="si">%s</span><span class="s2">``&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="n">node</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_factory</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_factory</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">rename_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oldkey</span><span class="p">,</span> <span class="n">newkey</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">cache</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">oldkey</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">oldkey</span><span class="p">)</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">newkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">drop_from_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodepath</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Remove the node from cache&#39;&#39;&#39;</span>

        <span class="c1"># Remove the node from the cache.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">nodepath</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">drop_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">check_unregistered</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Drop the `node`.</span>

<span class="sd">        Remove the node from the cache and, if it has no more references,</span>
<span class="sd">        close it.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Remove all references to the node.</span>
        <span class="n">nodepath</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_v_pathname</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">drop_from_cache</span><span class="p">(</span><span class="n">nodepath</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nodepath</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">_v_isopen</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="p">[</span><span class="n">nodepath</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">check_unregistered</span><span class="p">:</span>
            <span class="c1"># If the node is not in the registry (this should never happen)</span>
            <span class="c1"># we close it forcibly since it is not ensured that the __del__</span>
            <span class="c1"># method is called for object that are still alive when the</span>
            <span class="c1"># interpreter is shut down</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">_v_isopen</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;dropping a node that is not in the registry: &quot;</span>
                              <span class="s2">&quot;``</span><span class="si">%s</span><span class="s2">``&quot;</span> <span class="o">%</span> <span class="n">nodepath</span><span class="p">)</span>

                <span class="n">node</span><span class="o">.</span><span class="n">_g_pre_kill_hook</span><span class="p">()</span>
                <span class="n">node</span><span class="o">.</span><span class="n">_f_close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">flush_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Only iter on the nodes in the registry since nodes in the cahce</span>
        <span class="c1"># should always have an entry in the registry</span>
        <span class="n">closed_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">path</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">_v_isopen</span><span class="p">:</span>
                <span class="n">closed_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="k">elif</span> <span class="s1">&#39;/_i_&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>  <span class="c1"># Indexes are not necessary to be flushed</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Leaf</span><span class="p">):</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">closed_keys</span><span class="p">:</span>
            <span class="c1"># self.cache.pop(path, None)</span>
            <span class="k">if</span> <span class="n">path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;closed node the cache: ``</span><span class="si">%s</span><span class="s2">``&quot;</span> <span class="o">%</span> <span class="n">path</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_close_nodes</span><span class="p">(</span><span class="n">nodepaths</span><span class="p">,</span> <span class="n">get_node</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">nodepath</span> <span class="ow">in</span> <span class="n">nodepaths</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">nodepath</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">_v_isopen</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">_v__deleting</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Avoid descendent nodes to also iterate over</span>
                    <span class="c1"># their descendents, which are already to be</span>
                    <span class="c1"># closed by this loop.</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;_f_get_child&#39;</span><span class="p">):</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">_g_close</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">_f_close</span><span class="p">()</span>
                    <span class="k">del</span> <span class="n">node</span>
                <span class="k">except</span> <span class="n">ClosedNodeError</span><span class="p">:</span>
                    <span class="c1">#import traceback</span>
                    <span class="c1">#type_, value, tb = sys.exc_info()</span>
                    <span class="c1">#exception_dump = &#39;&#39;.join(</span>
                    <span class="c1">#    traceback.format_exception(type_, value, tb))</span>
                    <span class="c1">#warnings.warn(</span>
                    <span class="c1">#    &quot;A &#39;%s&#39; exception occurred trying to close a node &quot;</span>
                    <span class="c1">#    &quot;that was supposed to be open.\n&quot;</span>
                    <span class="c1">#    &quot;%s&quot; % (type_.__name__, exception_dump))</span>
                    <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">close_subtree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;/&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">prefix</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">):</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span>

        <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
        <span class="n">registry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span>

        <span class="c1"># Ensure tables are closed before their indices</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">path</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">cache</span>
            <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;/_i_&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">path</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_nodes</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">cache</span><span class="o">.</span><span class="n">pop</span><span class="p">)</span>

        <span class="c1"># Close everything else (i.e. indices)</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">cache</span> <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_nodes</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">cache</span><span class="o">.</span><span class="n">pop</span><span class="p">)</span>

        <span class="c1"># Ensure tables are closed before their indices</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">path</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">registry</span>
            <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;/_i_&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">path</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_nodes</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">registry</span><span class="o">.</span><span class="n">pop</span><span class="p">)</span>

        <span class="c1"># Close everything else (i.e. indices)</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">registry</span> <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_nodes</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">registry</span><span class="o">.</span><span class="n">pop</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">shutdown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">registry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registry</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>

        <span class="c1">#self.close_subtree(&#39;/&#39;)</span>

        <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>  <span class="c1"># copy</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">_v_isopen</span><span class="p">:</span>
                <span class="n">registry</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">node</span><span class="o">.</span><span class="n">_f_close</span><span class="p">()</span>

        <span class="k">while</span> <span class="n">registry</span><span class="p">:</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">_v_isopen</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">_f_close</span><span class="p">()</span>


<div class="viewcode-block" id="File"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File">[docs]</a><span class="nd">@six</span><span class="o">.</span><span class="n">python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">File</span><span class="p">(</span><span class="n">hdf5extension</span><span class="o">.</span><span class="n">File</span><span class="p">,</span> <span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The in-memory representation of a PyTables file.</span>

<span class="sd">    An instance of this class is returned when a PyTables file is</span>
<span class="sd">    opened with the :func:`tables.open_file` function. It offers methods</span>
<span class="sd">    to manipulate (create, rename, delete...) nodes and handle their</span>
<span class="sd">    attributes, as well as methods to traverse the object tree.</span>
<span class="sd">    The *user entry point* to the object tree attached to the HDF5 file</span>
<span class="sd">    is represented in the root_uep attribute.</span>
<span class="sd">    Other attributes are available.</span>

<span class="sd">    File objects support an *Undo/Redo mechanism* which can be enabled</span>
<span class="sd">    with the :meth:`File.enable_undo` method. Once the Undo/Redo</span>
<span class="sd">    mechanism is enabled, explicit *marks* (with an optional unique</span>
<span class="sd">    name) can be set on the state of the database using the</span>
<span class="sd">    :meth:`File.mark`</span>
<span class="sd">    method. There are two implicit marks which are always available:</span>
<span class="sd">    the initial mark (0) and the final mark (-1).  Both the identifier</span>
<span class="sd">    of a mark and its name can be used in *undo* and *redo* operations.</span>

<span class="sd">    Hierarchy manipulation operations (node creation, movement and</span>
<span class="sd">    removal) and attribute handling operations (setting and deleting)</span>
<span class="sd">    made after a mark can be undone by using the :meth:`File.undo`</span>
<span class="sd">    method, which returns the database to the state of a past mark.</span>
<span class="sd">    If undo() is not followed by operations that modify the hierarchy</span>
<span class="sd">    or attributes, the :meth:`File.redo` method can be used to return</span>
<span class="sd">    the database to the state of a future mark. Else, future states of</span>
<span class="sd">    the database are forgotten.</span>

<span class="sd">    Note that data handling operations can not be undone nor redone by</span>
<span class="sd">    now. Also, hierarchy manipulation operations on nodes that do not</span>
<span class="sd">    support the Undo/Redo mechanism issue an UndoRedoWarning *before*</span>
<span class="sd">    changing the database.</span>

<span class="sd">    The Undo/Redo mechanism is persistent between sessions and can</span>
<span class="sd">    only be disabled by calling the :meth:`File.disable_undo` method.</span>

<span class="sd">    File objects can also act as context managers when using the with</span>
<span class="sd">    statement introduced in Python 2.5.  When exiting a context, the</span>
<span class="sd">    file is automatically closed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        The name of the file (supports environment variable expansion).</span>
<span class="sd">        It is suggested that file names have any of the .h5, .hdf or</span>
<span class="sd">        .hdf5 extensions, although this is not mandatory.</span>

<span class="sd">    mode : str</span>
<span class="sd">        The mode to open the file. It can be one of the</span>
<span class="sd">        following:</span>

<span class="sd">            * *&#39;r&#39;*: Read-only; no data can be modified.</span>
<span class="sd">            * *&#39;w&#39;*: Write; a new file is created (an existing file</span>
<span class="sd">              with the same name would be deleted).</span>
<span class="sd">            * *&#39;a&#39;*: Append; an existing file is opened for reading</span>
<span class="sd">              and writing, and if the file does not exist it is created.</span>
<span class="sd">            * *&#39;r+&#39;*: It is similar to &#39;a&#39;, but the file must already</span>
<span class="sd">              exist.</span>

<span class="sd">    title : str</span>
<span class="sd">        If the file is to be created, a TITLE string attribute will be</span>
<span class="sd">        set on the root group with the given value. Otherwise, the</span>
<span class="sd">        title will be read from disk, and this will not have any effect.</span>

<span class="sd">    root_uep : str</span>
<span class="sd">        The root User Entry Point. This is a group in the HDF5 hierarchy</span>
<span class="sd">        which will be taken as the starting point to create the object</span>
<span class="sd">        tree. It can be whatever existing group in the file, named by</span>
<span class="sd">        its HDF5 path. If it does not exist, an HDF5ExtError is issued.</span>
<span class="sd">        Use this if you do not want to build the *entire* object tree,</span>
<span class="sd">        but rather only a *subtree* of it.</span>

<span class="sd">        .. versionchanged:: 3.0</span>
<span class="sd">           The *rootUEP* parameter has been renamed into *root_uep*.</span>

<span class="sd">    filters : Filters</span>
<span class="sd">        An instance of the Filters (see :ref:`FiltersClassDescr`) class that</span>
<span class="sd">        provides information about the desired I/O filters applicable to the</span>
<span class="sd">        leaves that hang directly from the *root group*, unless other filter</span>
<span class="sd">        properties are specified for these leaves. Besides, if you do not</span>
<span class="sd">        specify filter properties for child groups, they will inherit these</span>
<span class="sd">        ones, which will in turn propagate to child nodes.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In addition, it recognizes the (lowercase) names of parameters</span>
<span class="sd">    present in :file:`tables/parameters.py` as additional keyword</span>
<span class="sd">    arguments.</span>
<span class="sd">    See :ref:`parameter_files` for a detailed info on the supported</span>
<span class="sd">    parameters.</span>


<span class="sd">    .. rubric:: File attributes</span>

<span class="sd">    .. attribute:: filename</span>

<span class="sd">        The name of the opened file.</span>

<span class="sd">    .. attribute:: format_version</span>

<span class="sd">        The PyTables version number of this file.</span>

<span class="sd">    .. attribute:: isopen</span>

<span class="sd">        True if the underlying file is open, false otherwise.</span>

<span class="sd">    .. attribute:: mode</span>

<span class="sd">        The mode in which the file was opened.</span>

<span class="sd">    .. attribute:: root</span>

<span class="sd">        The *root* of the object tree hierarchy (a Group instance).</span>

<span class="sd">    .. attribute:: root_uep</span>

<span class="sd">        The UEP (user entry point) group name in the file (see</span>
<span class="sd">        the :func:`open_file` function).</span>

<span class="sd">        .. versionchanged:: 3.0</span>
<span class="sd">           The *rootUEP* attribute has been renamed into *root_uep*.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># The top level kinds. Group must go first!</span>
    <span class="n">_node_kinds</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Group&#39;</span><span class="p">,</span> <span class="s1">&#39;Leaf&#39;</span><span class="p">,</span> <span class="s1">&#39;Link&#39;</span><span class="p">,</span> <span class="s1">&#39;Unknown&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">title</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;The title of the root group in the file.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_title</span>

    <span class="nd">@title</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">title</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_title</span> <span class="o">=</span> <span class="n">title</span>

    <span class="nd">@title</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">title</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_title</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Default filter properties for the root group (see :ref:`FiltersClassDescr`).&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_filters</span>

    <span class="nd">@filters</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">filters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filters</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_filters</span> <span class="o">=</span> <span class="n">filters</span>

    <span class="nd">@filters</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">filters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_filters</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">open_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of times this file handle has been opened.</span>

<span class="sd">        .. versionchanged:: 3.1</span>
<span class="sd">           The mechanism for caching and sharing file handles has been</span>
<span class="sd">           removed in PyTables 3.1.  Now this property should always</span>
<span class="sd">           be 1 (or 0 for closed files).</span>

<span class="sd">        .. deprecated:: 3.1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_open_count</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                 <span class="n">root_uep</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="sd">&quot;&quot;&quot;The name of the opened file.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="sd">&quot;&quot;&quot;The mode in which the file was opened.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid mode string ``</span><span class="si">%s</span><span class="s2">``. Allowed modes are: &quot;</span>
                             <span class="s2">&quot;&#39;r&#39;, &#39;r+&#39;, &#39;a&#39; and &#39;w&#39;&quot;</span> <span class="o">%</span> <span class="n">mode</span><span class="p">)</span>

        <span class="c1"># Get all the parameters in parameter file(s)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
                       <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)])</span>
        <span class="c1"># Update them with possible keyword arguments</span>
        <span class="k">if</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">isupper</span><span class="p">()]:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The use of uppercase keyword parameters is &quot;</span>
                          <span class="s2">&quot;deprecated&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)])</span>
        <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># If MAX_ * _THREADS is not set yet, set it to the number of cores</span>
        <span class="c1"># on this machine.</span>

        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;MAX_NUMEXPR_THREADS&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">&#39;MAX_NUMEXPR_THREADS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">detect_number_of_cores</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;MAX_BLOSC_THREADS&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">&#39;MAX_BLOSC_THREADS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">detect_number_of_cores</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>

        <span class="c1"># Now, it is time to initialize the File extension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_g_new</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Check filters and set PyTables format version for new files.</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_new</span>
        <span class="k">if</span> <span class="n">new</span><span class="p">:</span>
            <span class="n">_checkfilters</span><span class="p">(</span><span class="n">filters</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">format_version</span> <span class="o">=</span> <span class="n">format_version</span>
            <span class="sd">&quot;&quot;&quot;The PyTables version number of this file.&quot;&quot;&quot;</span>

        <span class="c1"># The node manager must be initialized before the root group</span>
        <span class="c1"># initialization but the node_factory attribute is set onl later</span>
        <span class="c1"># because it is a bount method of the root grop itself.</span>
        <span class="n">node_cache_slots</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;NODE_CACHE_SLOTS&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_manager</span> <span class="o">=</span> <span class="n">NodeManager</span><span class="p">(</span><span class="n">nslots</span><span class="o">=</span><span class="n">node_cache_slots</span><span class="p">)</span>

        <span class="c1"># For the moment Undo/Redo is not enabled.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_undoEnabled</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Set the flag to indicate that the file has been opened.</span>
        <span class="c1"># It must be set before opening the root group</span>
        <span class="c1"># to allow some basic access to its attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isopen</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;True if the underlying file os open, False otherwise.&quot;&quot;&quot;</span>

        <span class="c1"># Append the name of the file to the global dict of files opened.</span>
        <span class="n">_open_files</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Set the number of times this file has been opened to 1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_open_count</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Get the root group from this file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_root_group</span><span class="p">(</span><span class="n">root_uep</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">filters</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The *root* of the object tree hierarchy (a Group instance).&quot;&quot;&quot;</span>
        <span class="c1"># Complete the creation of the root node</span>
        <span class="c1"># (see the explanation in ``RootGroup.__init__()``.</span>
        <span class="n">root</span><span class="o">.</span><span class="n">_g_post_init_hook</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_manager</span><span class="o">.</span><span class="n">node_factory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_g_load_child</span>

        <span class="c1"># Save the PyTables format version for this file.</span>
        <span class="k">if</span> <span class="n">new</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;PYTABLES_SYS_ATTRS&#39;</span><span class="p">]:</span>
                <span class="n">root</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">_g__setattr</span><span class="p">(</span>
                    <span class="s1">&#39;PYTABLES_FORMAT_VERSION&#39;</span><span class="p">,</span> <span class="n">format_version</span><span class="p">)</span>

        <span class="c1"># If the file is old, and not opened in &quot;read-only&quot; mode,</span>
        <span class="c1"># check if it has a transaction log</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">new</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">!=</span> <span class="s2">&quot;r&quot;</span> <span class="ow">and</span> <span class="n">_trans_group_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># It does. Enable the undo.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">enable_undo</span><span class="p">()</span>

        <span class="c1"># Set the maximum number of threads for Numexpr</span>
        <span class="n">numexpr</span><span class="o">.</span><span class="n">set_vml_num_threads</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;MAX_NUMEXPR_THREADS&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__get_root_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_uep</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">filters</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a Group instance which will act as the root group in the</span>
<span class="sd">        hierarchical tree.</span>

<span class="sd">        If file is opened in &quot;r&quot;, &quot;r+&quot; or &quot;a&quot; mode, and the file already</span>
<span class="sd">        exists, this method dynamically builds a python object tree</span>
<span class="sd">        emulating the structure present on file.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_v_objectid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_file_id</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">root_uep</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">]:</span>
            <span class="n">root_uep</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span>
        <span class="c1"># Save the User Entry Point in a variable class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_uep</span> <span class="o">=</span> <span class="n">root_uep</span>

        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_new</span>

        <span class="c1"># Get format version *before* getting the object tree</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">new</span><span class="p">:</span>
            <span class="c1"># Firstly, get the PyTables format version for this file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">format_version</span> <span class="o">=</span> <span class="n">utilsextension</span><span class="o">.</span><span class="n">read_f_attr</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_v_objectid</span><span class="p">,</span> <span class="s1">&#39;PYTABLES_FORMAT_VERSION&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_version</span><span class="p">:</span>
                <span class="c1"># PYTABLES_FORMAT_VERSION attribute is not present</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">format_version</span> <span class="o">=</span> <span class="s2">&quot;unknown&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_isPTFile</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">format_version</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># system attributes should always be str</span>
                <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">format_version</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_version</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">format_version</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_version</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>

        <span class="c1"># Create new attributes for the root Group instance and</span>
        <span class="c1"># create the object tree</span>
        <span class="k">return</span> <span class="n">RootGroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_uep</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="n">new</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_get_or_create_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">create</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the given `path` or create it if `create` is true.</span>

<span class="sd">        If `create` is true, `path` *must* be a string path and not a</span>
<span class="sd">        node, otherwise a `TypeError`will be raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">create</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_create_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the groups needed for the `path` to exist.</span>

<span class="sd">        The group associated with the given `path` is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;split&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;when creating parents, parent must be a path&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">path</span> <span class="o">==</span> <span class="s1">&#39;/&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>

        <span class="n">parent</span><span class="p">,</span> <span class="n">create_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_group</span>
        <span class="k">for</span> <span class="n">pcomp</span> <span class="ow">in</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">child</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">_f_get_child</span><span class="p">(</span><span class="n">pcomp</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">NoSuchNodeError</span><span class="p">:</span>
                <span class="n">child</span> <span class="o">=</span> <span class="n">create_group</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">pcomp</span><span class="p">)</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">child</span>
        <span class="k">return</span> <span class="n">parent</span>


<div class="viewcode-block" id="File.create_group"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.create_group">[docs]</a>    <span class="k">def</span> <span class="nf">create_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">createparents</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        where : str or Group</span>
<span class="sd">            The parent group from which the new group will hang. It can be a</span>
<span class="sd">            path string (for example &#39;/level1/leaf5&#39;), or a Group instance</span>
<span class="sd">            (see :ref:`GroupClassDescr`).</span>
<span class="sd">        name : str</span>
<span class="sd">            The name of the new group.</span>
<span class="sd">        title : str, optional</span>
<span class="sd">            A description for this node (it sets the TITLE HDF5 attribute on</span>
<span class="sd">            disk).</span>
<span class="sd">        filters : Filters</span>
<span class="sd">            An instance of the Filters class (see :ref:`FiltersClassDescr`)</span>
<span class="sd">            that provides information about the desired I/O filters applicable</span>
<span class="sd">            to the leaves that hang directly from this new group (unless other</span>
<span class="sd">            filter properties are specified for these leaves). Besides, if you</span>
<span class="sd">            do not specify filter properties for its child groups, they will</span>
<span class="sd">            inherit these ones.</span>
<span class="sd">        createparents : bool</span>
<span class="sd">            Whether to create the needed groups for the parent</span>
<span class="sd">            path to exist (not done by default).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Group : for more information on groups</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">parentnode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_create_path</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">createparents</span><span class="p">)</span>
        <span class="n">_checkfilters</span><span class="p">(</span><span class="n">filters</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Group</span><span class="p">(</span><span class="n">parentnode</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                     <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">)</span></div>


<div class="viewcode-block" id="File.create_table"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.create_table">[docs]</a>    <span class="k">def</span> <span class="nf">create_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                     <span class="n">filters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">expectedrows</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span>
                     <span class="n">chunkshape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">createparents</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new table with the given name in where location.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        where : str or Group</span>
<span class="sd">            The parent group from which the new table will hang. It can be a</span>
<span class="sd">            path string (for example &#39;/level1/leaf5&#39;), or a Group instance</span>
<span class="sd">            (see :ref:`GroupClassDescr`).</span>
<span class="sd">        name : str</span>
<span class="sd">            The name of the new table.</span>
<span class="sd">        description : Description</span>
<span class="sd">            This is an object that describes the table, i.e. how</span>
<span class="sd">            many columns it has, their names, types, shapes, etc.  It</span>
<span class="sd">            can be any of the following:</span>

<span class="sd">                * *A user-defined class*: This should inherit from the</span>
<span class="sd">                  IsDescription class (see :ref:`IsDescriptionClassDescr`)</span>
<span class="sd">                  where table fields are specified.</span>
<span class="sd">                * *A dictionary*: For example, when you do not know</span>
<span class="sd">                  beforehand which structure your table will have).</span>
<span class="sd">                * *A Description instance*: You can use the description</span>
<span class="sd">                  attribute of another table to create a new one with the</span>
<span class="sd">                  same structure.</span>
<span class="sd">                * *A NumPy dtype*: A completely general structured NumPy</span>
<span class="sd">                  dtype.</span>
<span class="sd">                * *A NumPy (structured) array instance*: The dtype of</span>
<span class="sd">                  this structured array will be used as the description.</span>
<span class="sd">                  Also, in case the array has actual data, it will be</span>
<span class="sd">                  injected into the newly created table.</span>

<span class="sd">            .. versionchanged:: 3.0</span>
<span class="sd">               The *description* parameter can be None (default) if *obj* is</span>
<span class="sd">               provided.  In that case the structure of the table is deduced</span>
<span class="sd">               by *obj*.</span>

<span class="sd">        title : str</span>
<span class="sd">            A description for this node (it sets the TITLE HDF5 attribute</span>
<span class="sd">            on disk).</span>
<span class="sd">        filters : Filters</span>
<span class="sd">            An instance of the Filters class (see :ref:`FiltersClassDescr`)</span>
<span class="sd">            that provides information about the desired I/O filters to be</span>
<span class="sd">            applied during the life of this object.</span>
<span class="sd">        expectedrows : int</span>
<span class="sd">            A user estimate of the number of records that will be in the table.</span>
<span class="sd">            If not provided, the default value is EXPECTED_ROWS_TABLE (see</span>
<span class="sd">            :file:`tables/parameters.py`). If you plan to create a bigger</span>
<span class="sd">            table try providing a guess; this will optimize the HDF5 B-Tree</span>
<span class="sd">            creation and management process time and memory used.</span>
<span class="sd">        chunkshape</span>
<span class="sd">            The shape of the data chunk to be read or written in a</span>
<span class="sd">            single HDF5 I/O operation. Filters are applied to those</span>
<span class="sd">            chunks of data. The rank of the chunkshape for tables must</span>
<span class="sd">            be 1. If None, a sensible value is calculated based on the</span>
<span class="sd">            expectedrows parameter (which is recommended).</span>
<span class="sd">        byteorder : str</span>
<span class="sd">            The byteorder of data *on disk*, specified as &#39;little&#39; or &#39;big&#39;.</span>
<span class="sd">            If this is not specified, the byteorder is that of the platform,</span>
<span class="sd">            unless you passed an array as the description, in which case</span>
<span class="sd">            its byteorder will be used.</span>
<span class="sd">        createparents : bool</span>
<span class="sd">            Whether to create the needed groups for the parent path to exist</span>
<span class="sd">            (not done by default).</span>
<span class="sd">        obj : python object</span>
<span class="sd">            The recarray to be saved.  Accepted types are NumPy record</span>
<span class="sd">            arrays.</span>

<span class="sd">            The *obj* parameter is optional and it can be provided in</span>
<span class="sd">            alternative to the *description* parameter.</span>
<span class="sd">            If both *obj* and *description* are provided they must</span>
<span class="sd">            be consistent with each other.</span>

<span class="sd">            .. versionadded:: 3.0</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Table : for more information on tables</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;invalid obj parameter </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">obj</span><span class="p">)</span>

            <span class="n">descr</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">descr_from_dtype</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">description</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                    <span class="n">dtype_from_descr</span><span class="p">(</span><span class="n">description</span><span class="p">)</span> <span class="o">!=</span> <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;the desctiption parameter is not consistent &#39;</span>
                                <span class="s1">&#39;with the data type of the obj parameter&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">description</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">description</span> <span class="o">=</span> <span class="n">descr</span>

        <span class="n">parentnode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_create_path</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">createparents</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">description</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid table description: None&quot;</span><span class="p">)</span>
        <span class="n">_checkfilters</span><span class="p">(</span><span class="n">filters</span><span class="p">)</span>

        <span class="n">ptobj</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="n">parentnode</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                      <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                      <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">,</span> <span class="n">expectedrows</span><span class="o">=</span><span class="n">expectedrows</span><span class="p">,</span>
                      <span class="n">chunkshape</span><span class="o">=</span><span class="n">chunkshape</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="n">byteorder</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ptobj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ptobj</span></div>


<div class="viewcode-block" id="File.create_array"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.create_array">[docs]</a>    <span class="k">def</span> <span class="nf">create_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                     <span class="n">byteorder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">createparents</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        where : str or Group</span>
<span class="sd">            The parent group from which the new array will hang. It can be a</span>
<span class="sd">            path string (for example &#39;/level1/leaf5&#39;), or a Group instance</span>
<span class="sd">            (see :ref:`GroupClassDescr`).</span>
<span class="sd">        name : str</span>
<span class="sd">            The name of the new array</span>
<span class="sd">        obj : python object</span>
<span class="sd">            The array or scalar to be saved.  Accepted types are NumPy</span>
<span class="sd">            arrays and scalars, as well as native Python sequences and</span>
<span class="sd">            scalars, provided that values are regular (i.e. they are</span>
<span class="sd">            not like ``[[1,2],2]``) and homogeneous (i.e. all the</span>
<span class="sd">            elements are of the same type).</span>

<span class="sd">            Also, objects that have some of their dimensions equal to 0</span>
<span class="sd">            are not supported (use an EArray node (see</span>
<span class="sd">            :ref:`EArrayClassDescr`) if you want to store an array with</span>
<span class="sd">            one of its dimensions equal to 0).</span>

<span class="sd">            .. versionchanged:: 3.0</span>
<span class="sd">               The *Object parameter has been renamed into *obj*.*</span>

<span class="sd">        title : str</span>
<span class="sd">            A description for this node (it sets the TITLE HDF5 attribute on</span>
<span class="sd">            disk).</span>
<span class="sd">        byteorder : str</span>
<span class="sd">            The byteorder of the data *on disk*, specified as &#39;little&#39; or</span>
<span class="sd">            &#39;big&#39;.  If this is not specified, the byteorder is that of the</span>
<span class="sd">            given object.</span>
<span class="sd">        createparents : bool, optional</span>
<span class="sd">            Whether to create the needed groups for the parent path to exist</span>
<span class="sd">            (not done by default).</span>
<span class="sd">        atom : Atom</span>
<span class="sd">            An Atom (see :ref:`AtomClassDescr`) instance representing</span>
<span class="sd">            the *type* and *shape* of the atomic objects to be saved.</span>

<span class="sd">            .. versionadded:: 3.0</span>

<span class="sd">        shape : tuple of ints</span>
<span class="sd">            The shape of the stored array.</span>

<span class="sd">            .. versionadded:: 3.0</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Array : for more information on arrays</span>
<span class="sd">        create_table : for more information on the rest of parameters</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;if the obj parameter is not specified &#39;</span>
                                <span class="s1">&#39;(or None) then both the atom and shape &#39;</span>
                                <span class="s1">&#39;parametes should be provided.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Making strides=(0,...) below is a trick to create the</span>
                <span class="c1"># array fast and without memory consumption</span>
                <span class="n">dflt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">atom</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">atom</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">dflt</span><span class="p">,</span>
                                    <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flavor</span> <span class="o">=</span> <span class="n">flavor_of</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="c1"># use a temporary object because converting obj at this stage</span>
            <span class="c1"># breaks some test. This is soultion performs a double,</span>
            <span class="c1"># potentially expensive, conversion of the obj parameter.</span>
            <span class="n">_obj</span> <span class="o">=</span> <span class="n">array_as_internal</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">flavor</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">shape</span> <span class="o">!=</span> <span class="n">_obj</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;the shape parameter do not match obj.shape&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">atom</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">_obj</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;the atom parameter is not consistent with &#39;</span>
                                <span class="s1">&#39;the data type of the obj parameter&#39;</span><span class="p">)</span>

        <span class="n">parentnode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_create_path</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">createparents</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Array</span><span class="p">(</span><span class="n">parentnode</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                     <span class="n">obj</span><span class="o">=</span><span class="n">obj</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="n">byteorder</span><span class="p">)</span></div>


<div class="viewcode-block" id="File.create_carray"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.create_carray">[docs]</a>    <span class="k">def</span> <span class="nf">create_carray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                      <span class="n">filters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chunkshape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">byteorder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">createparents</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new chunked array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        where : str or Group</span>
<span class="sd">            The parent group from which the new array will hang. It can</span>
<span class="sd">            be a path string (for example &#39;/level1/leaf5&#39;), or a Group</span>
<span class="sd">            instance (see :ref:`GroupClassDescr`).</span>
<span class="sd">        name : str</span>
<span class="sd">            The name of the new array</span>
<span class="sd">        atom : Atom</span>
<span class="sd">            An Atom (see :ref:`AtomClassDescr`) instance representing</span>
<span class="sd">            the *type* and *shape* of the atomic objects to be saved.</span>

<span class="sd">            .. versionchanged:: 3.0</span>
<span class="sd">               The *atom* parameter can be None (default) if *obj* is</span>
<span class="sd">               provided.</span>

<span class="sd">        shape : tuple</span>
<span class="sd">            The shape of the new array.</span>

<span class="sd">            .. versionchanged:: 3.0</span>
<span class="sd">               The *shape* parameter can be None (default) if *obj* is</span>
<span class="sd">               provided.</span>

<span class="sd">        title : str, optional</span>
<span class="sd">            A description for this node (it sets the TITLE HDF5 attribute</span>
<span class="sd">            on disk).</span>
<span class="sd">        filters : Filters, optional</span>
<span class="sd">            An instance of the Filters class (see :ref:`FiltersClassDescr`)</span>
<span class="sd">            that provides information about the desired I/O filters to</span>
<span class="sd">            be applied during the life of this object.</span>
<span class="sd">        chunkshape : tuple or number or None, optional</span>
<span class="sd">            The shape of the data chunk to be read or written in a</span>
<span class="sd">            single HDF5 I/O operation.  Filters are applied to those</span>
<span class="sd">            chunks of data.  The dimensionality of chunkshape must be</span>
<span class="sd">            the same as that of shape.  If None, a sensible value is</span>
<span class="sd">            calculated (which is recommended).</span>
<span class="sd">        byteorder : str, optional</span>
<span class="sd">            The byteorder of the data *on disk*, specified as &#39;little&#39;</span>
<span class="sd">            or &#39;big&#39;.  If this is not specified, the byteorder is that</span>
<span class="sd">            of the given object.</span>
<span class="sd">        createparents : bool, optional</span>
<span class="sd">            Whether to create the needed groups for the parent path to</span>
<span class="sd">            exist (not done by default).</span>
<span class="sd">        obj : python object</span>
<span class="sd">            The array or scalar to be saved.  Accepted types are NumPy</span>
<span class="sd">            arrays and scalars, as well as native Python sequences and</span>
<span class="sd">            scalars, provided that values are regular (i.e. they are</span>
<span class="sd">            not like ``[[1,2],2]``) and homogeneous (i.e. all the</span>
<span class="sd">            elements are of the same type).</span>

<span class="sd">            Also, objects that have some of their dimensions equal to 0</span>
<span class="sd">            are not supported. Please use an EArray node (see</span>
<span class="sd">            :ref:`EArrayClassDescr`) if you want to store an array with</span>
<span class="sd">            one of its dimensions equal to 0.</span>

<span class="sd">            The *obj* parameter is optional and it can be provided in</span>
<span class="sd">            alternative to the *atom* and *shape* parameters.</span>
<span class="sd">            If both *obj* and *atom* and/or *shape* are provided they must</span>
<span class="sd">            be consistent with each other.</span>

<span class="sd">            .. versionadded:: 3.0</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        CArray : for more information on chunked arrays</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flavor</span> <span class="o">=</span> <span class="n">flavor_of</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">array_as_internal</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">flavor</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">shape</span> <span class="o">!=</span> <span class="n">obj</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;the shape parameter do not match obj.shape&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">shape</span>

            <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">atom</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;the atom parameter is not consistent with &#39;</span>
                                <span class="s1">&#39;the data type of the obj parameter&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">atom</span> <span class="o">=</span> <span class="n">Atom</span><span class="o">.</span><span class="n">from_dtype</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">parentnode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_create_path</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">createparents</span><span class="p">)</span>
        <span class="n">_checkfilters</span><span class="p">(</span><span class="n">filters</span><span class="p">)</span>
        <span class="n">ptobj</span> <span class="o">=</span> <span class="n">CArray</span><span class="p">(</span><span class="n">parentnode</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                       <span class="n">atom</span><span class="o">=</span><span class="n">atom</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">,</span>
                       <span class="n">chunkshape</span><span class="o">=</span><span class="n">chunkshape</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="n">byteorder</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ptobj</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>

        <span class="k">return</span> <span class="n">ptobj</span></div>


<div class="viewcode-block" id="File.create_earray"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.create_earray">[docs]</a>    <span class="k">def</span> <span class="nf">create_earray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                      <span class="n">filters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">expectedrows</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                      <span class="n">chunkshape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">createparents</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new enlargeable array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        where : str or Group</span>
<span class="sd">            The parent group from which the new array will hang. It can be a</span>
<span class="sd">            path string (for example &#39;/level1/leaf5&#39;), or a Group instance</span>
<span class="sd">            (see :ref:`GroupClassDescr`).</span>
<span class="sd">        name : str</span>
<span class="sd">            The name of the new array</span>
<span class="sd">        atom : Atom</span>
<span class="sd">            An Atom (see :ref:`AtomClassDescr`) instance representing the</span>
<span class="sd">            *type* and *shape* of the atomic objects to be saved.</span>

<span class="sd">            .. versionchanged:: 3.0</span>
<span class="sd">               The *atom* parameter can be None (default) if *obj* is</span>
<span class="sd">               provided.</span>

<span class="sd">        shape : tuple</span>
<span class="sd">            The shape of the new array.  One (and only one) of the shape</span>
<span class="sd">            dimensions *must* be 0.  The dimension being 0 means that the</span>
<span class="sd">            resulting EArray object can be extended along it.  Multiple</span>
<span class="sd">            enlargeable dimensions are not supported right now.</span>

<span class="sd">            .. versionchanged:: 3.0</span>
<span class="sd">               The *shape* parameter can be None (default) if *obj* is</span>
<span class="sd">               provided.</span>

<span class="sd">        title : str, optional</span>
<span class="sd">            A description for this node (it sets the TITLE HDF5 attribute on</span>
<span class="sd">            disk).</span>
<span class="sd">        expectedrows : int, optional</span>
<span class="sd">            A user estimate about the number of row elements that will be added</span>
<span class="sd">            to the growable dimension in the EArray node.  If not provided, the</span>
<span class="sd">            default value is EXPECTED_ROWS_EARRAY (see tables/parameters.py).</span>
<span class="sd">            If you plan to create either a much smaller or a much bigger array</span>
<span class="sd">            try providing a guess; this will optimize the HDF5 B-Tree creation</span>
<span class="sd">            and management process time and the amount of memory used.</span>
<span class="sd">        chunkshape : tuple, numeric, or None, optional</span>
<span class="sd">            The shape of the data chunk to be read or written in a single HDF5</span>
<span class="sd">            I/O operation.  Filters are applied to those chunks of data.  The</span>
<span class="sd">            dimensionality of chunkshape must be the same as that of shape</span>
<span class="sd">            (beware: no dimension should be 0 this time!).  If None, a sensible</span>
<span class="sd">            value is calculated based on the expectedrows parameter (which is</span>
<span class="sd">            recommended).</span>
<span class="sd">        byteorder : str, optional</span>
<span class="sd">            The byteorder of the data *on disk*, specified as &#39;little&#39; or</span>
<span class="sd">            &#39;big&#39;. If this is not specified, the byteorder is that of the</span>
<span class="sd">            platform.</span>
<span class="sd">        createparents : bool, optional</span>
<span class="sd">            Whether to create the needed groups for the parent path to exist</span>
<span class="sd">            (not done by default).</span>
<span class="sd">        obj : python object</span>
<span class="sd">            The array or scalar to be saved.  Accepted types are NumPy</span>
<span class="sd">            arrays and scalars, as well as native Python sequences and</span>
<span class="sd">            scalars, provided that values are regular (i.e. they are</span>
<span class="sd">            not like ``[[1,2],2]``) and homogeneous (i.e. all the</span>
<span class="sd">            elements are of the same type).</span>

<span class="sd">            The *obj* parameter is optional and it can be provided in</span>
<span class="sd">            alternative to the *atom* and *shape* parameters.</span>
<span class="sd">            If both *obj* and *atom* and/or *shape* are provided they must</span>
<span class="sd">            be consistent with each other.</span>

<span class="sd">            .. versionadded:: 3.0</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        EArray : for more information on enlargeable arrays</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flavor</span> <span class="o">=</span> <span class="n">flavor_of</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">array_as_internal</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">flavor</span><span class="p">)</span>

            <span class="n">earray_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

            <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">shape</span> <span class="o">!=</span> <span class="n">earray_shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;the shape parameter is not compatible &#39;</span>
                                <span class="s1">&#39;with obj.shape.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">earray_shape</span>

            <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">atom</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;the atom parameter is not consistent with &#39;</span>
                                <span class="s1">&#39;the data type of the obj parameter&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">atom</span> <span class="o">=</span> <span class="n">Atom</span><span class="o">.</span><span class="n">from_dtype</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">parentnode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_create_path</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">createparents</span><span class="p">)</span>
        <span class="n">_checkfilters</span><span class="p">(</span><span class="n">filters</span><span class="p">)</span>
        <span class="n">ptobj</span> <span class="o">=</span> <span class="n">EArray</span><span class="p">(</span><span class="n">parentnode</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                       <span class="n">atom</span><span class="o">=</span><span class="n">atom</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                       <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">,</span> <span class="n">expectedrows</span><span class="o">=</span><span class="n">expectedrows</span><span class="p">,</span>
                       <span class="n">chunkshape</span><span class="o">=</span><span class="n">chunkshape</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="n">byteorder</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ptobj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ptobj</span></div>


<div class="viewcode-block" id="File.create_vlarray"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.create_vlarray">[docs]</a>    <span class="k">def</span> <span class="nf">create_vlarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                       <span class="n">filters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">expectedrows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">chunkshape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">createparents</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new variable-length array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        where : str or Group</span>
<span class="sd">            The parent group from which the new array will hang. It can</span>
<span class="sd">            be a path string (for example &#39;/level1/leaf5&#39;), or a Group</span>
<span class="sd">            instance (see :ref:`GroupClassDescr`).</span>
<span class="sd">        name : str</span>
<span class="sd">            The name of the new array</span>
<span class="sd">        atom : Atom</span>
<span class="sd">            An Atom (see :ref:`AtomClassDescr`) instance representing</span>
<span class="sd">            the *type* and *shape* of the atomic objects to be saved.</span>

<span class="sd">            .. versionchanged:: 3.0</span>
<span class="sd">               The *atom* parameter can be None (default) if *obj* is</span>
<span class="sd">               provided.</span>

<span class="sd">        title : str, optional</span>
<span class="sd">            A description for this node (it sets the TITLE HDF5 attribute</span>
<span class="sd">            on disk).</span>
<span class="sd">        filters : Filters</span>
<span class="sd">            An instance of the Filters class (see :ref:`FiltersClassDescr`)</span>
<span class="sd">            that provides information about the desired I/O filters to</span>
<span class="sd">            be applied during the life of this object.</span>
<span class="sd">        expectedrows : int, optional</span>
<span class="sd">            A user estimate about the number of row elements that will</span>
<span class="sd">            be added to the growable dimension in the `VLArray` node.</span>
<span class="sd">            If not provided, the default value is ``EXPECTED_ROWS_VLARRAY``</span>
<span class="sd">            (see ``tables/parameters.py``).  If you plan to create either</span>
<span class="sd">            a much smaller or a much bigger `VLArray` try providing a guess;</span>
<span class="sd">            this will optimize the HDF5 B-Tree creation and management</span>
<span class="sd">            process time and the amount of memory used.</span>

<span class="sd">            .. versionadded:: 3.0</span>

<span class="sd">        chunkshape : int or tuple of int, optional</span>
<span class="sd">            The shape of the data chunk to be read or written in a</span>
<span class="sd">            single HDF5 I/O operation. Filters are applied to those</span>
<span class="sd">            chunks of data. The dimensionality of chunkshape must be 1.</span>
<span class="sd">            If None, a sensible value is calculated (which is recommended).</span>
<span class="sd">        byteorder : str, optional</span>
<span class="sd">            The byteorder of the data *on disk*, specified as &#39;little&#39; or</span>
<span class="sd">            &#39;big&#39;. If this is not specified, the byteorder is that of the</span>
<span class="sd">            platform.</span>
<span class="sd">        createparents : bool, optional</span>
<span class="sd">            Whether to create the needed groups for the parent path to</span>
<span class="sd">            exist (not done by default).</span>
<span class="sd">        obj : python object</span>
<span class="sd">            The array or scalar to be saved.  Accepted types are NumPy</span>
<span class="sd">            arrays and scalars, as well as native Python sequences and</span>
<span class="sd">            scalars, provided that values are regular (i.e. they are</span>
<span class="sd">            not like ``[[1,2],2]``) and homogeneous (i.e. all the</span>
<span class="sd">            elements are of the same type).</span>

<span class="sd">            The *obj* parameter is optional and it can be provided in</span>
<span class="sd">            alternative to the *atom* parameter.</span>
<span class="sd">            If both *obj* and *atom* and are provided they must</span>
<span class="sd">            be consistent with each other.</span>

<span class="sd">            .. versionadded:: 3.0</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        VLArray : for more informationon variable-length arrays</span>

<span class="sd">        .. versionchanged:: 3.0</span>
<span class="sd">           The *expectedsizeinMB* parameter has been replaced by</span>
<span class="sd">           *expectedrows*.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flavor</span> <span class="o">=</span> <span class="n">flavor_of</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">array_as_internal</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">flavor</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">atom</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;the atom parameter is not consistent with &#39;</span>
                                <span class="s1">&#39;the data type of the obj parameter&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">atom</span> <span class="o">=</span> <span class="n">Atom</span><span class="o">.</span><span class="n">from_dtype</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;atom parameter cannot be None&#39;</span><span class="p">)</span>

        <span class="n">parentnode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_create_path</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">createparents</span><span class="p">)</span>
        <span class="n">_checkfilters</span><span class="p">(</span><span class="n">filters</span><span class="p">)</span>
        <span class="n">ptobj</span> <span class="o">=</span> <span class="n">VLArray</span><span class="p">(</span><span class="n">parentnode</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                        <span class="n">atom</span><span class="o">=</span><span class="n">atom</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">,</span>
                        <span class="n">expectedrows</span><span class="o">=</span><span class="n">expectedrows</span><span class="p">,</span>
                        <span class="n">chunkshape</span><span class="o">=</span><span class="n">chunkshape</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="n">byteorder</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ptobj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ptobj</span></div>


<div class="viewcode-block" id="File.create_hard_link"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.create_hard_link">[docs]</a>    <span class="k">def</span> <span class="nf">create_hard_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">createparents</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a hard link.</span>

<span class="sd">        Create a hard link to a `target` node with the given `name` in</span>
<span class="sd">        `where` location.  `target` can be a node object or a path</span>
<span class="sd">        string.  If `createparents` is true, the intermediate groups</span>
<span class="sd">        required for reaching `where` are created (the default is not</span>
<span class="sd">        doing so).</span>

<span class="sd">        The returned node is a regular `Group` or `Leaf` instance.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">targetnode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="n">parentnode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_create_path</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">createparents</span><span class="p">)</span>
        <span class="n">linkextension</span><span class="o">.</span><span class="n">_g_create_hard_link</span><span class="p">(</span><span class="n">parentnode</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">targetnode</span><span class="p">)</span>
        <span class="c1"># Refresh children names in link&#39;s parent node</span>
        <span class="n">parentnode</span><span class="o">.</span><span class="n">_g_add_children_names</span><span class="p">()</span>
        <span class="c1"># Return the target node</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">parentnode</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="File.create_soft_link"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.create_soft_link">[docs]</a>    <span class="k">def</span> <span class="nf">create_soft_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">createparents</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a soft link (aka symbolic link) to a `target` node.</span>

<span class="sd">        Create a soft link (aka symbolic link) to a `target` nodewith</span>
<span class="sd">        the given `name` in `where` location.  `target` can be a node</span>
<span class="sd">        object or a path string.  If `createparents` is true, the</span>
<span class="sd">        intermediate groups required for reaching `where` are created.</span>

<span class="sd">        (the default is not doing so).</span>

<span class="sd">        The returned node is a SoftLink instance.  See the SoftLink</span>
<span class="sd">        class (in :ref:`SoftLinkClassDescr`) for more information on</span>
<span class="sd">        soft links.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s1">&#39;_v_pathname&#39;</span><span class="p">):</span>   <span class="c1"># quacks like a Node</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">_v_pathname</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;`target` has to be a string or a node object&quot;</span><span class="p">)</span>
        <span class="n">parentnode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_create_path</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">createparents</span><span class="p">)</span>
        <span class="n">slink</span> <span class="o">=</span> <span class="n">SoftLink</span><span class="p">(</span><span class="n">parentnode</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="c1"># Refresh children names in link&#39;s parent node</span>
        <span class="n">parentnode</span><span class="o">.</span><span class="n">_g_add_children_names</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">slink</span></div>


<div class="viewcode-block" id="File.create_external_link"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.create_external_link">[docs]</a>    <span class="k">def</span> <span class="nf">create_external_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">createparents</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an external link.</span>

<span class="sd">        Create an external link to a *target* node with the given *name*</span>
<span class="sd">        in *where* location.  *target* can be a node object in another</span>
<span class="sd">        file or a path string in the form &#39;file:/path/to/node&#39;.  If</span>
<span class="sd">        *createparents* is true, the intermediate groups required for</span>
<span class="sd">        reaching *where* are created (the default is not doing so).</span>

<span class="sd">        The returned node is an :class:`ExternalLink` instance.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s1">&#39;_v_pathname&#39;</span><span class="p">):</span>   <span class="c1"># quacks like a Node</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">filename</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="n">target</span><span class="o">.</span><span class="n">_v_pathname</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;`target` has to be a string or a node object&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">target</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;:/&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`target` must expressed as &#39;file:/path/to/node&#39;&quot;</span><span class="p">)</span>
        <span class="n">parentnode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_create_path</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">createparents</span><span class="p">)</span>
        <span class="n">elink</span> <span class="o">=</span> <span class="n">ExternalLink</span><span class="p">(</span><span class="n">parentnode</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="c1"># Refresh children names in link&#39;s parent node</span>
        <span class="n">parentnode</span><span class="o">.</span><span class="n">_g_add_children_names</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">elink</span></div>


    <span class="k">def</span> <span class="nf">_get_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodepath</span><span class="p">):</span>
        <span class="c1"># The root node is always at hand.</span>
        <span class="k">if</span> <span class="n">nodepath</span> <span class="o">==</span> <span class="s1">&#39;/&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>

        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_manager</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">nodepath</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;unable to instantiate node ``</span><span class="si">%s</span><span class="s2">``&quot;</span> <span class="o">%</span> <span class="n">nodepath</span>

        <span class="k">return</span> <span class="n">node</span>


<div class="viewcode-block" id="File.get_node"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.get_node">[docs]</a>    <span class="k">def</span> <span class="nf">get_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">classname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the node under where with the given name.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        where : str or Node</span>
<span class="sd">            This can be a path string leading to a node or a Node instance (see</span>
<span class="sd">            :ref:`NodeClassDescr`). If no name is specified, that node is</span>
<span class="sd">            returned.</span>

<span class="sd">            .. note::</span>

<span class="sd">                If where is a Node instance from a different file than the one</span>
<span class="sd">                on which this function is called, the returned node will also</span>
<span class="sd">                be from that other file.</span>

<span class="sd">        name : str, optional</span>
<span class="sd">            If a name is specified, this must be a string with the name of</span>
<span class="sd">            a node under where.  In this case the where argument can only</span>
<span class="sd">            lead to a Group (see :ref:`GroupClassDescr`) instance (else a</span>
<span class="sd">            TypeError is raised). The node called name under the group</span>
<span class="sd">            where is returned.</span>
<span class="sd">        classname : str, optional</span>
<span class="sd">            If the classname argument is specified, it must be the name of</span>
<span class="sd">            a class derived from Node (e.g. Table). If the node is found but it</span>
<span class="sd">            is not an instance of that class, a NoSuchNodeError is also raised.</span>

<span class="sd">        If the node to be returned does not exist, a NoSuchNodeError is</span>
<span class="sd">        raised. Please note that hidden nodes are also considered.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_open</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="n">where</span><span class="o">.</span><span class="n">_g_check_open</span><span class="p">()</span>

            <span class="n">basepath</span> <span class="o">=</span> <span class="n">where</span><span class="o">.</span><span class="n">_v_pathname</span>
            <span class="n">nodepath</span> <span class="o">=</span> <span class="n">join_path</span><span class="p">(</span><span class="n">basepath</span><span class="p">,</span> <span class="n">name</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;/&#39;</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">where</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_get_node</span><span class="p">(</span><span class="n">nodepath</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">str_</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">where</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;``where`` must start with a slash (&#39;/&#39;)&quot;</span><span class="p">)</span>

            <span class="n">basepath</span> <span class="o">=</span> <span class="n">where</span>
            <span class="n">nodepath</span> <span class="o">=</span> <span class="n">join_path</span><span class="p">(</span><span class="n">basepath</span><span class="p">,</span> <span class="n">name</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;/&#39;</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node</span><span class="p">(</span><span class="n">nodepath</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;``where`` must be a string or a node: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">where</span><span class="p">,))</span>

        <span class="c1"># Finally, check whether the desired node is an instance</span>
        <span class="c1"># of the expected class.</span>
        <span class="k">if</span> <span class="n">classname</span><span class="p">:</span>
            <span class="n">class_</span> <span class="o">=</span> <span class="n">get_class_by_name</span><span class="p">(</span><span class="n">classname</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">class_</span><span class="p">):</span>
                <span class="n">npathname</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_v_pathname</span>
                <span class="n">nclassname</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="c1"># This error message is right since it can never be shown</span>
                <span class="c1"># for ``classname in [None, &#39;Node&#39;]``.</span>
                <span class="k">raise</span> <span class="n">NoSuchNodeError</span><span class="p">(</span>
                    <span class="s2">&quot;could not find a ``</span><span class="si">%s</span><span class="s2">`` node at ``</span><span class="si">%s</span><span class="s2">``; &quot;</span>
                    <span class="s2">&quot;instead, a ``</span><span class="si">%s</span><span class="s2">`` node has been found there&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">classname</span><span class="p">,</span> <span class="n">npathname</span><span class="p">,</span> <span class="n">nclassname</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">node</span></div>


<div class="viewcode-block" id="File.is_visible_node"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.is_visible_node">[docs]</a>    <span class="k">def</span> <span class="nf">is_visible_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Is the node under `path` visible?</span>

<span class="sd">        If the node does not exist, a NoSuchNodeError is raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># ``util.isvisiblepath()`` is still recommended for internal use.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">_f_isvisible</span><span class="p">()</span></div>


<div class="viewcode-block" id="File.rename_node"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.rename_node">[docs]</a>    <span class="k">def</span> <span class="nf">rename_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">newname</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change the name of the node specified by where and name to newname.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        where, name</span>
<span class="sd">            These arguments work as in</span>
<span class="sd">            :meth:`File.get_node`, referencing the node to be acted upon.</span>
<span class="sd">        newname : str</span>
<span class="sd">            The new name to be assigned to the node (a string).</span>
<span class="sd">        overwrite : bool</span>
<span class="sd">            Whether to recursively remove a node with the same</span>
<span class="sd">            newname if it already exists (not done by default).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_f_rename</span><span class="p">(</span><span class="n">newname</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span></div>


<div class="viewcode-block" id="File.move_node"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.move_node">[docs]</a>    <span class="k">def</span> <span class="nf">move_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">newparent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">newname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">createparents</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Move the node specified by where and name to newparent/newname.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        where, name : path</span>
<span class="sd">            These arguments work as in</span>
<span class="sd">            :meth:`File.get_node`, referencing the node to be acted upon.</span>
<span class="sd">        newparent</span>
<span class="sd">            The destination group the node will be moved into (a</span>
<span class="sd">            path name or a Group instance). If it is</span>
<span class="sd">            not specified or None, the current parent</span>
<span class="sd">            group is chosen as the new parent.</span>
<span class="sd">        newname</span>
<span class="sd">            The new name to be assigned to the node in its</span>
<span class="sd">            destination (a string). If it is not specified or</span>
<span class="sd">            None, the current name is chosen as the</span>
<span class="sd">            new name.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The other arguments work as in :meth:`Node._f_move`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_f_move</span><span class="p">(</span><span class="n">newparent</span><span class="p">,</span> <span class="n">newname</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">createparents</span><span class="p">)</span></div>


<div class="viewcode-block" id="File.copy_node"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.copy_node">[docs]</a>    <span class="k">def</span> <span class="nf">copy_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">newparent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">newname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">createparents</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy the node specified by where and name to newparent/newname.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        where : str</span>
<span class="sd">            These arguments work as in</span>
<span class="sd">            :meth:`File.get_node`, referencing the node to be acted</span>
<span class="sd">            upon.</span>
<span class="sd">        newparent : str or Group</span>
<span class="sd">            The destination group that the node will be copied</span>
<span class="sd">            into (a path name or a Group</span>
<span class="sd">            instance). If not specified or None, the</span>
<span class="sd">            current parent group is chosen as the new parent.</span>
<span class="sd">        newname : str</span>
<span class="sd">            The name to be assigned to the new copy in its</span>
<span class="sd">            destination (a string).  If it is not specified or</span>
<span class="sd">            None, the current name is chosen as the</span>
<span class="sd">            new name.</span>
<span class="sd">        name : str</span>
<span class="sd">            These arguments work as in</span>
<span class="sd">            :meth:`File.get_node`, referencing the node to be acted</span>
<span class="sd">            upon.</span>
<span class="sd">        overwrite : bool, optional</span>
<span class="sd">            If True, the destination group will be overwritten if it already</span>
<span class="sd">            exists.  Defaults to False.</span>
<span class="sd">        recursive : bool, optional</span>
<span class="sd">            If True, all descendant nodes of srcgroup are recursively copied.</span>
<span class="sd">            Defaults to False.</span>
<span class="sd">        createparents : bool, optional</span>
<span class="sd">            If True, any necessary parents of dstgroup will be created.</span>
<span class="sd">            Defaults to False.</span>
<span class="sd">        kwargs</span>
<span class="sd">           Additional keyword arguments can be used to customize the copying</span>
<span class="sd">           process.  See the documentation of :meth:`Group._f_copy`</span>
<span class="sd">           for a description of those arguments.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        node : Node</span>
<span class="sd">            The newly created copy of the source node (i.e. the destination</span>
<span class="sd">            node).  See :meth:`.Node._f_copy` for further details on the</span>
<span class="sd">            semantics of copying nodes.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">_v_depth</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">newparent</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">newname</span><span class="p">:</span>
            <span class="n">npobj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">newparent</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">_v_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">npobj</span><span class="o">.</span><span class="n">_v_file</span><span class="p">:</span>
                <span class="c1"># Special case for copying file1:/ --&gt; file2:/path</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_f_copy_children</span><span class="p">(</span><span class="n">npobj</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span>
                                           <span class="n">recursive</span><span class="o">=</span><span class="n">recursive</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">npobj</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span>
                    <span class="s2">&quot;You cannot copy a root group over the same file&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">_f_copy</span><span class="p">(</span><span class="n">newparent</span><span class="p">,</span> <span class="n">newname</span><span class="p">,</span>
                           <span class="n">overwrite</span><span class="p">,</span> <span class="n">recursive</span><span class="p">,</span> <span class="n">createparents</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="File.remove_node"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.remove_node">[docs]</a>    <span class="k">def</span> <span class="nf">remove_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove the object node *name* under *where* location.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        where, name</span>
<span class="sd">            These arguments work as in</span>
<span class="sd">            :meth:`File.get_node`, referencing the node to be acted upon.</span>
<span class="sd">        recursive : bool</span>
<span class="sd">            If not supplied or false, the node will be removed</span>
<span class="sd">            only if it has no children; if it does, a</span>
<span class="sd">            NodeError will be raised. If supplied</span>
<span class="sd">            with a true value, the node and all its descendants will be</span>
<span class="sd">            completely removed.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_f_remove</span><span class="p">(</span><span class="n">recursive</span><span class="p">)</span></div>


<div class="viewcode-block" id="File.get_node_attr"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.get_node_attr">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">attrname</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a PyTables attribute from the given node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        where, name</span>
<span class="sd">            These arguments work as in :meth:`File.get_node`, referencing the</span>
<span class="sd">            node to be acted upon.</span>
<span class="sd">        attrname</span>
<span class="sd">            The name of the attribute to retrieve.  If the named</span>
<span class="sd">            attribute does not exist, an AttributeError is raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">_f_getattr</span><span class="p">(</span><span class="n">attrname</span><span class="p">)</span></div>


<div class="viewcode-block" id="File.set_node_attr"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.set_node_attr">[docs]</a>    <span class="k">def</span> <span class="nf">set_node_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">attrname</span><span class="p">,</span> <span class="n">attrvalue</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set a PyTables attribute for the given node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        where, name</span>
<span class="sd">            These arguments work as in</span>
<span class="sd">            :meth:`File.get_node`, referencing the node to be acted upon.</span>
<span class="sd">        attrname</span>
<span class="sd">            The name of the attribute to set.</span>
<span class="sd">        attrvalue</span>
<span class="sd">            The value of the attribute to set. Any kind of Python</span>
<span class="sd">            object (like strings, ints, floats, lists, tuples, dicts,</span>
<span class="sd">            small NumPy objects ...) can be stored as an attribute.</span>
<span class="sd">            However, if necessary, pickle is automatically used so as</span>
<span class="sd">            to serialize objects that you might want to save.</span>
<span class="sd">            See the :class:`AttributeSet` class for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If the node already has a large number of attributes, a</span>
<span class="sd">        PerformanceWarning is issued.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_f_setattr</span><span class="p">(</span><span class="n">attrname</span><span class="p">,</span> <span class="n">attrvalue</span><span class="p">)</span></div>


<div class="viewcode-block" id="File.del_node_attr"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.del_node_attr">[docs]</a>    <span class="k">def</span> <span class="nf">del_node_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">attrname</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete a PyTables attribute from the given node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        where, name</span>
<span class="sd">            These arguments work as in :meth:`File.get_node`, referencing the</span>
<span class="sd">            node to be acted upon.</span>
<span class="sd">        attrname</span>
<span class="sd">            The name of the attribute to delete.  If the named</span>
<span class="sd">            attribute does not exist, an AttributeError is raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_f_delattr</span><span class="p">(</span><span class="n">attrname</span><span class="p">)</span></div>


<div class="viewcode-block" id="File.copy_node_attrs"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.copy_node_attrs">[docs]</a>    <span class="k">def</span> <span class="nf">copy_node_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">dstnode</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy PyTables attributes from one node to another.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        where, name</span>
<span class="sd">            These arguments work as in :meth:`File.get_node`, referencing the</span>
<span class="sd">            node to be acted upon.</span>
<span class="sd">        dstnode</span>
<span class="sd">            The destination node where the attributes will be copied to. It can</span>
<span class="sd">            be a path string or a Node instance (see :ref:`NodeClassDescr`).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">srcobject</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="n">dstobject</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">dstnode</span><span class="p">)</span>
        <span class="n">srcobject</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">_f_copy</span><span class="p">(</span><span class="n">dstobject</span><span class="p">)</span></div>


<div class="viewcode-block" id="File.copy_children"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.copy_children">[docs]</a>    <span class="k">def</span> <span class="nf">copy_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">srcgroup</span><span class="p">,</span> <span class="n">dstgroup</span><span class="p">,</span>
                      <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">createparents</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy the children of a group into another group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        srcgroup : str</span>
<span class="sd">            The group to copy from.</span>
<span class="sd">        dstgroup : str</span>
<span class="sd">            The destination group.</span>
<span class="sd">        overwrite : bool, optional</span>
<span class="sd">            If True, the destination group will be overwritten if it already</span>
<span class="sd">            exists.  Defaults to False.</span>
<span class="sd">        recursive : bool, optional</span>
<span class="sd">            If True, all descendant nodes of srcgroup are recursively copied.</span>
<span class="sd">            Defaults to False.</span>
<span class="sd">        createparents : bool, optional</span>
<span class="sd">            If True, any necessary parents of dstgroup will be created.</span>
<span class="sd">            Defaults to False.</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">           Additional keyword arguments can be used to customize the copying</span>
<span class="sd">           process.  See the documentation of :meth:`Group._f_copy_children`</span>
<span class="sd">           for a description of those arguments.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">srcgroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">srcgroup</span><span class="p">)</span>  <span class="c1"># Does the source node exist?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_group</span><span class="p">(</span><span class="n">srcgroup</span><span class="p">)</span>  <span class="c1"># Is it a group?</span>

        <span class="n">srcgroup</span><span class="o">.</span><span class="n">_f_copy_children</span><span class="p">(</span>
            <span class="n">dstgroup</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">recursive</span><span class="p">,</span> <span class="n">createparents</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="File.copy_file"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.copy_file">[docs]</a>    <span class="k">def</span> <span class="nf">copy_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dstfilename</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy the contents of this file to dstfilename.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dstfilename : str</span>
<span class="sd">            A path string indicating the name of the destination file. If</span>
<span class="sd">            it already exists, the copy will fail with an IOError, unless</span>
<span class="sd">            the overwrite argument is true.</span>
<span class="sd">        overwrite : bool, optional</span>
<span class="sd">            If true, the destination file will be overwritten if it already</span>
<span class="sd">            exists.  In this case, the destination file must be closed, or</span>
<span class="sd">            errors will occur.  Defaults to False.</span>
<span class="sd">        kwargs</span>
<span class="sd">            Additional keyword arguments discussed below.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Additional keyword arguments may be passed to customize the</span>
<span class="sd">        copying process. For instance, title and filters may be changed,</span>
<span class="sd">        user attributes may be or may not be copied, data may be</span>
<span class="sd">        sub-sampled, stats may be collected, etc. Arguments unknown to</span>
<span class="sd">        nodes are simply ignored. Check the documentation for copying</span>
<span class="sd">        operations of nodes to see which options they support.</span>

<span class="sd">        In addition, it recognizes the names of parameters present in</span>
<span class="sd">        :file:`tables/parameters.py` as additional keyword arguments.</span>
<span class="sd">        See :ref:`parameter_files` for a detailed info on the supported</span>
<span class="sd">        parameters.</span>

<span class="sd">        Copying a file usually has the beneficial side effect of</span>
<span class="sd">        creating a more compact and cleaner version of the original</span>
<span class="sd">        file.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_open</span><span class="p">()</span>

        <span class="c1"># Check that we are not treading our own shoes</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span> <span class="o">==</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">dstfilename</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;You cannot copy a file over itself&quot;</span><span class="p">)</span>

        <span class="c1"># Compute default arguments.</span>
        <span class="c1"># These are *not* passed on.</span>
        <span class="n">filters</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;filters&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># By checking the HDF5 attribute, we avoid setting filters</span>
            <span class="c1"># in the destination file if not explicitly set in the</span>
            <span class="c1"># source file.  Just by assigning ``self.filters`` we would</span>
            <span class="c1"># not be able to tell.</span>
            <span class="n">filters</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_attrs</span><span class="p">,</span> <span class="s1">&#39;FILTERS&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">copyuserattrs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;copyuserattrs&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">dstfilename</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">((</span><span class="s2">&quot;file ``</span><span class="si">%s</span><span class="s2">`` already exists; &quot;</span>
                           <span class="s2">&quot;you may want to use the ``overwrite`` &quot;</span>
                           <span class="s2">&quot;argument&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="n">dstfilename</span><span class="p">)</span>

        <span class="c1"># Create destination file, overwriting it.</span>
        <span class="n">dstfileh</span> <span class="o">=</span> <span class="n">open_file</span><span class="p">(</span>
            <span class="n">dstfilename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Maybe copy the user attributes of the root group.</span>
            <span class="k">if</span> <span class="n">copyuserattrs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">_f_copy</span><span class="p">(</span><span class="n">dstfileh</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>

            <span class="c1"># Copy the rest of the hierarchy.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_f_copy_children</span><span class="p">(</span><span class="n">dstfileh</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">dstfileh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="File.list_nodes"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.list_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">list_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">classname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a *list* with children nodes hanging from where.</span>

<span class="sd">        This is a list-returning version of :meth:`File.iter_nodes`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">where</span><span class="p">)</span>  <span class="c1"># Does the parent exist?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_group</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>  <span class="c1"># Is it a group?</span>

        <span class="k">return</span> <span class="n">group</span><span class="o">.</span><span class="n">_f_list_nodes</span><span class="p">(</span><span class="n">classname</span><span class="p">)</span></div>


<div class="viewcode-block" id="File.iter_nodes"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.iter_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">iter_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">classname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over children nodes hanging from where.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        where</span>
<span class="sd">            This argument works as in :meth:`File.get_node`, referencing the</span>
<span class="sd">            node to be acted upon.</span>
<span class="sd">        classname</span>
<span class="sd">            If the name of a class derived from</span>
<span class="sd">            Node (see :ref:`NodeClassDescr`) is supplied, only instances of</span>
<span class="sd">            that class (or subclasses of it) will be returned.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The returned nodes are alphanumerically sorted by their name.</span>
<span class="sd">        This is an iterator version of :meth:`File.list_nodes`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">where</span><span class="p">)</span>  <span class="c1"># Does the parent exist?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_group</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>  <span class="c1"># Is it a group?</span>

        <span class="k">return</span> <span class="n">group</span><span class="o">.</span><span class="n">_f_iter_nodes</span><span class="p">(</span><span class="n">classname</span><span class="p">)</span></div>


<div class="viewcode-block" id="File.__contains__"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.__contains__">[docs]</a>    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Is there a node with that path?</span>

<span class="sd">        Returns True if the file has a node with the given path (a</span>
<span class="sd">        string), False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">NoSuchNodeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="File.__iter__"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.__iter__">[docs]</a>    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recursively iterate over the nodes in the tree.</span>

<span class="sd">        This is equivalent to calling :meth:`File.walk_nodes` with no</span>
<span class="sd">        arguments.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            # Recursively list all the nodes in the object tree.</span>
<span class="sd">            h5file = tables.open_file(&#39;vlarray1.h5&#39;)</span>
<span class="sd">            print(&quot;All nodes in the object tree:&quot;)</span>
<span class="sd">            for node in h5file:</span>
<span class="sd">                print(node)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">walk_nodes</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="File.walk_nodes"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.walk_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">walk_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">classname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recursively iterate over nodes hanging from where.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        where : str or Group, optional</span>
<span class="sd">            If supplied, the iteration starts from (and includes)</span>
<span class="sd">            this group. It can be a path string or a</span>
<span class="sd">            Group instance (see :ref:`GroupClassDescr`).</span>
<span class="sd">        classname</span>
<span class="sd">            If the name of a class derived from</span>
<span class="sd">            Node (see :ref:`GroupClassDescr`) is supplied, only instances of</span>
<span class="sd">            that class (or subclasses of it) will be returned.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This version iterates over the leaves in the same group in order</span>
<span class="sd">        to avoid having a list referencing to them and thus, preventing</span>
<span class="sd">        the LRU cache to remove them after their use.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            # Recursively print all the nodes hanging from &#39;/detector&#39;.</span>
<span class="sd">            print(&quot;Nodes hanging from group &#39;/detector&#39;:&quot;)</span>
<span class="sd">            for node in h5file.walk_nodes(&#39;/detector&#39;, classname=&#39;EArray&#39;):</span>
<span class="sd">                print(node)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">class_</span> <span class="o">=</span> <span class="n">get_class_by_name</span><span class="p">(</span><span class="n">classname</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">class_</span> <span class="ow">is</span> <span class="n">Group</span><span class="p">:</span>  <span class="c1"># only groups</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">walk_groups</span><span class="p">(</span><span class="n">where</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">group</span>
        <span class="k">elif</span> <span class="n">class_</span> <span class="ow">is</span> <span class="n">Node</span><span class="p">:</span>  <span class="c1"># all nodes</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">where</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">walk_groups</span><span class="p">(</span><span class="n">where</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_nodes</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">leaf</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># only nodes of the named type</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">walk_groups</span><span class="p">(</span><span class="n">where</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_nodes</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">classname</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">leaf</span></div>


<div class="viewcode-block" id="File.walk_groups"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.walk_groups">[docs]</a>    <span class="k">def</span> <span class="nf">walk_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recursively iterate over groups (not leaves) hanging from where.</span>

<span class="sd">        The where group itself is listed first (preorder), then each of its</span>
<span class="sd">        child groups (following an alphanumerical order) is also traversed,</span>
<span class="sd">        following the same procedure.  If where is not supplied, the root</span>
<span class="sd">        group is used.</span>

<span class="sd">        The where argument can be a path string</span>
<span class="sd">        or a Group instance (see :ref:`GroupClassDescr`).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">where</span><span class="p">)</span>  <span class="c1"># Does the parent exist?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_group</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>  <span class="c1"># Is it a group?</span>
        <span class="k">return</span> <span class="n">group</span><span class="o">.</span><span class="n">_f_walk_groups</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_check_open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check the state of the file.</span>

<span class="sd">        If the file is closed, a `ClosedFileError` is raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isopen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ClosedFileError</span><span class="p">(</span><span class="s2">&quot;the file object is closed&quot;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_iswritable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Is this file writable?&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_check_writable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether the file is writable.</span>

<span class="sd">        If the file is not writable, a `FileModeError` is raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iswritable</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">FileModeError</span><span class="p">(</span><span class="s2">&quot;the file is not writable&quot;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_check_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="c1"># `node` must already be a node.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Group</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;node ``</span><span class="si">%s</span><span class="s2">`` is not a group&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,))</span>


    <span class="c1"># &lt;Undo/Redo support&gt;</span>
<div class="viewcode-block" id="File.is_undo_enabled"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.is_undo_enabled">[docs]</a>    <span class="k">def</span> <span class="nf">is_undo_enabled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Is the Undo/Redo mechanism enabled?</span>

<span class="sd">        Returns True if the Undo/Redo mechanism has been enabled for</span>
<span class="sd">        this file, False otherwise. Please note that this mechanism is</span>
<span class="sd">        persistent, so a newly opened PyTables file may already have</span>
<span class="sd">        Undo/Redo support enabled.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_open</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_undoEnabled</span></div>


    <span class="k">def</span> <span class="nf">_check_undo_enabled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_undoEnabled</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UndoRedoError</span><span class="p">(</span><span class="s2">&quot;Undo/Redo feature is currently disabled!&quot;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_create_transaction_group</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tgroup</span> <span class="o">=</span> <span class="n">TransactionGroupG</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">_trans_group_name</span><span class="p">,</span>
            <span class="s2">&quot;Transaction information container&quot;</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># The format of the transaction container.</span>
        <span class="n">tgroup</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">_g__setattr</span><span class="p">(</span><span class="s1">&#39;FORMATVERSION&#39;</span><span class="p">,</span> <span class="n">_trans_version</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tgroup</span>


    <span class="k">def</span> <span class="nf">_create_transaction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">troot</span><span class="p">,</span> <span class="n">tid</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TransactionG</span><span class="p">(</span>
            <span class="n">troot</span><span class="p">,</span> <span class="n">_trans_name</span> <span class="o">%</span> <span class="n">tid</span><span class="p">,</span>
            <span class="s2">&quot;Transaction number </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">tid</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_create_mark</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">mid</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">MarkG</span><span class="p">(</span>
            <span class="n">trans</span><span class="p">,</span> <span class="n">_markName</span> <span class="o">%</span> <span class="n">mid</span><span class="p">,</span>
            <span class="s2">&quot;Mark number </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">mid</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<div class="viewcode-block" id="File.enable_undo"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.enable_undo">[docs]</a>    <span class="k">def</span> <span class="nf">enable_undo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="n">Filters</span><span class="p">(</span><span class="n">complevel</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;Enable the Undo/Redo mechanism.</span>

<span class="sd">        This operation prepares the database for undoing and redoing</span>
<span class="sd">        modifications in the node hierarchy. This</span>
<span class="sd">        allows :meth:`File.mark`, :meth:`File.undo`, :meth:`File.redo` and</span>
<span class="sd">        other methods to be called.</span>

<span class="sd">        The filters argument, when specified,</span>
<span class="sd">        must be an instance of class Filters (see :ref:`FiltersClassDescr`) and</span>
<span class="sd">        is meant for setting the compression values for the action log. The</span>
<span class="sd">        default is having compression enabled, as the gains in terms of</span>
<span class="sd">        space can be considerable. You may want to disable compression if</span>
<span class="sd">        you want maximum speed for Undo/Redo operations.</span>

<span class="sd">        Calling this method when the Undo/Redo mechanism is already</span>
<span class="sd">        enabled raises an UndoRedoError.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">maxundo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;MAX_UNDO_PATH_LENGTH&#39;</span><span class="p">]</span>

        <span class="k">class</span> <span class="nc">ActionLog</span><span class="p">(</span><span class="n">NotLoggedMixin</span><span class="p">,</span> <span class="n">Table</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="k">class</span> <span class="nc">ActionLogDesc</span><span class="p">(</span><span class="n">IsDescription</span><span class="p">):</span>
            <span class="n">opcode</span> <span class="o">=</span> <span class="n">UInt8Col</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">arg1</span> <span class="o">=</span> <span class="n">StringCol</span><span class="p">(</span><span class="n">maxundo</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dflt</span><span class="o">=</span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">arg2</span> <span class="o">=</span> <span class="n">StringCol</span><span class="p">(</span><span class="n">maxundo</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dflt</span><span class="o">=</span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_open</span><span class="p">()</span>

        <span class="c1"># Enabling several times is not allowed to avoid the user having</span>
        <span class="c1"># the illusion that a new implicit mark has been created</span>
        <span class="c1"># when calling enable_undo for the second time.</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_undo_enabled</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">UndoRedoError</span><span class="p">(</span><span class="s2">&quot;Undo/Redo feature is already enabled!&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_markers</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seqmarkers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nmarks</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_curtransaction</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># No marks yet</span>

        <span class="c1"># Get the Group for keeping user actions</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tgroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">_trans_group_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">NodeError</span><span class="p">:</span>
            <span class="c1"># The file is going to be changed.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_writable</span><span class="p">()</span>

            <span class="c1"># A transaction log group does not exist. Create it</span>
            <span class="n">tgroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_transaction_group</span><span class="p">()</span>

            <span class="c1"># Create a transaction.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_transaction</span><span class="p">(</span>
                <span class="n">tgroup</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curtransaction</span><span class="p">)</span>

            <span class="c1"># Create an action log</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span> <span class="o">=</span> <span class="n">ActionLog</span><span class="p">(</span>
                <span class="n">tgroup</span><span class="p">,</span> <span class="n">_action_log_name</span><span class="p">,</span> <span class="n">ActionLogDesc</span><span class="p">,</span> <span class="s2">&quot;Action log&quot;</span><span class="p">,</span>
                <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">)</span>

            <span class="c1"># Create an implicit mark</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="n">_op_to_code</span><span class="p">[</span><span class="s2">&quot;MARK&quot;</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">)])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nmarks</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_seqmarkers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># current action is 0</span>

            <span class="c1"># Create a group for mark 0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_mark</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trans</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="c1"># Initialize the marker pointer</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nmarks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Initialize the action pointer</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span><span class="o">.</span><span class="n">nrows</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The group seems to exist already</span>
            <span class="c1"># Get the default transaction</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_trans</span> <span class="o">=</span> <span class="n">tgroup</span><span class="o">.</span><span class="n">_f_get_child</span><span class="p">(</span>
                <span class="n">_trans_name</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curtransaction</span><span class="p">)</span>
            <span class="c1"># Open the action log and go to the end of it</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span> <span class="o">=</span> <span class="n">tgroup</span><span class="o">.</span><span class="n">actionlog</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;opcode&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">_op_to_code</span><span class="p">[</span><span class="s2">&quot;MARK&quot;</span><span class="p">]:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;arg2&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_markers</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nmarks</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_seqmarkers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">nrow</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_nmarks</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Get the current mark and current action</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">CURMARK</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">CURACTION</span>

        <span class="c1"># The Undo/Redo mechanism has been enabled.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_undoEnabled</span> <span class="o">=</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="File.disable_undo"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.disable_undo">[docs]</a>    <span class="k">def</span> <span class="nf">disable_undo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Disable the Undo/Redo mechanism.</span>

<span class="sd">        Disabling the Undo/Redo mechanism leaves the database in the</span>
<span class="sd">        current state and forgets past and future database states. This</span>
<span class="sd">        makes :meth:`File.mark`, :meth:`File.undo`, :meth:`File.redo` and other</span>
<span class="sd">        methods fail with an UndoRedoError.</span>

<span class="sd">        Calling this method when the Undo/Redo mechanism is already</span>
<span class="sd">        disabled raises an UndoRedoError.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_open</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_undo_enabled</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">UndoRedoError</span><span class="p">(</span><span class="s2">&quot;Undo/Redo feature is already disabled!&quot;</span><span class="p">)</span>

        <span class="c1"># The file is going to be changed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_writable</span><span class="p">()</span>

        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_markers</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seqmarkers</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curtransaction</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nmarks</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span>
        <span class="c1"># Recursively delete the transaction group</span>
        <span class="n">tnode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">_trans_group_path</span><span class="p">)</span>
        <span class="n">tnode</span><span class="o">.</span><span class="n">_g_remove</span><span class="p">(</span><span class="n">recursive</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># The Undo/Redo mechanism has been disabled.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_undoEnabled</span> <span class="o">=</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="File.mark"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.mark">[docs]</a>    <span class="k">def</span> <span class="nf">mark</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mark the state of the database.</span>

<span class="sd">        Creates a mark for the current state of the database. A unique (and</span>
<span class="sd">        immutable) identifier for the mark is returned. An optional name (a</span>
<span class="sd">        string) can be assigned to the mark. Both the identifier of a mark and</span>
<span class="sd">        its name can be used in :meth:`File.undo` and :meth:`File.redo`</span>
<span class="sd">        operations. When the name has already been used for another mark,</span>
<span class="sd">        an UndoRedoError is raised.</span>

<span class="sd">        This method can only be called when the Undo/Redo mechanism has been</span>
<span class="sd">        enabled. Otherwise, an UndoRedoError is raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_open</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_undo_enabled</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only strings are allowed as mark names. &quot;</span>
                                <span class="s2">&quot;You passed object: &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_markers</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">UndoRedoError</span><span class="p">(</span><span class="s2">&quot;Name &#39;</span><span class="si">%s</span><span class="s2">&#39; is already used as a marker &quot;</span>
                                    <span class="s2">&quot;name. Try another one.&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

            <span class="c1"># The file is going to be changed.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_writable</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_markers</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Create an explicit mark</span>
        <span class="c1"># Insert the mark in the action log</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;MARK&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nmarks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seqmarkers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span><span class="p">)</span>
        <span class="c1"># Create a group for the current mark</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_mark</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span></div>

    <span class="k">def</span> <span class="nf">_log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Log an action.</span>

<span class="sd">        The `action` must be an all-uppercase string identifying it.</span>
<span class="sd">        Arguments must also be strings.</span>

<span class="sd">        This method should be called once the action has been completed.</span>

<span class="sd">        This method can only be called when the Undo/Redo mechanism has</span>
<span class="sd">        been enabled.  Otherwise, an `UndoRedoError` is raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_undo_enabled</span><span class="p">()</span>

        <span class="n">maxundo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;MAX_UNDO_PATH_LENGTH&#39;</span><span class="p">]</span>
        <span class="c1"># Check whether we are at the end of the action log or not</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span><span class="o">.</span><span class="n">nrows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># We are not, so delete the trailing actions</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span><span class="o">.</span><span class="n">remove_rows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span><span class="o">.</span><span class="n">nrows</span><span class="p">)</span>
            <span class="c1"># Reset the current marker group</span>
            <span class="n">mnode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">_markPath</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_curtransaction</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span><span class="p">))</span>
            <span class="n">mnode</span><span class="o">.</span><span class="n">_g_reset</span><span class="p">()</span>
            <span class="c1"># Delete the marker groups with backup objects</span>
            <span class="k">for</span> <span class="n">mark</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nmarks</span><span class="p">):</span>
                <span class="n">mnode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">_markPath</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_curtransaction</span><span class="p">,</span> <span class="n">mark</span><span class="p">))</span>
                <span class="n">mnode</span><span class="o">.</span><span class="n">_g_remove</span><span class="p">(</span><span class="n">recursive</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Update the new number of marks</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nmarks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_seqmarkers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seqmarkers</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_nmarks</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">action</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_op_to_code</span><span class="p">:</span>  <span class="c1"># INTERNAL</span>
            <span class="k">raise</span> <span class="n">UndoRedoError</span><span class="p">(</span><span class="s2">&quot;Action ``</span><span class="si">%s</span><span class="s2">`` not in ``_op_to_code`` &quot;</span>
                                <span class="s2">&quot;dictionary: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="n">_op_to_code</span><span class="p">))</span>

        <span class="n">arg1</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">arg2</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">arg1</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">arg1</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">arg2</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># INTERNAL</span>
            <span class="k">raise</span> <span class="n">UndoRedoError</span><span class="p">(</span><span class="s2">&quot;Too many parameters for action log: &quot;</span>
                                <span class="s2">&quot;</span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arg1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxundo</span>
                <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxundo</span><span class="p">):</span>  <span class="c1"># INTERNAL</span>
            <span class="k">raise</span> <span class="n">UndoRedoError</span><span class="p">(</span><span class="s2">&quot;Parameter arg1 or arg2 is too long: &quot;</span>
                                <span class="s2">&quot;(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">))</span>
        <span class="c1"># print(&quot;Logging--&gt;&quot;, (action, arg1, arg2))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="n">_op_to_code</span><span class="p">[</span><span class="n">action</span><span class="p">],</span>
                                 <span class="n">arg1</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span>
                                 <span class="n">arg2</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_get_mark_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mark</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an integer markid from a mark sequence number or name.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mark</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">markid</span> <span class="o">=</span> <span class="n">mark</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mark</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mark</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_markers</span><span class="p">:</span>
                <span class="n">lmarkers</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_markers</span><span class="p">))</span>
                <span class="k">raise</span> <span class="n">UndoRedoError</span><span class="p">(</span><span class="s2">&quot;The mark that you have specified has not &quot;</span>
                                    <span class="s2">&quot;been found in the internal marker list: &quot;</span>
                                    <span class="s2">&quot;</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">lmarkers</span><span class="p">)</span>
            <span class="n">markid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_markers</span><span class="p">[</span><span class="n">mark</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Parameter mark can only be an integer or a &quot;</span>
                            <span class="s2">&quot;string, and you passed a type &lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">mark</span><span class="p">))</span>
        <span class="c1"># print(&quot;markid, self._nmarks:&quot;, markid, self._nmarks)</span>
        <span class="k">return</span> <span class="n">markid</span>


    <span class="k">def</span> <span class="nf">_get_final_action</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">markid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the action to go.</span>

<span class="sd">        It does not touch the self private attributes</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">markid</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nmarks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># The required mark is beyond the end of the action log</span>
            <span class="c1"># The final action is the last row</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span><span class="o">.</span><span class="n">nrows</span>
        <span class="k">elif</span> <span class="n">markid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># The required mark is the first one</span>
            <span class="c1"># return the first row</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seqmarkers</span><span class="p">[</span><span class="n">markid</span><span class="p">]</span>


    <span class="k">def</span> <span class="nf">_doundo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">finalaction</span><span class="p">,</span> <span class="n">direction</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Undo/Redo actions up to final action in the specificed direction.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">direction</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">actionlog</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span><span class="p">[</span><span class="n">finalaction</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">actionlog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span><span class="p">:</span><span class="n">finalaction</span><span class="p">]</span>

        <span class="c1"># Uncomment this for debugging</span>
<span class="c1">#         print(&quot;curaction, finalaction, direction&quot;, \</span>
<span class="c1">#               self._curaction, finalaction, direction)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">actionlog</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">actionlog</span><span class="p">[</span><span class="s1">&#39;opcode&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">_op_to_code</span><span class="p">[</span><span class="s2">&quot;MARK&quot;</span><span class="p">]:</span>
                <span class="c1"># undo/redo the action</span>
                <span class="k">if</span> <span class="n">direction</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Uncomment this for debugging</span>
<span class="c1">#                     print(&quot;redo--&gt;&quot;, \</span>
<span class="c1">#                           _code_to_op[actionlog[&#39;opcode&#39;][i]],\</span>
<span class="c1">#                           actionlog[&#39;arg1&#39;][i],\</span>
<span class="c1">#                           actionlog[&#39;arg2&#39;][i])</span>
                    <span class="n">undoredo</span><span class="o">.</span><span class="n">redo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                  <span class="c1"># _code_to_op[actionlog[&#39;opcode&#39;][i]],</span>
                                  <span class="c1"># The next is a workaround for python &lt; 2.5</span>
                                  <span class="n">_code_to_op</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">actionlog</span><span class="p">[</span><span class="s1">&#39;opcode&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])],</span>
                                  <span class="n">actionlog</span><span class="p">[</span><span class="s1">&#39;arg1&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf8&#39;</span><span class="p">),</span>
                                  <span class="n">actionlog</span><span class="p">[</span><span class="s1">&#39;arg2&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf8&#39;</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Uncomment this for debugging</span>
                    <span class="c1"># print(&quot;undo--&gt;&quot;, \</span>
                    <span class="c1">#       _code_to_op[actionlog[&#39;opcode&#39;][i]],\</span>
                    <span class="c1">#       actionlog[&#39;arg1&#39;][i].decode(&#39;utf8&#39;),\</span>
                    <span class="c1">#       actionlog[&#39;arg2&#39;][i].decode(&#39;utf8&#39;))</span>
                    <span class="n">undoredo</span><span class="o">.</span><span class="n">undo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                  <span class="c1"># _code_to_op[actionlog[&#39;opcode&#39;][i]],</span>
                                  <span class="c1"># The next is a workaround for python &lt; 2.5</span>
                                  <span class="n">_code_to_op</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">actionlog</span><span class="p">[</span><span class="s1">&#39;opcode&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])],</span>
                                  <span class="n">actionlog</span><span class="p">[</span><span class="s1">&#39;arg1&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf8&#39;</span><span class="p">),</span>
                                  <span class="n">actionlog</span><span class="p">[</span><span class="s1">&#39;arg2&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf8&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">direction</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">actionlog</span><span class="p">[</span><span class="s1">&#39;arg1&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">actionlog</span><span class="p">[</span><span class="s1">&#39;arg1&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="c1"># Protection against negative marks</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span> <span class="o">+=</span> <span class="n">direction</span>

<div class="viewcode-block" id="File.undo"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.undo">[docs]</a>    <span class="k">def</span> <span class="nf">undo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mark</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Go to a past state of the database.</span>

<span class="sd">        Returns the database to the state associated with the specified mark.</span>
<span class="sd">        Both the identifier of a mark and its name can be used. If the mark is</span>
<span class="sd">        omitted, the last created mark is used. If there are no past</span>
<span class="sd">        marks, or the specified mark is not older than the current one, an</span>
<span class="sd">        UndoRedoError is raised.</span>

<span class="sd">        This method can only be called when the Undo/Redo mechanism</span>
<span class="sd">        has been enabled. Otherwise, an UndoRedoError</span>
<span class="sd">        is raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_open</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_undo_enabled</span><span class="p">()</span>

<span class="c1">#         print(&quot;(pre)UNDO: (curaction, curmark) = (%s,%s)&quot; % \</span>
<span class="c1">#               (self._curaction, self._curmark))</span>
        <span class="k">if</span> <span class="n">mark</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">markid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span>
            <span class="c1"># Correction if we are settled on top of a mark</span>
            <span class="n">opcode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">opcode</span>
            <span class="k">if</span> <span class="n">opcode</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span><span class="p">]</span> <span class="o">==</span> <span class="n">_op_to_code</span><span class="p">[</span><span class="s2">&quot;MARK&quot;</span><span class="p">]:</span>
                <span class="n">markid</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get the mark ID number</span>
            <span class="n">markid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_mark_id</span><span class="p">(</span><span class="n">mark</span><span class="p">)</span>
        <span class="c1"># Get the final action ID to go</span>
        <span class="n">finalaction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_final_action</span><span class="p">(</span><span class="n">markid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">finalaction</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UndoRedoError</span><span class="p">(</span><span class="s2">&quot;Mark ``</span><span class="si">%s</span><span class="s2">`` is newer than the current mark. &quot;</span>
                                <span class="s2">&quot;Use `redo()` or `goto()` instead.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mark</span><span class="p">,))</span>

        <span class="c1"># The file is going to be changed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_writable</span><span class="p">()</span>

        <span class="c1"># Try to reach this mark by unwinding actions in the log</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_doundo</span><span class="p">(</span><span class="n">finalaction</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span><span class="o">.</span><span class="n">nrows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">arg1</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span><span class="p">])</span></div>
<span class="c1">#         print(&quot;(post)UNDO: (curaction, curmark) = (%s,%s)&quot; % \</span>
<span class="c1">#               (self._curaction, self._curmark))</span>

<div class="viewcode-block" id="File.redo"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.redo">[docs]</a>    <span class="k">def</span> <span class="nf">redo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mark</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Go to a future state of the database.</span>

<span class="sd">        Returns the database to the state associated with the specified</span>
<span class="sd">        mark.  Both the identifier of a mark and its name can be used.</span>
<span class="sd">        If the `mark` is omitted, the next created mark is used.  If</span>
<span class="sd">        there are no future marks, or the specified mark is not newer</span>
<span class="sd">        than the current one, an UndoRedoError is raised.</span>

<span class="sd">        This method can only be called when the Undo/Redo mechanism has</span>
<span class="sd">        been enabled.  Otherwise, an UndoRedoError is raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_open</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_undo_enabled</span><span class="p">()</span>

<span class="c1">#         print(&quot;(pre)REDO: (curaction, curmark) = (%s, %s)&quot; % \</span>
<span class="c1">#               (self._curaction, self._curmark))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span><span class="o">.</span><span class="n">nrows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># We are at the end of log, so no action</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">mark</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mark</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">mark</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">mark</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nmarks</span><span class="p">)</span>  <span class="c1"># Go beyond the mark bounds up to the end</span>
        <span class="c1"># Get the mark ID number</span>
        <span class="n">markid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_mark_id</span><span class="p">(</span><span class="n">mark</span><span class="p">)</span>
        <span class="n">finalaction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_final_action</span><span class="p">(</span><span class="n">markid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">finalaction</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UndoRedoError</span><span class="p">(</span><span class="s2">&quot;Mark ``</span><span class="si">%s</span><span class="s2">`` is older than the current mark. &quot;</span>
                                <span class="s2">&quot;Use `redo()` or `goto()` instead.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mark</span><span class="p">,))</span>

        <span class="c1"># The file is going to be changed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_writable</span><span class="p">()</span>

        <span class="c1"># Get the final action ID to go</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Try to reach this mark by redoing the actions in the log</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_doundo</span><span class="p">(</span><span class="n">finalaction</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Increment the current mark only if we are not at the end of marks</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nmarks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span><span class="o">.</span><span class="n">nrows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span><span class="o">.</span><span class="n">nrows</span> <span class="o">-</span> <span class="mi">1</span></div>
<span class="c1">#         print(&quot;(post)REDO: (curaction, curmark) = (%s,%s)&quot; % \</span>
<span class="c1">#               (self._curaction, self._curmark))</span>

<div class="viewcode-block" id="File.goto"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.goto">[docs]</a>    <span class="k">def</span> <span class="nf">goto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mark</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Go to a specific mark of the database.</span>

<span class="sd">        Returns the database to the state associated with the specified mark.</span>
<span class="sd">        Both the identifier of a mark and its name can be used.</span>

<span class="sd">        This method can only be called when the Undo/Redo mechanism has been</span>
<span class="sd">        enabled. Otherwise, an UndoRedoError is raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_open</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_undo_enabled</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">mark</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># Special case</span>
            <span class="n">mark</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nmarks</span>  <span class="c1"># Go beyond the mark bounds up to the end</span>
        <span class="c1"># Get the mark ID number</span>
        <span class="n">markid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_mark_id</span><span class="p">(</span><span class="n">mark</span><span class="p">)</span>
        <span class="n">finalaction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_final_action</span><span class="p">(</span><span class="n">markid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">finalaction</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">undo</span><span class="p">(</span><span class="n">mark</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">redo</span><span class="p">(</span><span class="n">mark</span><span class="p">)</span></div>

<div class="viewcode-block" id="File.get_current_mark"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.get_current_mark">[docs]</a>    <span class="k">def</span> <span class="nf">get_current_mark</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the identifier of the current mark.</span>

<span class="sd">        Returns the identifier of the current mark. This can be used</span>
<span class="sd">        to know the state of a database after an application crash, or to</span>
<span class="sd">        get the identifier of the initial implicit mark after a call</span>
<span class="sd">        to :meth:`File.enable_undo`.</span>

<span class="sd">        This method can only be called when the Undo/Redo mechanism</span>
<span class="sd">        has been enabled. Otherwise, an UndoRedoError</span>
<span class="sd">        is raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_open</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_undo_enabled</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span></div>


    <span class="k">def</span> <span class="nf">_shadow_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute and return a shadow name.</span>

<span class="sd">        Computes the current shadow name according to the current</span>
<span class="sd">        transaction, mark and action.  It returns a tuple with the</span>
<span class="sd">        shadow parent node and the name of the shadow in it.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span>
            <span class="n">_shadow_parent</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_curtransaction</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span><span class="p">))</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">_shadow_name</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span><span class="p">,)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>


    <span class="c1"># &lt;/Undo/Redo support&gt;</span>

<div class="viewcode-block" id="File.flush"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.flush">[docs]</a>    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Flush all the alive leaves in the object tree.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_open</span><span class="p">()</span>

        <span class="c1"># Flush the cache to disk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_manager</span><span class="o">.</span><span class="n">flush_nodes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flush_file</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># 0 means local scope, 1 global (virtual) scope</span></div>

<div class="viewcode-block" id="File.close"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Flush all the alive leaves in object tree and close the file.&quot;&quot;&quot;</span>

        <span class="c1"># If the file is already closed, return immediately</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isopen</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># If this file has been opened more than once, decrease the</span>
        <span class="c1"># counter and return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_open_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_open_count</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">return</span>

        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_undoEnabled</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iswritable</span><span class="p">():</span>
            <span class="c1"># Save the current mark and current action</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">_g__setattr</span><span class="p">(</span><span class="s2">&quot;CURMARK&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curmark</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_actionlog</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">_g__setattr</span><span class="p">(</span><span class="s2">&quot;CURACTION&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curaction</span><span class="p">)</span>

        <span class="c1"># Close all loaded nodes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_f_close</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_node_manager</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>

        <span class="c1"># Post-conditions</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_manager</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> \
            <span class="p">(</span><span class="s2">&quot;cached nodes remain after closing: </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_manager</span><span class="o">.</span><span class="n">cache</span><span class="p">))</span>

        <span class="c1"># No other nodes should have been revived.</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_manager</span><span class="o">.</span><span class="n">registry</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> \
            <span class="p">(</span><span class="s2">&quot;alive nodes remain after closing: </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_manager</span><span class="o">.</span><span class="n">registry</span><span class="p">))</span>

        <span class="c1"># Close the file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_file</span><span class="p">()</span>

        <span class="c1"># After the objects are disconnected, destroy the</span>
        <span class="c1"># object dictionary using the brute force ;-)</span>
        <span class="c1"># This should help to the garbage collector</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="c1"># Set the flag to indicate that the file is closed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isopen</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Restore the filename attribute that is used by _FileRegistry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>

        <span class="c1"># Delete the entry from he registry of opened files</span>
        <span class="n">_open_files</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="File.__enter__"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.__enter__">[docs]</a>    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Enter a context and return the same file.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="File.__exit__"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.__exit__">[docs]</a>    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">exc_info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Exit a context and close the file.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># do not hide exceptions</span></div>

<div class="viewcode-block" id="File.__str__"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a short string representation of the object tree.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            &gt;&gt;&gt; f = tables.open_file(&#39;data/test.h5&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(f)</span>
<span class="sd">            data/test.h5 (File) &#39;Table Benchmark&#39;</span>
<span class="sd">            Last modif.: &#39;Mon Sep 20 12:40:47 2004&#39;</span>
<span class="sd">            Object Tree:</span>
<span class="sd">            / (Group) &#39;Table Benchmark&#39;</span>
<span class="sd">            /tuple0 (Table(100,)) &#39;This is the table title&#39;</span>
<span class="sd">            /group0 (Group) &#39;&#39;</span>
<span class="sd">            /group0/tuple1 (Table(100,)) &#39;This is the table title&#39;</span>
<span class="sd">            /group0/group1 (Group) &#39;&#39;</span>
<span class="sd">            /group0/group1/tuple2 (Table(100,)) &#39;This is the table title&#39;</span>
<span class="sd">            /group0/group1/group2 (Group) &#39;&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isopen</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&lt;closed File&gt;&quot;</span>

        <span class="c1"># Print all the nodes (Group and Leaf objects) on object tree</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">date</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)[</span><span class="mi">8</span><span class="p">]))</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="c1"># in-memory file</span>
            <span class="n">date</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">astring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">+</span> <span class="s1">&#39; (File) &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
<span class="c1">#         astring += &#39;root_uep :=&#39; + repr(self.root_uep) + &#39;; &#39;</span>
<span class="c1">#         astring += &#39;format_version := &#39; + self.format_version + &#39;\n&#39;</span>
<span class="c1">#         astring += &#39;filters :=&#39; + repr(self.filters) + &#39;\n&#39;</span>
        <span class="n">astring</span> <span class="o">+=</span> <span class="s1">&#39;Last modif.: &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">date</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">astring</span> <span class="o">+=</span> <span class="s1">&#39;Object Tree: </span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">walk_groups</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">):</span>
            <span class="n">astring</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="k">for</span> <span class="n">kind</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_kinds</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_nodes</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">kind</span><span class="p">):</span>
                    <span class="n">astring</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">astring</span></div>

<div class="viewcode-block" id="File.__repr__"><a class="viewcode-back" href="../../usersguide/libref/file_class.html#tables.File.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a detailed string representation of the object tree.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isopen</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&lt;closed File&gt;&quot;</span>

        <span class="c1"># Print all the nodes (Group and Leaf objects) on object tree</span>
        <span class="n">astring</span> <span class="o">=</span> <span class="s1">&#39;File(filename=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span> <span class="o">+</span> \
                  <span class="s1">&#39;, title=&#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="p">)</span> <span class="o">+</span> \
                  <span class="s1">&#39;, mode=&#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">)</span> <span class="o">+</span> \
                  <span class="s1">&#39;, root_uep=&#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_uep</span><span class="p">)</span> <span class="o">+</span> \
                  <span class="s1">&#39;, filters=&#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="p">)</span> <span class="o">+</span> \
                  <span class="s1">&#39;)</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">walk_groups</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">):</span>
            <span class="n">astring</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="k">for</span> <span class="n">kind</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_kinds</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_nodes</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">kind</span><span class="p">):</span>
                    <span class="n">astring</span> <span class="o">+=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">astring</span></div>

    <span class="k">def</span> <span class="nf">_update_node_locations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oldpath</span><span class="p">,</span> <span class="n">newpath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update location information of nodes under `oldpath`.</span>

<span class="sd">        This only affects *already loaded* nodes.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">oldprefix</span> <span class="o">=</span> <span class="n">oldpath</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span>  <span class="c1"># root node can not be renamed, anyway</span>
        <span class="n">oldprefix_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">oldprefix</span><span class="p">)</span>

        <span class="c1"># Update alive and dead descendents.</span>
        <span class="k">for</span> <span class="n">cache</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_manager</span><span class="o">.</span><span class="n">cache</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_manager</span><span class="o">.</span><span class="n">registry</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">nodepath</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nodepath</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">oldprefix</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nodepath</span> <span class="o">!=</span> <span class="n">oldprefix</span><span class="p">:</span>
                    <span class="n">nodesuffix</span> <span class="o">=</span> <span class="n">nodepath</span><span class="p">[</span><span class="n">oldprefix_len</span><span class="p">:]</span>
                    <span class="n">newnodepath</span> <span class="o">=</span> <span class="n">join_path</span><span class="p">(</span><span class="n">newpath</span><span class="p">,</span> <span class="n">nodesuffix</span><span class="p">)</span>
                    <span class="n">newnodeppath</span> <span class="o">=</span> <span class="n">split_path</span><span class="p">(</span><span class="n">newnodepath</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">descendent_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node</span><span class="p">(</span><span class="n">nodepath</span><span class="p">)</span>
                    <span class="n">descendent_node</span><span class="o">.</span><span class="n">_g_update_location</span><span class="p">(</span><span class="n">newnodeppath</span><span class="p">)</span></div>



<span class="c1"># If a user hits ^C during a run, it is wise to gracefully close the</span>
<span class="c1"># opened files.</span>
<span class="kn">import</span> <span class="nn">atexit</span>
<span class="n">atexit</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">_open_files</span><span class="o">.</span><span class="n">close_all</span><span class="p">)</span>


<span class="c1">## Local Variables:</span>
<span class="c1">## mode: python</span>
<span class="c1">## py-indent-offset: 4</span>
<span class="c1">## tab-width: 4</span>
<span class="c1">## fill-column: 72</span>
<span class="c1">## End:</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2011-2017, PyTables maintainers.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'3.4.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>