

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>tables.index &mdash; PyTables 3.6.2.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
 
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-111342564-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-111342564-1');
</script>


</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/logo-pytables-small.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                3.6.2.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../usersguide/index.html">Userâ€™s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cookbook/index.html">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../other_material.html">Other Material</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../MIGRATING_TO_3.x.html">Migrating from 2.x to 3.x</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../downloads.html">Downloads</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release_notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../project_pointers.html">Project pointers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev_team.html">Development Team</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PyTables</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>tables.index</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for tables.index</h1><div class="highlight"><pre>
<span></span><span class="c1">#######################################################################</span>
<span class="c1">#</span>
<span class="c1"># License: BSD</span>
<span class="c1"># Created: June 08, 2004</span>
<span class="c1"># Author: Francesc Alted - faltet@pytables.com</span>
<span class="c1">#</span>
<span class="c1"># $Id$</span>
<span class="c1">#</span>
<span class="c1">########################################################################</span>

<span class="sd">&quot;&quot;&quot;Here is defined the Index class.&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span><span class="p">,</span> <span class="n">perf_counter</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">.idxutils</span> <span class="kn">import</span> <span class="p">(</span><span class="n">calc_chunksize</span><span class="p">,</span> <span class="n">calcoptlevels</span><span class="p">,</span>
                             <span class="n">get_reduction_level</span><span class="p">,</span> <span class="n">nextafter</span><span class="p">,</span> <span class="n">inftype</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">indexesextension</span>
<span class="kn">from</span> <span class="nn">.node</span> <span class="kn">import</span> <span class="n">NotLoggedMixin</span>
<span class="kn">from</span> <span class="nn">.atom</span> <span class="kn">import</span> <span class="n">UIntAtom</span><span class="p">,</span> <span class="n">Atom</span>
<span class="kn">from</span> <span class="nn">.earray</span> <span class="kn">import</span> <span class="n">EArray</span>
<span class="kn">from</span> <span class="nn">.carray</span> <span class="kn">import</span> <span class="n">CArray</span>
<span class="kn">from</span> <span class="nn">.leaf</span> <span class="kn">import</span> <span class="n">Filters</span>
<span class="kn">from</span> <span class="nn">.indexes</span> <span class="kn">import</span> <span class="n">CacheArray</span><span class="p">,</span> <span class="n">LastRowArray</span><span class="p">,</span> <span class="n">IndexArray</span>
<span class="kn">from</span> <span class="nn">.group</span> <span class="kn">import</span> <span class="n">Group</span>
<span class="kn">from</span> <span class="nn">.path</span> <span class="kn">import</span> <span class="n">join_path</span>
<span class="kn">from</span> <span class="nn">.exceptions</span> <span class="kn">import</span> <span class="n">PerformanceWarning</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">is_idx</span><span class="p">,</span> <span class="n">idx2long</span><span class="p">,</span> <span class="n">lazyattr</span>
<span class="kn">from</span> <span class="nn">.utilsextension</span> <span class="kn">import</span> <span class="p">(</span><span class="n">nan_aware_gt</span><span class="p">,</span> <span class="n">nan_aware_ge</span><span class="p">,</span>
                                   <span class="n">nan_aware_lt</span><span class="p">,</span> <span class="n">nan_aware_le</span><span class="p">,</span>
                                   <span class="n">bisect_left</span><span class="p">,</span> <span class="n">bisect_right</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.lrucacheextension</span> <span class="kn">import</span> <span class="n">ObjectCache</span>



<span class="c1"># default version for INDEX objects</span>
<span class="c1"># obversion = &quot;1.0&quot;    # Version of indexes in PyTables 1.x series</span>
<span class="c1"># obversion = &quot;2.0&quot;    # Version of indexes in PyTables Pro 2.0 series</span>
<span class="n">obversion</span> <span class="o">=</span> <span class="s2">&quot;2.1&quot;</span>     <span class="c1"># Version of indexes in PyTables Pro 2.1 and up series,</span>
                      <span class="c1"># including the join 2.3 Std + Pro version</span>


<span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
<span class="c1"># debug = True  # Uncomment this for printing sizes purposes</span>
<span class="n">profile</span> <span class="o">=</span> <span class="kc">False</span>
<span class="c1"># profile = True  # Uncomment for profiling</span>
<span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">show_stats</span>


<span class="c1"># The default method for sorting</span>
<span class="c1"># defsort = &quot;quicksort&quot;</span>
<span class="c1"># Changing to mergesort to fix #441</span>
<span class="n">defsort</span> <span class="o">=</span> <span class="s2">&quot;mergesort&quot;</span>

<span class="c1"># Default policy for automatically updating indexes after a table</span>
<span class="c1"># append operation, or automatically reindexing after an</span>
<span class="c1"># index-invalidating operation like removing or modifying table rows.</span>
<span class="n">default_auto_index</span> <span class="o">=</span> <span class="kc">True</span>
<span class="c1"># Keep in sync with ``Table.autoindex`` docstring.</span>

<span class="c1"># Default filters used to compress indexes.  This is quite fast and</span>
<span class="c1"># compression is pretty good.</span>
<span class="c1"># Remember to keep these defaults in sync with the docstrings and UG.</span>
<span class="n">default_index_filters</span> <span class="o">=</span> <span class="n">Filters</span><span class="p">(</span><span class="n">complevel</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">complib</span><span class="o">=</span><span class="s1">&#39;zlib&#39;</span><span class="p">,</span>
                                <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fletcher32</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># Deprecated API</span>
<span class="n">defaultAutoIndex</span> <span class="o">=</span> <span class="n">default_auto_index</span>
<span class="n">defaultIndexFilters</span> <span class="o">=</span> <span class="n">default_index_filters</span>

<span class="c1"># The list of types for which an optimised search in cython and C has</span>
<span class="c1"># been implemented. Always add here the name of a new optimised type.</span>
<span class="n">opt_search_types</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;int8&quot;</span><span class="p">,</span> <span class="s2">&quot;int16&quot;</span><span class="p">,</span> <span class="s2">&quot;int32&quot;</span><span class="p">,</span> <span class="s2">&quot;int64&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;uint8&quot;</span><span class="p">,</span> <span class="s2">&quot;uint16&quot;</span><span class="p">,</span> <span class="s2">&quot;uint32&quot;</span><span class="p">,</span> <span class="s2">&quot;uint64&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="s2">&quot;float64&quot;</span><span class="p">)</span>

<span class="c1"># The upper limit for uint32 ints</span>
<span class="n">max32</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span>


<span class="k">def</span> <span class="nf">_table_column_pathname_of_index</span><span class="p">(</span><span class="n">indexpathname</span><span class="p">):</span>
    <span class="n">names</span> <span class="o">=</span> <span class="n">indexpathname</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_i_&#39;</span><span class="p">):</span>
            <span class="k">break</span>
    <span class="n">tablepathname</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
    <span class="n">colpathname</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">tablepathname</span><span class="p">,</span> <span class="n">colpathname</span><span class="p">)</span>


<div class="viewcode-block" id="Index"><a class="viewcode-back" href="../../usersguide/libref/helper_classes.html#tables.index.Index">[docs]</a><span class="k">class</span> <span class="nc">Index</span><span class="p">(</span><span class="n">NotLoggedMixin</span><span class="p">,</span> <span class="n">Group</span><span class="p">,</span> <span class="n">indexesextension</span><span class="o">.</span><span class="n">Index</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents the index of a column in a table.</span>

<span class="sd">    This class is used to keep the indexing information for columns in a Table</span>
<span class="sd">    dataset (see :ref:`TableClassDescr`). It is actually a descendant of the</span>
<span class="sd">    Group class (see :ref:`GroupClassDescr`), with some added functionality. An</span>
<span class="sd">    Index is always associated with one and only one column in the table.</span>

<span class="sd">    .. note::</span>

<span class="sd">        This class is mainly intended for internal use, but some of its</span>
<span class="sd">        documented attributes and methods may be interesting for the</span>
<span class="sd">        programmer.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parentnode</span>
<span class="sd">        The parent :class:`Group` object.</span>

<span class="sd">        .. versionchanged:: 3.0</span>
<span class="sd">           Renamed from *parentNode* to *parentnode*.</span>

<span class="sd">    name : str</span>
<span class="sd">        The name of this node in its parent group.</span>
<span class="sd">    atom : Atom</span>
<span class="sd">        An Atom object representing the shape and type of the atomic objects to</span>
<span class="sd">        be saved. Only scalar atoms are supported.</span>
<span class="sd">    title</span>
<span class="sd">        Sets a TITLE attribute of the Index entity.</span>
<span class="sd">    kind</span>
<span class="sd">        The desired kind for this index.  The &#39;full&#39; kind specifies a complete</span>
<span class="sd">        track of the row position (64-bit), while the &#39;medium&#39;, &#39;light&#39; or</span>
<span class="sd">        &#39;ultralight&#39; kinds only specify in which chunk the row is (using</span>
<span class="sd">        32-bit, 16-bit and 8-bit respectively).</span>
<span class="sd">    optlevel</span>
<span class="sd">        The desired optimization level for this index.</span>
<span class="sd">    filters : Filters</span>
<span class="sd">        An instance of the Filters class that provides information about the</span>
<span class="sd">        desired I/O filters to be applied during the life of this object.</span>
<span class="sd">    tmp_dir</span>
<span class="sd">        The directory for the temporary files.</span>
<span class="sd">    expectedrows</span>
<span class="sd">        Represents an user estimate about the number of row slices that will be</span>
<span class="sd">        added to the growable dimension in the IndexArray object.</span>
<span class="sd">    byteorder</span>
<span class="sd">        The byteorder of the index datasets *on-disk*.</span>
<span class="sd">    blocksizes</span>
<span class="sd">        The four main sizes of the compound blocks in index datasets (a low</span>
<span class="sd">        level parameter).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_c_classid</span> <span class="o">=</span> <span class="s1">&#39;INDEX&#39;</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The kind of this index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;ultralight&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;light&#39;</span><span class="p">,</span>
                <span class="mi">4</span><span class="p">:</span> <span class="s1">&#39;medium&#39;</span><span class="p">,</span> <span class="mi">8</span><span class="p">:</span> <span class="s1">&#39;full&#39;</span><span class="p">}[</span><span class="bp">self</span><span class="o">.</span><span class="n">indsize</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Filter properties for this index - see Filters in</span>
<span class="sd">        :ref:`FiltersClassDescr`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_filters</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dirty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
       <span class="sd">&quot;&quot;&quot;Whether the index is dirty or not.</span>
<span class="sd">       Dirty indexes are out of sync with column data, so they exist but they</span>
<span class="sd">       are not usable.</span>
<span class="sd">       &quot;&quot;&quot;</span>

       <span class="c1"># If there is no ``DIRTY`` attribute, index should be clean.</span>
       <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="p">,</span> <span class="s1">&#39;DIRTY&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="nd">@dirty</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dirty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirty</span><span class="p">):</span>
        <span class="n">wasdirty</span><span class="p">,</span> <span class="n">isdirty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirty</span><span class="p">,</span> <span class="nb">bool</span><span class="p">(</span><span class="n">dirty</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">DIRTY</span> <span class="o">=</span> <span class="n">dirty</span>
        <span class="c1"># If an *actual* change in dirtiness happens,</span>
        <span class="c1"># notify the condition cache by setting or removing a nail.</span>
        <span class="n">conditioncache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">_condition_cache</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">wasdirty</span> <span class="ow">and</span> <span class="n">isdirty</span><span class="p">:</span>
            <span class="n">conditioncache</span><span class="o">.</span><span class="n">nail</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">wasdirty</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isdirty</span><span class="p">:</span>
            <span class="n">conditioncache</span><span class="o">.</span><span class="n">unnail</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">column</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The Column (see :ref:`ColumnClassDescr`) instance for the indexed</span>
<span class="sd">        column.&quot;&quot;&quot;</span>

        <span class="n">tablepath</span><span class="p">,</span> <span class="n">columnpath</span> <span class="o">=</span> <span class="n">_table_column_pathname_of_index</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">)</span>
        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_get_node</span><span class="p">(</span><span class="n">tablepath</span><span class="p">)</span>
        <span class="n">column</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">_g_col</span><span class="p">(</span><span class="n">columnpath</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">column</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Accessor for the `Table` object of this index.&quot;&quot;&quot;</span>
        <span class="n">tablepath</span><span class="p">,</span> <span class="n">columnpath</span> <span class="o">=</span> <span class="n">_table_column_pathname_of_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">)</span>
        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_get_node</span><span class="p">(</span><span class="n">tablepath</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">table</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nblockssuperblock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of blocks in a superblock.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">superblocksize</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nslicesblock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of slices in a block.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nchunkslice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of chunks in a slice.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nsuperblocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The total number of superblocks in index.&quot;&quot;&quot;</span>
        <span class="c1"># Last row should not be considered as a superblock</span>
        <span class="n">nelements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelements</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelementsILR</span>
        <span class="n">nblocks</span> <span class="o">=</span> <span class="n">nelements</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">superblocksize</span>
        <span class="k">if</span> <span class="n">nelements</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nblocks</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">nblocks</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nblocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The total number of blocks in index.&quot;&quot;&quot;</span>
        <span class="c1"># Last row should not be considered as a block</span>
        <span class="n">nelements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelements</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelementsILR</span>
        <span class="n">nblocks</span> <span class="o">=</span> <span class="n">nelements</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span>
        <span class="k">if</span> <span class="n">nelements</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nblocks</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">nblocks</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nslices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of complete slices in index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelements</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nchunks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of complete chunks in index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelements</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The shape of this index (in slices and elements).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">temp_required</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Whether a temporary file for indexes is required or not.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">optlevel</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">nrows</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">want_complete_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Whether we should try to build a completely sorted index or not.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span> <span class="o">==</span> <span class="mi">8</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">optlevel</span> <span class="o">==</span> <span class="mi">9</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_csi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Whether the index is completely sorted or not.</span>

<span class="sd">        .. versionchanged:: 3.0</span>
<span class="sd">           The *is_CSI* property has been renamed into *is_csi*.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelements</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># An index with 0 indexed elements is not a CSI one (by definition)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">:</span>
            <span class="c1"># An index that is not full cannot be completely sorted</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># Try with the &#39;is_csi&#39; attribute</span>
        <span class="k">if</span> <span class="s1">&#39;is_csi&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">is_csi</span>
        <span class="c1"># If not, then compute the overlaps manually</span>
        <span class="c1"># (the attribute &#39;is_csi&#39; will be set there)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">noverlaps</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="nd">@lazyattr</span>
    <span class="k">def</span> <span class="nf">nrowsinchunk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of rows that fits in a *table* chunk.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">chunkshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@lazyattr</span>
    <span class="k">def</span> <span class="nf">lbucket</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the length of a bucket based index type.&quot;&quot;&quot;</span>

        <span class="c1"># Avoid to set a too large lbucket size (mainly useful for tests)</span>
        <span class="n">lbucket</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrowsinchunk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># For ultra-light, we will never have to keep track of a</span>
            <span class="c1"># bucket outside of a slice.</span>
            <span class="n">maxnb</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">8</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span> <span class="o">&gt;</span> <span class="n">maxnb</span> <span class="o">*</span> <span class="n">lbucket</span><span class="p">:</span>
                <span class="n">lbucket</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span><span class="p">)</span> <span class="o">/</span> <span class="n">maxnb</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># For light, we will never have to keep track of a</span>
            <span class="c1"># bucket outside of a block.</span>
            <span class="n">maxnb</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span> <span class="o">&gt;</span> <span class="n">maxnb</span> <span class="o">*</span> <span class="n">lbucket</span><span class="p">:</span>
                <span class="n">lbucket</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span><span class="p">)</span> <span class="o">/</span> <span class="n">maxnb</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For medium and full indexes there should not be a need to</span>
            <span class="c1"># increase lbucket</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">lbucket</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parentnode</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                 <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                 <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">optlevel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">filters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">tmp_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">expectedrows</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">byteorder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">blocksizes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">new</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_v_version</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;The object version of this index.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optlevel</span> <span class="o">=</span> <span class="n">optlevel</span>
        <span class="sd">&quot;&quot;&quot;The optimization level for this index.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmp_dir</span> <span class="o">=</span> <span class="n">tmp_dir</span>
        <span class="sd">&quot;&quot;&quot;The directory for the temporary files.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expectedrows</span> <span class="o">=</span> <span class="n">expectedrows</span>
        <span class="sd">&quot;&quot;&quot;The expected number of items of index arrays.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">byteorder</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;little&quot;</span><span class="p">,</span> <span class="s2">&quot;big&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">=</span> <span class="n">byteorder</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span>
        <span class="sd">&quot;&quot;&quot;The byteorder of the index datasets.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">base</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">type</span>
            <span class="sd">&quot;&quot;&quot;The datatypes to be stored by the sorted index array.&quot;&quot;&quot;</span>
            <span class="c1">############### Important note ###########################</span>
            <span class="c1"># The datatypes saved as index values are NumPy native</span>
            <span class="c1"># types, so we get rid of type metainfo like Time* or Enum*</span>
            <span class="c1"># that belongs to HDF5 types (actually, this metainfo is</span>
            <span class="c1"># not needed for sorting and looking-up purposes).</span>
            <span class="c1">##########################################################</span>
            <span class="n">indsize</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;ultralight&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;light&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;medium&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;full&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">}[</span><span class="n">kind</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">indsize</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="s2">&quot;indsize should be 1, 2, 4 or 8!&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span> <span class="o">=</span> <span class="n">indsize</span>
            <span class="sd">&quot;&quot;&quot;The itemsize for the indices part of the index.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;The total number of slices in the index.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nelements</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;The number of currently indexed rows for this column.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocksizes</span> <span class="o">=</span> <span class="n">blocksizes</span>
        <span class="sd">&quot;&quot;&quot;The four main sizes of the compound blocks (if specified).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dirtycache</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="sd">&quot;&quot;&quot;Dirty cache (for ranges, bounds &amp; sorted) flag.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">superblocksize</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Size of the superblock for this index.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Size of the block for this index.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Size of the slice for this index.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Size of the chunk for this index.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmpfilename</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Filename for temporary bounds.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opt_search_types</span> <span class="o">=</span> <span class="n">opt_search_types</span>
        <span class="sd">&quot;&quot;&quot;The types for which and optimized search has been implemented.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noverlaps</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;The number of overlaps in an index.  0 means a completely</span>
<span class="sd">        sorted index. -1 means that this number is not computed yet.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tprof</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="sd">&quot;&quot;&quot;Time counter for benchmarking purposes.&quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">.file</span> <span class="kn">import</span> <span class="n">open_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_openFile</span> <span class="o">=</span> <span class="n">open_file</span>
        <span class="sd">&quot;&quot;&quot;The `open_file()` function, to avoid a circular import.&quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parentnode</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">filters</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_g_post_init_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_new</span><span class="p">:</span>
            <span class="c1"># The version for newly created indexes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_version</span> <span class="o">=</span> <span class="n">obversion</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_g_post_init_hook</span><span class="p">()</span>

        <span class="c1"># Index arrays must only be created for new indexes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_new</span><span class="p">:</span>
            <span class="n">idxversion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_version</span>
            <span class="c1"># Set-up some variables from info on disk and return</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span>
            <span class="c1"># Coerce NumPy scalars to Python scalars in order</span>
            <span class="c1"># to avoid undesired upcasting operations.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">superblocksize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">attrs</span><span class="o">.</span><span class="n">superblocksize</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">attrs</span><span class="o">.</span><span class="n">blocksize</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">attrs</span><span class="o">.</span><span class="n">slicesize</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">attrs</span><span class="o">.</span><span class="n">chunksize</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blocksizes</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">superblocksize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optlevel</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">attrs</span><span class="o">.</span><span class="n">optlevel</span><span class="p">)</span>
            <span class="nb">sorted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="nb">sorted</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">dtype</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">sorted</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">type</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">itemsize</span>
            <span class="c1"># Some sanity checks for slicesize, chunksize and indsize</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span> <span class="o">==</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Wrong slicesize&quot;</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span> <span class="o">==</span> <span class="n">indices</span><span class="o">.</span><span class="n">_v_chunkshape</span><span class="p">[</span>
                <span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Wrong chunksize&quot;</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="s2">&quot;Wrong indices itemsize&quot;</span>
            <span class="k">if</span> <span class="n">idxversion</span> <span class="o">&gt;</span> <span class="s2">&quot;2.0&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">attrs</span><span class="o">.</span><span class="n">reduction</span><span class="p">)</span>
                <span class="n">nelementsSLR</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sortedLR</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">nelements</span><span class="p">)</span>
                <span class="n">nelementsILR</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indicesLR</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">nelements</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">nelementsILR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicesLR</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">nelementsSLR</span> <span class="o">=</span> <span class="n">nelementsILR</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span> <span class="o">=</span> <span class="nb">sorted</span><span class="o">.</span><span class="n">nrows</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nelements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span> <span class="o">+</span> <span class="n">nelementsILR</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nelementsSLR</span> <span class="o">=</span> <span class="n">nelementsSLR</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nelementsILR</span> <span class="o">=</span> <span class="n">nelementsILR</span>
            <span class="k">if</span> <span class="n">nelementsILR</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Get the bounds as a cache (this has to remain here!)</span>
            <span class="n">rchunksize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span>
            <span class="n">nboundsLR</span> <span class="o">=</span> <span class="p">(</span><span class="n">nelementsSLR</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">rchunksize</span>
            <span class="k">if</span> <span class="n">nboundsLR</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nboundsLR</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># correction for -1 bounds</span>
            <span class="n">nboundsLR</span> <span class="o">+=</span> <span class="mi">2</span>  <span class="c1"># bounds + begin + end</span>
            <span class="c1"># All bounds values (+begin + end) are at the end of sortedLR</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bebounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sortedLR</span><span class="p">[</span>
                <span class="n">nelementsSLR</span><span class="p">:</span><span class="n">nelementsSLR</span> <span class="o">+</span> <span class="n">nboundsLR</span><span class="p">]</span>
            <span class="k">return</span>

        <span class="c1"># The index is new. Initialize the values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nelements</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nelementsSLR</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nelementsILR</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># The atom</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="n">Atom</span><span class="o">.</span><span class="n">from_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># The filters</span>
        <span class="n">filters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filters</span>

        <span class="c1"># Compute the superblocksize, blocksize, slicesize and chunksize values</span>
        <span class="c1"># (in case these parameters haven&#39;t been passed to the constructor)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocksizes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blocksizes</span> <span class="o">=</span> <span class="n">calc_chunksize</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expectedrows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optlevel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span><span class="p">)</span>
        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">superblocksize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span><span class="p">,</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocksizes</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;blocksizes:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocksizes</span><span class="p">)</span>
        <span class="c1"># Compute the reduction level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span> <span class="o">=</span> <span class="n">get_reduction_level</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optlevel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span><span class="p">)</span>
        <span class="n">rchunksize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span>
        <span class="n">rslicesize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span>

        <span class="c1"># Save them on disk as attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">superblocksize</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">superblocksize</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">blocksize</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">slicesize</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">chunksize</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span><span class="p">)</span>
        <span class="c1"># Save the optlevel as well</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">optlevel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optlevel</span>
        <span class="c1"># Save the reduction level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">reduction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span>

        <span class="c1"># Create the IndexArray for sorted values</span>
        <span class="nb">sorted</span> <span class="o">=</span> <span class="n">IndexArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;sorted&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="s2">&quot;Sorted Values&quot;</span><span class="p">,</span>
                            <span class="n">filters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">byteorder</span><span class="p">)</span>

        <span class="c1"># Create the IndexArray for index values</span>
        <span class="n">IndexArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;indices&#39;</span><span class="p">,</span> <span class="n">UIntAtom</span><span class="p">(</span><span class="n">itemsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">indsize</span><span class="p">),</span>
                   <span class="s2">&quot;Number of chunk in table&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">byteorder</span><span class="p">)</span>

        <span class="c1"># Create the cache for range values  (1st order cache)</span>
        <span class="n">CacheArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ranges&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="s2">&quot;Range Values&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">expectedrows</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span><span class="p">,</span>
                   <span class="n">byteorder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">byteorder</span><span class="p">)</span>
        <span class="c1"># median ranges</span>
        <span class="n">EArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;mranges&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="s2">&quot;Median ranges&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span>
               <span class="n">byteorder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">byteorder</span><span class="p">,</span> <span class="n">_log</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Create the cache for boundary values (2nd order cache)</span>
        <span class="n">nbounds_inslice</span> <span class="o">=</span> <span class="p">(</span><span class="n">rslicesize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">rchunksize</span>
        <span class="n">CacheArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;bounds&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nbounds_inslice</span><span class="p">),</span>
                   <span class="s2">&quot;Boundary Values&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchunks</span><span class="p">,</span>
                   <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbounds_inslice</span><span class="p">),</span> <span class="n">byteorder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">byteorder</span><span class="p">)</span>

        <span class="c1"># begin, end &amp; median bounds (only for numerical types)</span>
        <span class="n">EArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;abounds&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="s2">&quot;Start bounds&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span>
               <span class="n">byteorder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">byteorder</span><span class="p">,</span> <span class="n">_log</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">EArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;zbounds&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="s2">&quot;End bounds&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span>
               <span class="n">byteorder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">byteorder</span><span class="p">,</span> <span class="n">_log</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">EArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;mbounds&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="s2">&quot;Median bounds&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span>
               <span class="n">byteorder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">byteorder</span><span class="p">,</span> <span class="n">_log</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Create the Array for last (sorted) row values + bounds</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">rslicesize</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">nbounds_inslice</span><span class="p">,)</span>
        <span class="n">sortedLR</span> <span class="o">=</span> <span class="n">LastRowArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;sortedLR&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span>
                                <span class="s2">&quot;Last Row sorted values + bounds&quot;</span><span class="p">,</span>
                                <span class="n">filters</span><span class="p">,</span> <span class="p">(</span><span class="n">rchunksize</span><span class="p">,),</span>
                                <span class="n">byteorder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">byteorder</span><span class="p">)</span>

        <span class="c1"># Create the Array for the number of chunk in last row</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span><span class="p">,)</span>     <span class="c1"># enough for indexes and length</span>
        <span class="n">indicesLR</span> <span class="o">=</span> <span class="n">LastRowArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;indicesLR&#39;</span><span class="p">,</span>
                                 <span class="n">UIntAtom</span><span class="p">(</span><span class="n">itemsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">indsize</span><span class="p">),</span>
                                 <span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;Last Row indices&quot;</span><span class="p">,</span>
                                 <span class="n">filters</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span><span class="p">,),</span>
                                 <span class="n">byteorder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">byteorder</span><span class="p">)</span>

        <span class="c1"># The number of elements in LR will be initialized here</span>
        <span class="n">sortedLR</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">nelements</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">indicesLR</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">nelements</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># All bounds values (+begin + end) are uninitialized in creation time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bebounds</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># The starts and lengths initialization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">starts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;Where the values fulfiling conditions starts for every slice.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lengths</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;Lengths of the values fulfilling conditions for every slice.&quot;&quot;&quot;</span>

        <span class="c1"># Finally, create a temporary file for indexes if needed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">temp_required</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">create_temp</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">initial_append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xarr</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">reduction</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute an initial indices arrays for data to be indexed.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">tref</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;Entering initial_append&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">xarr</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">indsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span>
        <span class="n">slicesize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span>
        <span class="n">nelementsILR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelementsILR</span>
        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;Before creating idx&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">indsize</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint64&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">nrow</span> <span class="o">*</span> <span class="n">slicesize</span>
        <span class="k">elif</span> <span class="n">indsize</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="c1"># For medium (32-bit) all the rows in tables should be</span>
            <span class="c1"># directly reachable.  But as len(arr) &lt; 2**31, we can</span>
            <span class="c1"># choose uint32 for representing indices.  In this way, we</span>
            <span class="c1"># consume far less memory during the keysort process.  The</span>
            <span class="c1"># offset will be added in self.final_idx32() later on.</span>
            <span class="c1">#</span>
            <span class="c1"># This optimization also prevents the values in LR to</span>
            <span class="c1"># participate in the ``swap_chunks`` process, and this is</span>
            <span class="c1"># the main reason to not allow the medium indexes to create</span>
            <span class="c1"># completely sorted indexes.  However, I don&#39;t find this to</span>
            <span class="c1"># be a big limitation, as probably fully indexes are much</span>
            <span class="c1"># more suitable for producing completely sorted indexes</span>
            <span class="c1"># because in this case the indices part is usable for</span>
            <span class="c1"># getting the reverse indices of the index, and I forsee</span>
            <span class="c1"># this to be a common requirement in many operations (for</span>
            <span class="c1"># example, in table sorts).</span>
            <span class="c1">#</span>
            <span class="c1"># F. Alted 2008-09-15</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint32&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="s2">&quot;uint</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">indsize</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span>
            <span class="n">lbucket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lbucket</span>
            <span class="c1"># Fill the idx with the bucket indices</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lbucket</span> <span class="o">-</span> <span class="p">((</span><span class="n">nrow</span> <span class="o">*</span> <span class="p">(</span><span class="n">slicesize</span> <span class="o">%</span> <span class="n">lbucket</span><span class="p">))</span> <span class="o">%</span> <span class="n">lbucket</span><span class="p">))</span>
            <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">slicesize</span><span class="p">,</span> <span class="n">lbucket</span><span class="p">):</span>
                <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">lbucket</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">lbucket</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">lbucket</span>
            <span class="k">if</span> <span class="n">indsize</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Add a second offset in this case</span>
                <span class="c1"># First normalize the number of rows</span>
                <span class="n">offset2</span> <span class="o">=</span> <span class="p">(</span><span class="n">nrow</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslicesblock</span><span class="p">)</span> <span class="o">*</span> <span class="n">slicesize</span> <span class="o">//</span> <span class="n">lbucket</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="n">offset2</span>
        <span class="c1"># Add the last row at the beginning of arr &amp; idx (if needed)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">indsize</span> <span class="o">==</span> <span class="mi">8</span> <span class="ow">and</span> <span class="n">nelementsILR</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># It is possible that the values in LR are already sorted.</span>
            <span class="c1"># Fetch them and override existing values in arr and idx.</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nelementsILR</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_slice_lr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sortedLR</span><span class="p">,</span> <span class="n">arr</span><span class="p">[:</span><span class="n">nelementsILR</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_slice_lr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indicesLR</span><span class="p">,</span> <span class="n">idx</span><span class="p">[:</span><span class="n">nelementsILR</span><span class="p">])</span>
        <span class="c1"># In-place sorting</span>
        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;Before keysort&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>
        <span class="n">indexesextension</span><span class="o">.</span><span class="n">keysort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="n">larr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">reduction</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># It&#39;s important to do a copy() here in order to ensure that</span>
            <span class="c1"># sorted._append() will receive a contiguous array.</span>
            <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
                <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;Before reduction&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>
            <span class="n">reduc</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[::</span><span class="n">reduction</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
                <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;After reduction&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">reduc</span>
            <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
                <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;After arr &lt;-- reduc&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>
        <span class="c1"># A completely sorted index is not longer possible after an</span>
        <span class="c1"># append of an index with already one slice.</span>
        <span class="k">if</span> <span class="n">nrow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">is_csi</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;Exiting initial_append&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">larr</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">idx</span>

    <span class="k">def</span> <span class="nf">final_idx32</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform final operations in 32-bit indices.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">tref</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;Entering final_idx32&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>
        <span class="c1"># Do an upcast first in order to add the offset.</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint64&#39;</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="n">offset</span>
        <span class="c1"># The next partition is valid up to table sizes of</span>
        <span class="c1"># 2**30 * 2**18 = 2**48 bytes, that is, 256 Tera-elements,</span>
        <span class="c1"># which should be a safe figure, at least for a while.</span>
        <span class="n">idx</span> <span class="o">//=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lbucket</span>
        <span class="c1"># After the division, we can downsize the indexes to &#39;uint32&#39;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint32&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;Exiting final_idx32&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">idx</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xarr</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Append the array to the index objects.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">tref</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;Entering append&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">update</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">temp_required</span><span class="p">:</span>
            <span class="n">where</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp</span>
            <span class="c1"># The reduction will take place *after* the optimization process</span>
            <span class="n">reduction</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">where</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">reduction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span>
        <span class="nb">sorted</span> <span class="o">=</span> <span class="n">where</span><span class="o">.</span><span class="n">sorted</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">where</span><span class="o">.</span><span class="n">indices</span>
        <span class="n">ranges</span> <span class="o">=</span> <span class="n">where</span><span class="o">.</span><span class="n">ranges</span>
        <span class="n">mranges</span> <span class="o">=</span> <span class="n">where</span><span class="o">.</span><span class="n">mranges</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">where</span><span class="o">.</span><span class="n">bounds</span>
        <span class="n">mbounds</span> <span class="o">=</span> <span class="n">where</span><span class="o">.</span><span class="n">mbounds</span>
        <span class="n">abounds</span> <span class="o">=</span> <span class="n">where</span><span class="o">.</span><span class="n">abounds</span>
        <span class="n">zbounds</span> <span class="o">=</span> <span class="n">where</span><span class="o">.</span><span class="n">zbounds</span>
        <span class="n">sortedLR</span> <span class="o">=</span> <span class="n">where</span><span class="o">.</span><span class="n">sortedLR</span>
        <span class="n">indicesLR</span> <span class="o">=</span> <span class="n">where</span><span class="o">.</span><span class="n">indicesLR</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="nb">sorted</span><span class="o">.</span><span class="n">nrows</span>  <span class="c1"># before sorted.append()</span>
        <span class="n">larr</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_append</span><span class="p">(</span><span class="n">xarr</span><span class="p">,</span> <span class="n">nrows</span><span class="p">,</span> <span class="n">reduction</span><span class="p">)</span>
        <span class="c1"># Save the sorted array</span>
        <span class="nb">sorted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span> <span class="o">//</span> <span class="n">reduction</span>
        <span class="n">ncs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchunkslice</span>
        <span class="c1"># Save ranges &amp; bounds</span>
        <span class="n">ranges</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">larr</span><span class="p">]])</span>
        <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">arr</span><span class="p">[</span><span class="n">cs</span><span class="p">::</span><span class="n">cs</span><span class="p">]])</span>
        <span class="n">abounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="n">cs</span><span class="p">])</span>
        <span class="n">zbounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">cs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">::</span><span class="n">cs</span><span class="p">])</span>
        <span class="c1"># Compute the medians</span>
        <span class="n">smedian</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">cs</span> <span class="o">//</span> <span class="mi">2</span><span class="p">::</span><span class="n">cs</span><span class="p">]</span>
        <span class="n">mbounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">smedian</span><span class="p">)</span>
        <span class="n">mranges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">smedian</span><span class="p">[</span><span class="n">ncs</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;Before deleting arr &amp; smedian&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">arr</span><span class="p">,</span> <span class="n">smedian</span>   <span class="c1"># delete references</span>
        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;After deleting arr &amp; smedian&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>
        <span class="c1"># Now that arr is gone, we can upcast the indices and add the offset</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_idx32</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">nrows</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span><span class="p">)</span>
        <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;Before deleting idx&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">idx</span>
        <span class="c1"># Update counters after a successful append</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span> <span class="o">=</span> <span class="n">nrows</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nelements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nelementsSLR</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># reset the counter of the last row index to 0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nelementsILR</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># reset the counter of the last row index to 0</span>
        <span class="c1"># The number of elements will be saved as an attribute.</span>
        <span class="c1"># This is necessary in case the LR arrays can remember its values</span>
        <span class="c1"># after a possible node preemtion/reload.</span>
        <span class="n">sortedLR</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">nelements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelementsSLR</span>
        <span class="n">indicesLR</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">nelements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelementsILR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dirtycache</span> <span class="o">=</span> <span class="kc">True</span>   <span class="c1"># the cache is dirty now</span>
        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;Exiting append&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">append_last_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xarr</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Append the array to the last row index objects.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">tref</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;Entering appendLR&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>
        <span class="c1"># compute the elements in the last row sorted &amp; bounds array</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslices</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">update</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">temp_required</span><span class="p">:</span>
            <span class="n">where</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp</span>
            <span class="c1"># The reduction will take place *after* the optimization process</span>
            <span class="n">reduction</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">where</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">reduction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span>
        <span class="n">indicesLR</span> <span class="o">=</span> <span class="n">where</span><span class="o">.</span><span class="n">indicesLR</span>
        <span class="n">sortedLR</span> <span class="o">=</span> <span class="n">where</span><span class="o">.</span><span class="n">sortedLR</span>
        <span class="n">larr</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_append</span><span class="p">(</span><span class="n">xarr</span><span class="p">,</span> <span class="n">nrows</span><span class="p">,</span> <span class="n">reduction</span><span class="p">)</span>
        <span class="n">nelementsSLR</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="n">nelementsILR</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="c1"># Build the cache of bounds</span>
        <span class="n">rchunksize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span> <span class="o">//</span> <span class="n">reduction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bebounds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">arr</span><span class="p">[::</span><span class="n">rchunksize</span><span class="p">],</span> <span class="p">[</span><span class="n">larr</span><span class="p">]))</span>
        <span class="c1"># The number of elements will be saved as an attribute</span>
        <span class="n">sortedLR</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">nelements</span> <span class="o">=</span> <span class="n">nelementsSLR</span>
        <span class="n">indicesLR</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">nelements</span> <span class="o">=</span> <span class="n">nelementsILR</span>
        <span class="c1"># Save the number of elements, bounds and sorted values</span>
        <span class="c1"># at the end of the sorted array</span>
        <span class="n">offset2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bebounds</span><span class="p">)</span>
        <span class="n">sortedLR</span><span class="p">[</span><span class="n">nelementsSLR</span><span class="p">:</span><span class="n">nelementsSLR</span> <span class="o">+</span> <span class="n">offset2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bebounds</span>
        <span class="n">sortedLR</span><span class="p">[:</span><span class="n">nelementsSLR</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span>
        <span class="k">del</span> <span class="n">arr</span>
        <span class="c1"># Now that arr is gone, we can upcast the indices and add the offset</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_idx32</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">nrows</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span><span class="p">)</span>
        <span class="c1"># Save the reverse index array</span>
        <span class="n">indicesLR</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="k">del</span> <span class="n">idx</span>
        <span class="c1"># Update counters after a successful append</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span> <span class="o">=</span> <span class="n">nrows</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nelements</span> <span class="o">=</span> <span class="n">nrows</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span> <span class="o">+</span> <span class="n">nelementsILR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nelementsILR</span> <span class="o">=</span> <span class="n">nelementsILR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nelementsSLR</span> <span class="o">=</span> <span class="n">nelementsSLR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dirtycache</span> <span class="o">=</span> <span class="kc">True</span>   <span class="c1"># the cache is dirty now</span>
        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;Exiting appendLR&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optimize an index so as to allow faster searches.</span>

<span class="sd">        verbose</span>
<span class="sd">            If True, messages about the progress of the</span>
<span class="sd">            optimization process are printed out.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">temp_required</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">debug</span>

        <span class="c1"># Initialize last_tover and last_nover</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_tover</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_nover</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Compute the correct optimizations for current optim level</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="n">calcoptlevels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nblocks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optlevel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span><span class="p">)</span>
        <span class="n">optmedian</span><span class="p">,</span> <span class="n">optstarts</span><span class="p">,</span> <span class="n">optstops</span><span class="p">,</span> <span class="n">optfull</span> <span class="o">=</span> <span class="n">opts</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;optvalues:&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">create_temp2</span><span class="p">()</span>
        <span class="c1"># Start the optimization process</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">optfull</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">niter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">optfull</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="s1">&#39;chunks&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">):</span>
                        <span class="k">break</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nblocks</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># Swap slices only in the case that we have</span>
                        <span class="c1"># several blocks</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="s1">&#39;slices&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">):</span>
                            <span class="k">break</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="s1">&#39;chunks&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">):</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="s1">&#39;chunks&#39;</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">):</span>
                        <span class="k">break</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="s1">&#39;chunks&#39;</span><span class="p">,</span> <span class="s1">&#39;stop&#39;</span><span class="p">):</span>
                        <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">optmedian</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="s1">&#39;chunks&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">):</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">optstarts</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="s1">&#39;chunks&#39;</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">):</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">optstops</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="s1">&#39;chunks&#39;</span><span class="p">,</span> <span class="s1">&#39;stop&#39;</span><span class="p">):</span>
                        <span class="k">break</span>
            <span class="k">break</span>  <span class="c1"># If we reach this, exit the loop</span>

        <span class="c1"># Check if we require a complete sort.  Important: this step</span>
        <span class="c1"># should be carried out *after* the optimization process has</span>
        <span class="c1"># been completed (this is to guarantee that the complete sort</span>
        <span class="c1"># does not take too much memory).</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">want_complete_sort</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noverlaps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">do_complete_sort</span><span class="p">()</span>
            <span class="c1"># Check that we have effectively achieved the complete sort</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noverlaps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;OPSI was not able to achieve a completely sorted index.&quot;</span>
                    <span class="s2">&quot;  Please report this to the authors.&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>

        <span class="c1"># Close and delete the temporal optimization index file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cleanup_temp</span><span class="p">()</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">do_complete_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Bring an already optimized index into a complete sorted state.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">perf_counter</span><span class="p">()</span>
        <span class="n">ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp</span>
        <span class="n">ranges</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">ranges</span><span class="p">[:]</span>
        <span class="n">nslices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslices</span>

        <span class="n">nelementsLR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelementsILR</span>
        <span class="k">if</span> <span class="n">nelementsLR</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Add the ranges corresponding to the last row</span>
            <span class="n">rangeslr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">bebounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">bebounds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">ranges</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ranges</span><span class="p">,</span> <span class="p">[</span><span class="n">rangeslr</span><span class="p">]))</span>
            <span class="n">nslices</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="nb">sorted</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">sorted</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">indices</span>
        <span class="n">sortedLR</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">sortedLR</span>
        <span class="n">indicesLR</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">indicesLR</span>
        <span class="n">sremain</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">iremain</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;u</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span><span class="p">)</span>
        <span class="n">starts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">nslices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int_</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nslices</span><span class="p">):</span>
            <span class="c1"># Find the overlapping elements for slice i</span>
            <span class="n">sover</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">iover</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;u</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span><span class="p">)</span>
            <span class="n">prev_end</span> <span class="o">=</span> <span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nslices</span><span class="p">):</span>
                <span class="n">stj</span> <span class="o">=</span> <span class="n">starts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">j</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslices</span> <span class="ow">and</span> <span class="n">stj</span> <span class="o">==</span> <span class="n">ss</span><span class="p">)</span> <span class="ow">or</span>
                        <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslices</span> <span class="ow">and</span> <span class="n">stj</span> <span class="o">==</span> <span class="n">nelementsLR</span><span class="p">)):</span>
                    <span class="c1"># This slice has been already dealt with</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslices</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">stj</span> <span class="o">&lt;</span> <span class="n">ss</span><span class="p">,</span> \
                        <span class="s2">&quot;Two slices cannot overlap completely at this stage!&quot;</span>
                    <span class="n">next_beg</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">stj</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">stj</span> <span class="o">&lt;</span> <span class="n">nelementsLR</span><span class="p">,</span> \
                        <span class="s2">&quot;Two slices cannot overlap completely at this stage!&quot;</span>
                    <span class="n">next_beg</span> <span class="o">=</span> <span class="n">sortedLR</span><span class="p">[</span><span class="n">stj</span><span class="p">]</span>
                <span class="n">next_end</span> <span class="o">=</span> <span class="n">ranges</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">prev_end</span> <span class="o">&gt;</span> <span class="n">next_end</span><span class="p">:</span>
                    <span class="c1"># Complete overlapping case</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslices</span><span class="p">:</span>
                        <span class="n">sover</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sover</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">stj</span><span class="p">:]))</span>
                        <span class="n">iover</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">iover</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">stj</span><span class="p">:]))</span>
                        <span class="n">starts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ss</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="n">nelementsLR</span>
                        <span class="n">sover</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sover</span><span class="p">,</span> <span class="n">sortedLR</span><span class="p">[</span><span class="n">stj</span><span class="p">:</span><span class="n">n</span><span class="p">]))</span>
                        <span class="n">iover</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">iover</span><span class="p">,</span> <span class="n">indicesLR</span><span class="p">[</span><span class="n">stj</span><span class="p">:</span><span class="n">n</span><span class="p">]))</span>
                        <span class="n">starts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nelementsLR</span>
                <span class="k">elif</span> <span class="n">prev_end</span> <span class="o">&gt;</span> <span class="n">next_beg</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_item_lt</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">prev_end</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ranges</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">stj</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslices</span><span class="p">:</span>
                        <span class="n">sover</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sover</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">stj</span><span class="p">:</span><span class="n">idx</span><span class="p">]))</span>
                        <span class="n">iover</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">iover</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">stj</span><span class="p">:</span><span class="n">idx</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sover</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sover</span><span class="p">,</span> <span class="n">sortedLR</span><span class="p">[</span><span class="n">stj</span><span class="p">:</span><span class="n">idx</span><span class="p">]))</span>
                        <span class="n">iover</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">iover</span><span class="p">,</span> <span class="n">indicesLR</span><span class="p">[</span><span class="n">stj</span><span class="p">:</span><span class="n">idx</span><span class="p">]))</span>
                    <span class="n">starts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="c1"># Build the extended slices to sort out</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslices</span><span class="p">:</span>
                <span class="n">ssorted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">sremain</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">]:],</span> <span class="n">sover</span><span class="p">))</span>
                <span class="n">sindices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">iremain</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">]:],</span> <span class="n">iover</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ssorted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">sremain</span><span class="p">,</span> <span class="n">sortedLR</span><span class="p">[</span><span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">nelementsLR</span><span class="p">],</span> <span class="n">sover</span><span class="p">))</span>
                <span class="n">sindices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">iremain</span><span class="p">,</span> <span class="n">indicesLR</span><span class="p">[</span><span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">nelementsLR</span><span class="p">],</span> <span class="n">iover</span><span class="p">))</span>
            <span class="c1"># Sort the extended slices</span>
            <span class="n">indexesextension</span><span class="o">.</span><span class="n">keysort</span><span class="p">(</span><span class="n">ssorted</span><span class="p">,</span> <span class="n">sindices</span><span class="p">)</span>
            <span class="c1"># Save the first elements of extended slices in the slice i</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslices</span><span class="p">:</span>
                <span class="nb">sorted</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssorted</span><span class="p">[:</span><span class="n">ss</span><span class="p">]</span>
                <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sindices</span><span class="p">[:</span><span class="n">ss</span><span class="p">]</span>
                <span class="c1"># Update caches for this slice</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_caches</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ssorted</span><span class="p">[:</span><span class="n">ss</span><span class="p">])</span>
                <span class="c1"># Save the remaining values in a separate array</span>
                <span class="n">send</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sover</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">sremain</span><span class="p">)</span>
                <span class="n">sremain</span> <span class="o">=</span> <span class="n">ssorted</span><span class="p">[</span><span class="n">ss</span><span class="p">:</span><span class="n">ss</span> <span class="o">+</span> <span class="n">send</span><span class="p">]</span>
                <span class="n">iremain</span> <span class="o">=</span> <span class="n">sindices</span><span class="p">[</span><span class="n">ss</span><span class="p">:</span><span class="n">ss</span> <span class="o">+</span> <span class="n">send</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Still some elements remain for the last row</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ssorted</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">n</span> <span class="o">==</span> <span class="n">nelementsLR</span>
                <span class="n">send</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">sortedLR</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssorted</span>
                <span class="n">indicesLR</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">sindices</span>
                <span class="c1"># Update the caches for last row</span>
                <span class="n">sortedlr</span> <span class="o">=</span> <span class="n">sortedLR</span><span class="p">[:</span><span class="n">nelementsLR</span><span class="p">]</span>
                <span class="n">bebounds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">sortedlr</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span><span class="p">],</span> <span class="p">[</span><span class="n">sortedlr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>
                <span class="n">sortedLR</span><span class="p">[</span><span class="n">nelementsLR</span><span class="p">:</span><span class="n">nelementsLR</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">bebounds</span><span class="p">)]</span> <span class="o">=</span> <span class="n">bebounds</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bebounds</span> <span class="o">=</span> <span class="n">bebounds</span>

        <span class="c1"># Verify that we have dealt with all the remaining values</span>
        <span class="k">assert</span> <span class="n">send</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="c1"># Compute the overlaps in order to verify that we have achieved</span>
        <span class="c1"># a complete sort.  This has to be executed always (and not only</span>
        <span class="c1"># in verbose mode!).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_overlaps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tmp</span><span class="p">,</span> <span class="s2">&quot;do_complete_sort()&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">c1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;time: </span><span class="si">{}</span><span class="s2">. clock: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Swap chunks or slices using a certain bounds reference.&quot;&quot;&quot;</span>

        <span class="c1"># Thresholds for avoiding continuing the optimization</span>
        <span class="c1"># thnover = 4 * self.slicesize  # minimum number of overlapping</span>
        <span class="c1">#                               # elements</span>
        <span class="n">thnover</span> <span class="o">=</span> <span class="mi">40</span>
        <span class="n">thmult</span> <span class="o">=</span> <span class="mf">0.1</span>      <span class="c1"># minimum ratio of multiplicity (a 10%)</span>
        <span class="n">thtover</span> <span class="o">=</span> <span class="mf">0.01</span>    <span class="c1"># minimum overlaping index for slices (a 1%)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">perf_counter</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">what</span> <span class="o">==</span> <span class="s2">&quot;chunks&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">swap_chunks</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">what</span> <span class="o">==</span> <span class="s2">&quot;slices&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">swap_slices</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;swap_</span><span class="si">{}</span><span class="s2">(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">what</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;swap_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">what</span><span class="p">)</span>
        <span class="p">(</span><span class="n">nover</span><span class="p">,</span> <span class="n">mult</span><span class="p">,</span> <span class="n">tover</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_overlaps</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">rmult</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mult</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mult</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">c1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;time: </span><span class="si">{}</span><span class="s2">. clock: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
        <span class="c1"># Check that entropy is actually decreasing</span>
        <span class="k">if</span> <span class="n">what</span> <span class="o">==</span> <span class="s2">&quot;chunks&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_tover</span> <span class="o">&gt;</span> <span class="mf">0.</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_nover</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tover_var</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_tover</span> <span class="o">-</span> <span class="n">tover</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_tover</span>
            <span class="n">nover_var</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_nover</span> <span class="o">-</span> <span class="n">nover</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_nover</span>
            <span class="k">if</span> <span class="n">tover_var</span> <span class="o">&lt;</span> <span class="mf">0.05</span> <span class="ow">and</span> <span class="n">nover_var</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">:</span>
                <span class="c1"># Less than a 5% of improvement is too few</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_tover</span> <span class="o">=</span> <span class="n">tover</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_nover</span> <span class="o">=</span> <span class="n">nover</span>
        <span class="c1"># Check if some threshold has met</span>
        <span class="k">if</span> <span class="n">nover</span> <span class="o">&lt;</span> <span class="n">thnover</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">rmult</span> <span class="o">&lt;</span> <span class="n">thmult</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="c1"># Additional check for the overlap ratio</span>
        <span class="k">if</span> <span class="mf">0.</span> <span class="o">&lt;=</span> <span class="n">tover</span> <span class="o">&lt;</span> <span class="n">thtover</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">create_temp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create some temporary objects for slice sorting purposes.&quot;&quot;&quot;</span>

        <span class="c1"># The index will be dirty during the index optimization process</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dirty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># Build the name of the temporary file</span>
        <span class="n">fd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmpfilename</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">(</span>
            <span class="s2">&quot;.tmp&quot;</span><span class="p">,</span> <span class="s2">&quot;pytables-&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp_dir</span><span class="p">)</span>
        <span class="c1"># Close the file descriptor so as to avoid leaks</span>
        <span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
        <span class="c1"># Create the proper PyTables file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmpfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_openFile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tmpfilename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmpfile</span><span class="o">.</span><span class="n">root</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span>
        <span class="n">ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span>
        <span class="n">filters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filters</span>
        <span class="c1"># temporary sorted &amp; indices arrays</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="n">Atom</span><span class="o">.</span><span class="n">from_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">EArray</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s1">&#39;sorted&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span>
               <span class="s2">&quot;Temporary sorted&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">chunkshape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cs</span><span class="p">))</span>
        <span class="n">EArray</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s1">&#39;indices&#39;</span><span class="p">,</span> <span class="n">UIntAtom</span><span class="p">(</span><span class="n">itemsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">indsize</span><span class="p">),</span> <span class="n">shape</span><span class="p">,</span>
               <span class="s2">&quot;Temporary indices&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">chunkshape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cs</span><span class="p">))</span>
        <span class="c1"># temporary bounds</span>
        <span class="n">nbounds_inslice</span> <span class="o">=</span> <span class="p">(</span><span class="n">ss</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">cs</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nbounds_inslice</span><span class="p">)</span>
        <span class="n">EArray</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s1">&#39;bounds&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;Temp chunk bounds&quot;</span><span class="p">,</span>
               <span class="n">filters</span><span class="p">,</span> <span class="n">chunkshape</span><span class="o">=</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">nbounds_inslice</span><span class="p">))</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
        <span class="n">EArray</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s1">&#39;abounds&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;Temp start bounds&quot;</span><span class="p">,</span>
               <span class="n">filters</span><span class="p">,</span> <span class="n">chunkshape</span><span class="o">=</span><span class="p">(</span><span class="n">cs</span><span class="p">,))</span>
        <span class="n">EArray</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s1">&#39;zbounds&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;Temp end bounds&quot;</span><span class="p">,</span>
               <span class="n">filters</span><span class="p">,</span> <span class="n">chunkshape</span><span class="o">=</span><span class="p">(</span><span class="n">cs</span><span class="p">,))</span>
        <span class="n">EArray</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s1">&#39;mbounds&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;Median bounds&quot;</span><span class="p">,</span>
               <span class="n">filters</span><span class="p">,</span> <span class="n">chunkshape</span><span class="o">=</span><span class="p">(</span><span class="n">cs</span><span class="p">,))</span>
        <span class="c1"># temporary ranges</span>
        <span class="n">EArray</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s1">&#39;ranges&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
               <span class="s2">&quot;Temporary range values&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">chunkshape</span><span class="o">=</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">EArray</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s1">&#39;mranges&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
               <span class="s2">&quot;Median ranges&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">chunkshape</span><span class="o">=</span><span class="p">(</span><span class="n">cs</span><span class="p">,))</span>
        <span class="c1"># temporary last row (sorted)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">ss</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">nbounds_inslice</span><span class="p">,)</span>
        <span class="n">CArray</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s1">&#39;sortedLR&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span>
               <span class="s2">&quot;Temp Last Row sorted values + bounds&quot;</span><span class="p">,</span>
               <span class="n">filters</span><span class="p">,</span> <span class="n">chunkshape</span><span class="o">=</span><span class="p">(</span><span class="n">cs</span><span class="p">,))</span>
        <span class="c1"># temporary last row (indices)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">ss</span><span class="p">,)</span>
        <span class="n">CArray</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s1">&#39;indicesLR&#39;</span><span class="p">,</span>
               <span class="n">UIntAtom</span><span class="p">(</span><span class="n">itemsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">indsize</span><span class="p">),</span>
               <span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;Temp Last Row indices&quot;</span><span class="p">,</span>
               <span class="n">filters</span><span class="p">,</span> <span class="n">chunkshape</span><span class="o">=</span><span class="p">(</span><span class="n">cs</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">create_temp2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create some temporary objects for slice sorting purposes.&quot;&quot;&quot;</span>

        <span class="c1"># The algorithms for doing the swap can be optimized so that</span>
        <span class="c1"># one should be necessary to create temporaries for keeping just</span>
        <span class="c1"># the contents of a single superblock.</span>
        <span class="c1"># F. Alted 2007-01-03</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span>
        <span class="n">ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span>
        <span class="n">filters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filters</span>
        <span class="c1"># temporary sorted &amp; indices arrays</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nslices</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="n">Atom</span><span class="o">.</span><span class="n">from_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp</span>
        <span class="n">CArray</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s1">&#39;sorted2&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span>
               <span class="s2">&quot;Temporary sorted 2&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">chunkshape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cs</span><span class="p">))</span>
        <span class="n">CArray</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s1">&#39;indices2&#39;</span><span class="p">,</span> <span class="n">UIntAtom</span><span class="p">(</span><span class="n">itemsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">indsize</span><span class="p">),</span> <span class="n">shape</span><span class="p">,</span>
               <span class="s2">&quot;Temporary indices 2&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">chunkshape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cs</span><span class="p">))</span>
        <span class="c1"># temporary bounds</span>
        <span class="n">nbounds_inslice</span> <span class="o">=</span> <span class="p">(</span><span class="n">ss</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">cs</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nslices</span><span class="p">,</span> <span class="n">nbounds_inslice</span><span class="p">)</span>
        <span class="n">CArray</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s1">&#39;bounds2&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;Temp chunk bounds 2&quot;</span><span class="p">,</span>
               <span class="n">filters</span><span class="p">,</span> <span class="n">chunkshape</span><span class="o">=</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">nbounds_inslice</span><span class="p">))</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchunks</span><span class="p">,)</span>
        <span class="n">CArray</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s1">&#39;abounds2&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;Temp start bounds 2&quot;</span><span class="p">,</span>
               <span class="n">filters</span><span class="p">,</span> <span class="n">chunkshape</span><span class="o">=</span><span class="p">(</span><span class="n">cs</span><span class="p">,))</span>
        <span class="n">CArray</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s1">&#39;zbounds2&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;Temp end bounds 2&quot;</span><span class="p">,</span>
               <span class="n">filters</span><span class="p">,</span> <span class="n">chunkshape</span><span class="o">=</span><span class="p">(</span><span class="n">cs</span><span class="p">,))</span>
        <span class="n">CArray</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s1">&#39;mbounds2&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;Median bounds 2&quot;</span><span class="p">,</span>
               <span class="n">filters</span><span class="p">,</span> <span class="n">chunkshape</span><span class="o">=</span><span class="p">(</span><span class="n">cs</span><span class="p">,))</span>
        <span class="c1"># temporary ranges</span>
        <span class="n">CArray</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s1">&#39;ranges2&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nslices</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
               <span class="s2">&quot;Temporary range values 2&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">chunkshape</span><span class="o">=</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">CArray</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s1">&#39;mranges2&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nslices</span><span class="p">,),</span>
               <span class="s2">&quot;Median ranges 2&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">chunkshape</span><span class="o">=</span><span class="p">(</span><span class="n">cs</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">cleanup_temp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy the data and delete the temporaries for sorting purposes.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Copying temporary data...&quot;</span><span class="p">)</span>
        <span class="c1"># tmp -&gt; index</span>
        <span class="n">reduction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span> <span class="o">//</span> <span class="n">reduction</span>
        <span class="n">ncs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchunkslice</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nslices</span><span class="p">):</span>
            <span class="c1"># Copy sorted &amp; indices slices</span>
            <span class="nb">sorted</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">sorted</span><span class="p">[</span><span class="n">i</span><span class="p">][::</span><span class="n">reduction</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sorted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sorted</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
            <span class="c1"># Compute ranges</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="nb">sorted</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">sorted</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]])</span>
            <span class="c1"># Compute chunk bounds</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">sorted</span><span class="p">[</span><span class="n">cs</span><span class="p">::</span><span class="n">cs</span><span class="p">]])</span>
            <span class="c1"># Compute start, stop &amp; median bounds and ranges</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">abounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sorted</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="n">cs</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zbounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sorted</span><span class="p">[</span><span class="n">cs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">::</span><span class="n">cs</span><span class="p">])</span>
            <span class="n">smedian</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">[</span><span class="n">cs</span> <span class="o">//</span> <span class="mi">2</span><span class="p">::</span><span class="n">cs</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mbounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">smedian</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mranges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">smedian</span><span class="p">[</span><span class="n">ncs</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]])</span>
            <span class="k">del</span> <span class="nb">sorted</span><span class="p">,</span> <span class="n">smedian</span>   <span class="c1"># delete references</span>
            <span class="c1"># Now that sorted is gone, we can copy the indices</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>

        <span class="c1"># Now it is the last row turn (if needed)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelementsSLR</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># First, the sorted values</span>
            <span class="n">sortedLR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sortedLR</span>
            <span class="n">indicesLR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicesLR</span>
            <span class="n">nelementsLR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelementsILR</span>
            <span class="n">sortedlr</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">sortedLR</span><span class="p">[:</span><span class="n">nelementsLR</span><span class="p">][::</span><span class="n">reduction</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">nelementsSLR</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sortedlr</span><span class="p">)</span>
            <span class="n">sortedLR</span><span class="p">[:</span><span class="n">nelementsSLR</span><span class="p">]</span> <span class="o">=</span> <span class="n">sortedlr</span>
            <span class="c1"># Now, the bounds</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bebounds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sortedlr</span><span class="p">[::</span><span class="n">cs</span><span class="p">],</span> <span class="p">[</span><span class="n">sortedlr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>
            <span class="n">offset2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bebounds</span><span class="p">)</span>
            <span class="n">sortedLR</span><span class="p">[</span><span class="n">nelementsSLR</span><span class="p">:</span><span class="n">nelementsSLR</span> <span class="o">+</span> <span class="n">offset2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bebounds</span>
            <span class="c1"># Finally, the indices</span>
            <span class="n">indicesLR</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">indicesLR</span><span class="p">[:]</span>
            <span class="c1"># Update the number of (reduced) sorted elements</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nelementsSLR</span> <span class="o">=</span> <span class="n">nelementsSLR</span>
        <span class="c1"># The number of elements will be saved as an attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sortedLR</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">nelements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelementsSLR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indicesLR</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">nelements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelementsILR</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deleting temporaries...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmpfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tmpfilename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmpfilename</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># The optimization process has finished, and the index is ok now</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dirty</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># ...but the memory data cache is dirty now</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dirtycache</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">get_neworder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">neworder</span><span class="p">,</span> <span class="n">src_disk</span><span class="p">,</span> <span class="n">tmp_disk</span><span class="p">,</span>
                     <span class="n">lastrow</span><span class="p">,</span> <span class="n">nslices</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get sorted &amp; indices values in new order.&quot;&quot;&quot;</span>

        <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span>
        <span class="n">ncs</span> <span class="o">=</span> <span class="n">ncs2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchunkslice</span>
        <span class="n">self_nslices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslices</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nslices</span><span class="p">):</span>
            <span class="n">ns</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">ns</span> <span class="o">==</span> <span class="n">self_nslices</span><span class="p">:</span>
                <span class="c1"># The number of complete chunks in the last row</span>
                <span class="n">ncs2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelementsILR</span> <span class="o">//</span> <span class="n">cs</span>
            <span class="c1"># Get slices in new order</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncs2</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">neworder</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">ncs</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span>
                <span class="n">ins</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">//</span> <span class="n">ncs</span>
                <span class="n">inc</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span> <span class="o">-</span> <span class="n">ins</span> <span class="o">*</span> <span class="n">ncs</span><span class="p">)</span> <span class="o">*</span> <span class="n">cs</span>
                <span class="n">ins</span> <span class="o">+=</span> <span class="n">offset</span>
                <span class="n">nc</span> <span class="o">=</span> <span class="n">j</span> <span class="o">*</span> <span class="n">cs</span>
                <span class="k">if</span> <span class="n">ins</span> <span class="o">==</span> <span class="n">self_nslices</span><span class="p">:</span>
                    <span class="n">tmp</span><span class="p">[</span><span class="n">nc</span><span class="p">:</span><span class="n">nc</span> <span class="o">+</span> <span class="n">cs</span><span class="p">]</span> <span class="o">=</span> <span class="n">lastrow</span><span class="p">[</span><span class="n">inc</span><span class="p">:</span><span class="n">inc</span> <span class="o">+</span> <span class="n">cs</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tmp</span><span class="p">[</span><span class="n">nc</span><span class="p">:</span><span class="n">nc</span> <span class="o">+</span> <span class="n">cs</span><span class="p">]</span> <span class="o">=</span> <span class="n">src_disk</span><span class="p">[</span><span class="n">ins</span><span class="p">,</span> <span class="n">inc</span><span class="p">:</span><span class="n">inc</span> <span class="o">+</span> <span class="n">cs</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ns</span> <span class="o">==</span> <span class="n">self_nslices</span><span class="p">:</span>
                <span class="c1"># The number of complete chunks in the last row</span>
                <span class="n">lastrow</span><span class="p">[:</span><span class="n">ncs2</span> <span class="o">*</span> <span class="n">cs</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[:</span><span class="n">ncs2</span> <span class="o">*</span> <span class="n">cs</span><span class="p">]</span>
                <span class="c1"># The elements in the last chunk of the last row will</span>
                <span class="c1"># participate in the global reordering later on, during</span>
                <span class="c1"># the phase of sorting of *two* slices at a time</span>
                <span class="c1"># (including the last row slice, see</span>
                <span class="c1"># self.reorder_slices()).  The caches for last row will</span>
                <span class="c1"># be updated in self.reorder_slices() too.</span>
                <span class="c1"># F. Altet 2008-08-25</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmp_disk</span><span class="p">[</span><span class="n">ns</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>

    <span class="k">def</span> <span class="nf">swap_chunks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Swap &amp; reorder the different chunks in a block.&quot;&quot;&quot;</span>

        <span class="n">boundsnames</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;start&#39;</span><span class="p">:</span> <span class="s1">&#39;abounds&#39;</span><span class="p">,</span> <span class="s1">&#39;stop&#39;</span><span class="p">:</span> <span class="s1">&#39;zbounds&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span> <span class="s1">&#39;mbounds&#39;</span><span class="p">}</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp</span>
        <span class="nb">sorted</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">sorted</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">indices</span>
        <span class="n">tmp_sorted</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">sorted2</span>
        <span class="n">tmp_indices</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">indices2</span>
        <span class="n">sortedLR</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">sortedLR</span>
        <span class="n">indicesLR</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">indicesLR</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span>
        <span class="n">ncs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchunkslice</span>
        <span class="n">nsb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslicesblock</span>
        <span class="n">ncb</span> <span class="o">=</span> <span class="n">ncs</span> <span class="o">*</span> <span class="n">nsb</span>
        <span class="n">ncb2</span> <span class="o">=</span> <span class="n">ncb</span>
        <span class="n">boundsobj</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_f_get_child</span><span class="p">(</span><span class="n">boundsnames</span><span class="p">[</span><span class="n">mode</span><span class="p">])</span>
        <span class="n">can_cross_bbounds</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indsize</span> <span class="o">==</span> <span class="mi">8</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelementsILR</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nblock</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nblocks</span><span class="p">):</span>
            <span class="c1"># Protection for last block having less chunks than ncb</span>
            <span class="n">remainingchunks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchunks</span> <span class="o">-</span> <span class="n">nblock</span> <span class="o">*</span> <span class="n">ncb</span>
            <span class="k">if</span> <span class="n">remainingchunks</span> <span class="o">&lt;</span> <span class="n">ncb</span><span class="p">:</span>
                <span class="n">ncb2</span> <span class="o">=</span> <span class="n">remainingchunks</span>
            <span class="k">if</span> <span class="n">ncb2</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># if only zero or one chunks remains we are done</span>
                <span class="k">break</span>
            <span class="n">nslices</span> <span class="o">=</span> <span class="n">ncb2</span> <span class="o">//</span> <span class="n">ncs</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">boundsobj</span><span class="p">[</span><span class="n">nblock</span> <span class="o">*</span> <span class="n">ncb</span><span class="p">:</span><span class="n">nblock</span> <span class="o">*</span> <span class="n">ncb</span> <span class="o">+</span> <span class="n">ncb2</span><span class="p">]</span>
            <span class="c1"># Do this only if lastrow elements can cross block boundaries</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nblock</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nblocks</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span>  <span class="c1"># last block</span>
                    <span class="n">can_cross_bbounds</span><span class="p">):</span>
                <span class="n">nslices</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">ul</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelementsILR</span> <span class="o">//</span> <span class="n">cs</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bebounds</span><span class="p">[:</span><span class="n">ul</span><span class="p">]))</span>
            <span class="n">sbounds_idx</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">defsort</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nblock</span> <span class="o">*</span> <span class="n">nsb</span><span class="p">)</span>
            <span class="c1"># Swap sorted and indices following the new order</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_neworder</span><span class="p">(</span><span class="n">sbounds_idx</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">,</span> <span class="n">tmp_sorted</span><span class="p">,</span> <span class="n">sortedLR</span><span class="p">,</span>
                              <span class="n">nslices</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_neworder</span><span class="p">(</span><span class="n">sbounds_idx</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">tmp_indices</span><span class="p">,</span> <span class="n">indicesLR</span><span class="p">,</span>
                              <span class="n">nslices</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="s1">&#39;u</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span><span class="p">)</span>
        <span class="c1"># Reorder completely the index at slice level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reorder_slices</span><span class="p">(</span><span class="n">tmp</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">nslice</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a slice from the `where` dataset and put it in `buffer`.&quot;&quot;&quot;</span>

        <span class="c1"># Create the buffers for specifying the coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">startl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nslice</span><span class="p">,</span> <span class="n">start</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stopl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nslice</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">buffer</span><span class="o">.</span><span class="n">size</span><span class="p">],</span>
                                 <span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stepl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
        <span class="n">where</span><span class="o">.</span><span class="n">_g_read_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">startl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stopl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stepl</span><span class="p">,</span> <span class="n">buffer</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">nslice</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write a `slice` to the `where` dataset with the `buffer` data.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">startl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nslice</span><span class="p">,</span> <span class="n">start</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stopl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nslice</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">buffer</span><span class="o">.</span><span class="n">size</span><span class="p">],</span>
                                 <span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stepl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
        <span class="n">countl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stopl</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">startl</span>   <span class="c1"># (1, self.slicesize)</span>
        <span class="n">where</span><span class="o">.</span><span class="n">_g_write_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">startl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stepl</span><span class="p">,</span> <span class="n">countl</span><span class="p">,</span> <span class="n">buffer</span><span class="p">)</span>

    <span class="c1"># Read version for LastRow</span>
    <span class="k">def</span> <span class="nf">read_slice_lr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a slice from the `where` dataset and put it in `buffer`.&quot;&quot;&quot;</span>

        <span class="n">startl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">start</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
        <span class="n">stopl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">start</span> <span class="o">+</span> <span class="n">buffer</span><span class="o">.</span><span class="n">size</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
        <span class="n">stepl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
        <span class="n">where</span><span class="o">.</span><span class="n">_g_read_slice</span><span class="p">(</span><span class="n">startl</span><span class="p">,</span> <span class="n">stopl</span><span class="p">,</span> <span class="n">stepl</span><span class="p">,</span> <span class="n">buffer</span><span class="p">)</span>

    <span class="c1"># Write version for LastRow</span>
    <span class="k">def</span> <span class="nf">write_sliceLR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write a slice from the `where` dataset with the `buffer` data.&quot;&quot;&quot;</span>

        <span class="n">startl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">start</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
        <span class="n">countl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">start</span> <span class="o">+</span> <span class="n">buffer</span><span class="o">.</span><span class="n">size</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
        <span class="n">stepl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
        <span class="n">where</span><span class="o">.</span><span class="n">_g_write_slice</span><span class="p">(</span><span class="n">startl</span><span class="p">,</span> <span class="n">stepl</span><span class="p">,</span> <span class="n">countl</span><span class="p">,</span> <span class="n">buffer</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">reorder_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nslice</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">ssorted</span><span class="p">,</span> <span class="n">sindices</span><span class="p">,</span>
                      <span class="n">tmp_sorted</span><span class="p">,</span> <span class="n">tmp_indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy &amp; reorder the slice in source to final destination.&quot;&quot;&quot;</span>

        <span class="n">ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span>
        <span class="c1"># Load the second part in buffers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_slice</span><span class="p">(</span><span class="n">tmp_sorted</span><span class="p">,</span> <span class="n">nslice</span><span class="p">,</span> <span class="n">ssorted</span><span class="p">[</span><span class="n">ss</span><span class="p">:])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_slice</span><span class="p">(</span><span class="n">tmp_indices</span><span class="p">,</span> <span class="n">nslice</span><span class="p">,</span> <span class="n">sindices</span><span class="p">[</span><span class="n">ss</span><span class="p">:])</span>
        <span class="n">indexesextension</span><span class="o">.</span><span class="n">keysort</span><span class="p">(</span><span class="n">ssorted</span><span class="p">,</span> <span class="n">sindices</span><span class="p">)</span>
        <span class="c1"># Write the first part of the buffers to the regular leaves</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_slice</span><span class="p">(</span><span class="nb">sorted</span><span class="p">,</span> <span class="n">nslice</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ssorted</span><span class="p">[:</span><span class="n">ss</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_slice</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">nslice</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sindices</span><span class="p">[:</span><span class="n">ss</span><span class="p">])</span>
        <span class="c1"># Update caches</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_caches</span><span class="p">(</span><span class="n">nslice</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ssorted</span><span class="p">[:</span><span class="n">ss</span><span class="p">])</span>
        <span class="c1"># Shift the slice in the end to the beginning</span>
        <span class="n">ssorted</span><span class="p">[:</span><span class="n">ss</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssorted</span><span class="p">[</span><span class="n">ss</span><span class="p">:]</span>
        <span class="n">sindices</span><span class="p">[:</span><span class="n">ss</span><span class="p">]</span> <span class="o">=</span> <span class="n">sindices</span><span class="p">[</span><span class="n">ss</span><span class="p">:]</span>

    <span class="k">def</span> <span class="nf">update_caches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nslice</span><span class="p">,</span> <span class="n">ssorted</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the caches for faster lookups.&quot;&quot;&quot;</span>

        <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span>
        <span class="n">ncs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchunkslice</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp</span>
        <span class="c1"># update first &amp; second cache bounds (ranges &amp; bounds)</span>
        <span class="n">tmp</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="n">nslice</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssorted</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">tmp</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">nslice</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssorted</span><span class="p">[</span><span class="n">cs</span><span class="p">::</span><span class="n">cs</span><span class="p">]</span>
        <span class="c1"># update start &amp; stop bounds</span>
        <span class="n">tmp</span><span class="o">.</span><span class="n">abounds</span><span class="p">[</span><span class="n">nslice</span> <span class="o">*</span> <span class="n">ncs</span><span class="p">:(</span><span class="n">nslice</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ncs</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssorted</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="n">cs</span><span class="p">]</span>
        <span class="n">tmp</span><span class="o">.</span><span class="n">zbounds</span><span class="p">[</span><span class="n">nslice</span> <span class="o">*</span> <span class="n">ncs</span><span class="p">:(</span><span class="n">nslice</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ncs</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssorted</span><span class="p">[</span><span class="n">cs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">::</span><span class="n">cs</span><span class="p">]</span>
        <span class="c1"># update median bounds</span>
        <span class="n">smedian</span> <span class="o">=</span> <span class="n">ssorted</span><span class="p">[</span><span class="n">cs</span> <span class="o">//</span> <span class="mi">2</span><span class="p">::</span><span class="n">cs</span><span class="p">]</span>
        <span class="n">tmp</span><span class="o">.</span><span class="n">mbounds</span><span class="p">[</span><span class="n">nslice</span> <span class="o">*</span> <span class="n">ncs</span><span class="p">:(</span><span class="n">nslice</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ncs</span><span class="p">]</span> <span class="o">=</span> <span class="n">smedian</span>
        <span class="n">tmp</span><span class="o">.</span><span class="n">mranges</span><span class="p">[</span><span class="n">nslice</span><span class="p">]</span> <span class="o">=</span> <span class="n">smedian</span><span class="p">[</span><span class="n">ncs</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">reorder_slices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tmp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reorder completely the index at slice level.</span>

<span class="sd">        This method has to maintain the locality of elements in the</span>
<span class="sd">        ambit of ``blocks``, i.e. an element of a ``block`` cannot be</span>
<span class="sd">        sent to another ``block`` during this reordering.  This is</span>
<span class="sd">        *critical* for ``light`` indexes to be able to use this.</span>

<span class="sd">        This version of reorder_slices is optimized in that *two*</span>
<span class="sd">        complete slices are taken at a time (including the last row</span>
<span class="sd">        slice) so as to sort them.  Then, each new slice that is read is</span>
<span class="sd">        put at the end of this two-slice buffer, while the previous one</span>
<span class="sd">        is moved to the beginning of the buffer.  This is in order to</span>
<span class="sd">        better reduce the entropy of the regular part (i.e. all except</span>
<span class="sd">        the last row) of the index.</span>

<span class="sd">        A secondary effect of this is that it takes at least *twice* of</span>
<span class="sd">        memory than a previous version of reorder_slices() that only</span>
<span class="sd">        reorders on a slice-by-slice basis.  However, as this is more</span>
<span class="sd">        efficient than the old version, one can configure the slicesize</span>
<span class="sd">        to be smaller, so the memory consumption is barely similar.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp</span>
        <span class="nb">sorted</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">sorted</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">indices</span>
        <span class="k">if</span> <span class="n">tmp</span><span class="p">:</span>
            <span class="n">tmp_sorted</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">sorted2</span>
            <span class="n">tmp_indices</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">indices2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp_sorted</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">sorted</span>
            <span class="n">tmp_indices</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">indices</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span>
        <span class="n">ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span>
        <span class="n">nsb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span>
        <span class="n">nslices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslices</span>
        <span class="n">nblocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nblocks</span>
        <span class="n">nelementsLR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelementsILR</span>
        <span class="c1"># Create the buffer for reordering 2 slices at a time</span>
        <span class="n">ssorted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">ss</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">sindices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">ss</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                               <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;u</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
            <span class="c1"># Bootstrap the process for reordering</span>
            <span class="c1"># Read the first slice in buffers</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_slice</span><span class="p">(</span><span class="n">tmp_sorted</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ssorted</span><span class="p">[:</span><span class="n">ss</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_slice</span><span class="p">(</span><span class="n">tmp_indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sindices</span><span class="p">[:</span><span class="n">ss</span><span class="p">])</span>

            <span class="n">nslice</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># Just in case the loop behind executes nothing</span>
            <span class="c1"># Loop over the remainding slices in block</span>
            <span class="k">for</span> <span class="n">nslice</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">.</span><span class="n">nrows</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reorder_slice</span><span class="p">(</span><span class="n">nslice</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span>
                                   <span class="n">ssorted</span><span class="p">,</span> <span class="n">sindices</span><span class="p">,</span>
                                   <span class="n">tmp_sorted</span><span class="p">,</span> <span class="n">tmp_indices</span><span class="p">)</span>

            <span class="c1"># End the process (enrolling the lastrow if necessary)</span>
            <span class="k">if</span> <span class="n">nelementsLR</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sortedLR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp</span><span class="o">.</span><span class="n">sortedLR</span>
                <span class="n">indicesLR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp</span><span class="o">.</span><span class="n">indicesLR</span>
                <span class="c1"># Shrink the ssorted and sindices arrays to the minimum</span>
                <span class="n">ssorted2</span> <span class="o">=</span> <span class="n">ssorted</span><span class="p">[:</span><span class="n">ss</span> <span class="o">+</span> <span class="n">nelementsLR</span><span class="p">]</span>
                <span class="n">sortedlr</span> <span class="o">=</span> <span class="n">ssorted2</span><span class="p">[</span><span class="n">ss</span><span class="p">:]</span>
                <span class="n">sindices2</span> <span class="o">=</span> <span class="n">sindices</span><span class="p">[:</span><span class="n">ss</span> <span class="o">+</span> <span class="n">nelementsLR</span><span class="p">]</span>
                <span class="n">indiceslr</span> <span class="o">=</span> <span class="n">sindices2</span><span class="p">[</span><span class="n">ss</span><span class="p">:]</span>
                <span class="c1"># Read the last row info in the second part of the buffer</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">read_slice_lr</span><span class="p">(</span><span class="n">sortedLR</span><span class="p">,</span> <span class="n">sortedlr</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">read_slice_lr</span><span class="p">(</span><span class="n">indicesLR</span><span class="p">,</span> <span class="n">indiceslr</span><span class="p">)</span>
                <span class="n">indexesextension</span><span class="o">.</span><span class="n">keysort</span><span class="p">(</span><span class="n">ssorted2</span><span class="p">,</span> <span class="n">sindices2</span><span class="p">)</span>
                <span class="c1"># Write the second part of the buffers to the lastrow indices</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write_sliceLR</span><span class="p">(</span><span class="n">sortedLR</span><span class="p">,</span> <span class="n">sortedlr</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write_sliceLR</span><span class="p">(</span><span class="n">indicesLR</span><span class="p">,</span> <span class="n">indiceslr</span><span class="p">)</span>
                <span class="c1"># Update the caches for last row</span>
                <span class="n">bebounds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sortedlr</span><span class="p">[::</span><span class="n">cs</span><span class="p">],</span> <span class="p">[</span><span class="n">sortedlr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>
                <span class="n">sortedLR</span><span class="p">[</span><span class="n">nelementsLR</span><span class="p">:</span><span class="n">nelementsLR</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">bebounds</span><span class="p">)]</span> <span class="o">=</span> <span class="n">bebounds</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bebounds</span> <span class="o">=</span> <span class="n">bebounds</span>
            <span class="c1"># Write the first part of the buffers to the regular leaves</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_slice</span><span class="p">(</span><span class="nb">sorted</span><span class="p">,</span> <span class="n">nslice</span><span class="p">,</span> <span class="n">ssorted</span><span class="p">[:</span><span class="n">ss</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_slice</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">nslice</span><span class="p">,</span> <span class="n">sindices</span><span class="p">[:</span><span class="n">ss</span><span class="p">])</span>
            <span class="c1"># Update caches for this slice</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_caches</span><span class="p">(</span><span class="n">nslice</span><span class="p">,</span> <span class="n">ssorted</span><span class="p">[:</span><span class="n">ss</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Iterate over each block.  No data should cross block</span>
            <span class="c1"># boundaries to avoid adressing problems with short indices.</span>
            <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nblocks</span><span class="p">):</span>
                <span class="c1"># Bootstrap the process for reordering</span>
                <span class="c1"># Read the first slice in buffers</span>
                <span class="n">nrow</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">*</span> <span class="n">nsb</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">read_slice</span><span class="p">(</span><span class="n">tmp_sorted</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">ssorted</span><span class="p">[:</span><span class="n">ss</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">read_slice</span><span class="p">(</span><span class="n">tmp_indices</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">sindices</span><span class="p">[:</span><span class="n">ss</span><span class="p">])</span>

                <span class="c1"># Loop over the remainding slices in block</span>
                <span class="n">lrb</span> <span class="o">=</span> <span class="n">nrow</span> <span class="o">+</span> <span class="n">nsb</span>
                <span class="k">if</span> <span class="n">lrb</span> <span class="o">&gt;</span> <span class="n">nslices</span><span class="p">:</span>
                    <span class="n">lrb</span> <span class="o">=</span> <span class="n">nslices</span>
                <span class="n">nslice</span> <span class="o">=</span> <span class="n">nrow</span>   <span class="c1"># Just in case the loop behind executes nothing</span>
                <span class="k">for</span> <span class="n">nslice</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lrb</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reorder_slice</span><span class="p">(</span><span class="n">nslice</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span>
                                       <span class="n">ssorted</span><span class="p">,</span> <span class="n">sindices</span><span class="p">,</span>
                                       <span class="n">tmp_sorted</span><span class="p">,</span> <span class="n">tmp_indices</span><span class="p">)</span>

                <span class="c1"># Write the first part of the buffers to the regular leaves</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write_slice</span><span class="p">(</span><span class="nb">sorted</span><span class="p">,</span> <span class="n">nslice</span><span class="p">,</span> <span class="n">ssorted</span><span class="p">[:</span><span class="n">ss</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write_slice</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">nslice</span><span class="p">,</span> <span class="n">sindices</span><span class="p">[:</span><span class="n">ss</span><span class="p">])</span>
                <span class="c1"># Update caches for this slice</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_caches</span><span class="p">(</span><span class="n">nslice</span><span class="p">,</span> <span class="n">ssorted</span><span class="p">[:</span><span class="n">ss</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">swap_slices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Swap slices in a superblock.&quot;&quot;&quot;</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp</span>
        <span class="nb">sorted</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">sorted</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">indices</span>
        <span class="n">tmp_sorted</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">sorted2</span>
        <span class="n">tmp_indices</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">indices2</span>
        <span class="n">ncs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchunkslice</span>
        <span class="n">nss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">superblocksize</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span>
        <span class="n">nss2</span> <span class="o">=</span> <span class="n">nss</span>
        <span class="k">for</span> <span class="n">sblock</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsuperblocks</span><span class="p">):</span>
            <span class="c1"># Protection for last superblock having less slices than nss</span>
            <span class="n">remainingslices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslices</span> <span class="o">-</span> <span class="n">sblock</span> <span class="o">*</span> <span class="n">nss</span>
            <span class="k">if</span> <span class="n">remainingslices</span> <span class="o">&lt;</span> <span class="n">nss</span><span class="p">:</span>
                <span class="n">nss2</span> <span class="o">=</span> <span class="n">remainingslices</span>
            <span class="k">if</span> <span class="n">nss2</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;start&quot;</span><span class="p">:</span>
                <span class="n">ranges</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="n">sblock</span> <span class="o">*</span> <span class="n">nss</span><span class="p">:</span><span class="n">sblock</span> <span class="o">*</span> <span class="n">nss</span> <span class="o">+</span> <span class="n">nss2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;stop&quot;</span><span class="p">:</span>
                <span class="n">ranges</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="n">sblock</span> <span class="o">*</span> <span class="n">nss</span><span class="p">:</span><span class="n">sblock</span> <span class="o">*</span> <span class="n">nss</span> <span class="o">+</span> <span class="n">nss2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span>
                <span class="n">ranges</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">mranges</span><span class="p">[</span><span class="n">sblock</span> <span class="o">*</span> <span class="n">nss</span><span class="p">:</span><span class="n">sblock</span> <span class="o">*</span> <span class="n">nss</span> <span class="o">+</span> <span class="n">nss2</span><span class="p">]</span>
            <span class="n">sranges_idx</span> <span class="o">=</span> <span class="n">ranges</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">defsort</span><span class="p">)</span>
            <span class="c1"># Don&#39;t swap the superblock at all if one doesn&#39;t need to</span>
            <span class="n">ndiff</span> <span class="o">=</span> <span class="p">(</span><span class="n">sranges_idx</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nss2</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">ndiff</span> <span class="o">*</span> <span class="mi">50</span> <span class="o">&lt;</span> <span class="n">nss2</span><span class="p">:</span>
                <span class="c1"># The number of slices to rearrange is less than 2.5%,</span>
                <span class="c1"># so skip the reordering of this superblock</span>
                <span class="c1"># (too expensive for such a little improvement)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;skipping reordering of superblock -&gt;&quot;</span><span class="p">,</span> <span class="n">sblock</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">ns</span> <span class="o">=</span> <span class="n">sblock</span> <span class="o">*</span> <span class="n">nss2</span>
            <span class="c1"># Swap sorted and indices slices following the new order</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nss2</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">sranges_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="c1"># Swap sorted &amp; indices slices</span>
                <span class="n">oi</span> <span class="o">=</span> <span class="n">ns</span> <span class="o">+</span> <span class="n">i</span>
                <span class="n">oidx</span> <span class="o">=</span> <span class="n">ns</span> <span class="o">+</span> <span class="n">idx</span>
                <span class="n">tmp_sorted</span><span class="p">[</span><span class="n">oi</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">[</span><span class="n">oidx</span><span class="p">]</span>
                <span class="n">tmp_indices</span><span class="p">[</span><span class="n">oi</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">oidx</span><span class="p">]</span>
                <span class="c1"># Swap start, stop &amp; median ranges</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">ranges2</span><span class="p">[</span><span class="n">oi</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="n">oidx</span><span class="p">]</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">mranges2</span><span class="p">[</span><span class="n">oi</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">mranges</span><span class="p">[</span><span class="n">oidx</span><span class="p">]</span>
                <span class="c1"># Swap chunk bounds</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">bounds2</span><span class="p">[</span><span class="n">oi</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">oidx</span><span class="p">]</span>
                <span class="c1"># Swap start, stop &amp; median bounds</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">oi</span> <span class="o">*</span> <span class="n">ncs</span>
                <span class="n">jn</span> <span class="o">=</span> <span class="p">(</span><span class="n">oi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ncs</span>
                <span class="n">xj</span> <span class="o">=</span> <span class="n">oidx</span> <span class="o">*</span> <span class="n">ncs</span>
                <span class="n">xjn</span> <span class="o">=</span> <span class="p">(</span><span class="n">oidx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ncs</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">abounds2</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">jn</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">abounds</span><span class="p">[</span><span class="n">xj</span><span class="p">:</span><span class="n">xjn</span><span class="p">]</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">zbounds2</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">jn</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">zbounds</span><span class="p">[</span><span class="n">xj</span><span class="p">:</span><span class="n">xjn</span><span class="p">]</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">mbounds2</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">jn</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">mbounds</span><span class="p">[</span><span class="n">xj</span><span class="p">:</span><span class="n">xjn</span><span class="p">]</span>
            <span class="c1"># tmp -&gt; originals</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nss2</span><span class="p">):</span>
                <span class="c1"># Copy sorted &amp; indices slices</span>
                <span class="n">oi</span> <span class="o">=</span> <span class="n">ns</span> <span class="o">+</span> <span class="n">i</span>
                <span class="nb">sorted</span><span class="p">[</span><span class="n">oi</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_sorted</span><span class="p">[</span><span class="n">oi</span><span class="p">]</span>
                <span class="n">indices</span><span class="p">[</span><span class="n">oi</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_indices</span><span class="p">[</span><span class="n">oi</span><span class="p">]</span>
                <span class="c1"># Copy start, stop &amp; median ranges</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="n">oi</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">ranges2</span><span class="p">[</span><span class="n">oi</span><span class="p">]</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">mranges</span><span class="p">[</span><span class="n">oi</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">mranges2</span><span class="p">[</span><span class="n">oi</span><span class="p">]</span>
                <span class="c1"># Copy chunk bounds</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">oi</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">bounds2</span><span class="p">[</span><span class="n">oi</span><span class="p">]</span>
                <span class="c1"># Copy start, stop &amp; median bounds</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">oi</span> <span class="o">*</span> <span class="n">ncs</span>
                <span class="n">jn</span> <span class="o">=</span> <span class="p">(</span><span class="n">oi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ncs</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">abounds</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">jn</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">abounds2</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">jn</span><span class="p">]</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">zbounds</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">jn</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">zbounds2</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">jn</span><span class="p">]</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">mbounds</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">jn</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">mbounds2</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">jn</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">search_item_lt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">nslice</span><span class="p">,</span> <span class="n">limits</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Search a single item in a specific sorted slice.&quot;&quot;&quot;</span>

        <span class="c1"># This method will only works under the assumtion that item</span>
        <span class="c1"># *is to be found* in the nslice.</span>
        <span class="k">assert</span> <span class="n">nan_aware_lt</span><span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">item</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nan_aware_le</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span>
        <span class="n">ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span>
        <span class="n">nelementsLR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelementsILR</span>
        <span class="n">bstart</span> <span class="o">=</span> <span class="n">start</span> <span class="o">//</span> <span class="n">cs</span>

        <span class="c1"># Find the chunk</span>
        <span class="k">if</span> <span class="n">nslice</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslices</span><span class="p">:</span>
            <span class="n">nchunk</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">where</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">nslice</span><span class="p">],</span> <span class="n">item</span><span class="p">,</span> <span class="n">bstart</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We need to subtract 1 chunk here because bebounds</span>
            <span class="c1"># has a leading value</span>
            <span class="n">nchunk</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bebounds</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">bstart</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">nchunk</span> <span class="o">&gt;=</span> <span class="mi">0</span>

        <span class="c1"># Find the element in chunk</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">nchunk</span> <span class="o">*</span> <span class="n">cs</span>
        <span class="k">if</span> <span class="n">nslice</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslices</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">where</span><span class="o">.</span><span class="n">sorted</span><span class="p">[</span><span class="n">nslice</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span><span class="n">pos</span> <span class="o">+</span> <span class="n">cs</span><span class="p">],</span> <span class="n">item</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">ss</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">cs</span>
            <span class="k">if</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="n">nelementsLR</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">nelementsLR</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sortedLR</span><span class="p">[</span><span class="n">pos</span><span class="p">:</span><span class="n">end</span><span class="p">],</span> <span class="n">item</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">nelementsLR</span>
        <span class="k">assert</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">pos</span>

    <span class="k">def</span> <span class="nf">compute_overlaps_finegrain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute some statistics about overlaping of slices in index.</span>

<span class="sd">        It returns the following info:</span>

<span class="sd">        noverlaps : int</span>
<span class="sd">            The total number of elements that overlaps in index.</span>
<span class="sd">        multiplicity : array of int</span>
<span class="sd">            The number of times that a concrete slice overlaps with any other.</span>
<span class="sd">        toverlap : float</span>
<span class="sd">            An ovelap index: the sum of the values in segment slices that</span>
<span class="sd">            overlaps divided by the entire range of values.  This index is only</span>
<span class="sd">            computed for numerical types.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span>
        <span class="n">ranges</span> <span class="o">=</span> <span class="n">where</span><span class="o">.</span><span class="n">ranges</span><span class="p">[:]</span>
        <span class="nb">sorted</span> <span class="o">=</span> <span class="n">where</span><span class="o">.</span><span class="n">sorted</span>
        <span class="n">sortedLR</span> <span class="o">=</span> <span class="n">where</span><span class="o">.</span><span class="n">sortedLR</span>
        <span class="n">nslices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslices</span>
        <span class="n">nelementsLR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelementsILR</span>
        <span class="k">if</span> <span class="n">nelementsLR</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Add the ranges corresponding to the last row</span>
            <span class="n">rangeslr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">bebounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">bebounds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">ranges</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ranges</span><span class="p">,</span> <span class="p">[</span><span class="n">rangeslr</span><span class="p">]))</span>
            <span class="n">nslices</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">soverlap</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">toverlap</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span>
        <span class="n">multiplicity</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">nslices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int_&quot;</span><span class="p">)</span>
        <span class="n">overlaps</span> <span class="o">=</span> <span class="n">multiplicity</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">starts</span> <span class="o">=</span> <span class="n">multiplicity</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nslices</span><span class="p">):</span>
            <span class="n">prev_end</span> <span class="o">=</span> <span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nslices</span><span class="p">):</span>
                <span class="n">stj</span> <span class="o">=</span> <span class="n">starts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">stj</span> <span class="o">&lt;=</span> <span class="n">ss</span>
                <span class="k">if</span> <span class="n">stj</span> <span class="o">==</span> <span class="n">ss</span><span class="p">:</span>
                    <span class="c1"># This slice has already been counted</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslices</span><span class="p">:</span>
                    <span class="n">next_beg</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">stj</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">next_beg</span> <span class="o">=</span> <span class="n">sortedLR</span><span class="p">[</span><span class="n">stj</span><span class="p">]</span>
                <span class="n">next_end</span> <span class="o">=</span> <span class="n">ranges</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">prev_end</span> <span class="o">&gt;</span> <span class="n">next_end</span><span class="p">:</span>
                    <span class="c1"># Complete overlapping case</span>
                    <span class="n">multiplicity</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslices</span><span class="p">:</span>
                        <span class="n">overlaps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ss</span> <span class="o">-</span> <span class="n">stj</span>
                        <span class="n">starts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ss</span>   <span class="c1"># a sentinel</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">overlaps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">nelementsLR</span> <span class="o">-</span> <span class="n">stj</span>
                        <span class="n">starts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nelementsLR</span>   <span class="c1"># a sentinel</span>
                <span class="k">elif</span> <span class="n">prev_end</span> <span class="o">&gt;</span> <span class="n">next_beg</span><span class="p">:</span>
                    <span class="n">multiplicity</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_item_lt</span><span class="p">(</span>
                        <span class="n">where</span><span class="p">,</span> <span class="n">prev_end</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ranges</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">stj</span><span class="p">)</span>
                    <span class="n">nelem</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">-</span> <span class="n">stj</span>
                    <span class="n">overlaps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">nelem</span>
                    <span class="n">starts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s2">&quot;string&quot;</span><span class="p">:</span>
                        <span class="c1"># Convert ranges into floats in order to allow</span>
                        <span class="c1"># doing operations with them without overflows</span>
                        <span class="n">soverlap</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">ranges</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Return the overlap as the ratio between overlaps and entire range</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s2">&quot;string&quot;</span><span class="p">:</span>
            <span class="n">erange</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ranges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="c1"># Check that there is an effective range of values</span>
            <span class="c1"># Beware, erange can be negative in situations where</span>
            <span class="c1"># the values are suffering overflow. This can happen</span>
            <span class="c1"># specially on big signed integer values (on overflows,</span>
            <span class="c1"># the end value will become negative!).</span>
            <span class="c1"># Also, there is no way to compute overlap ratios for</span>
            <span class="c1"># non-numerical types. So, be careful and always check</span>
            <span class="c1"># that toverlap has a positive value (it must have been</span>
            <span class="c1"># initialized to -1. before) before using it.</span>
            <span class="c1"># F. Alted 2007-01-19</span>
            <span class="k">if</span> <span class="n">erange</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">toverlap</span> <span class="o">=</span> <span class="n">soverlap</span> <span class="o">/</span> <span class="n">erange</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">message</span> <span class="o">!=</span> <span class="s2">&quot;init&quot;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;toverlap (</span><span class="si">%s</span><span class="s2">):&quot;</span> <span class="o">%</span> <span class="n">message</span><span class="p">,</span> <span class="n">toverlap</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;multiplicity:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">,</span> <span class="n">multiplicity</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;overlaps:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">overlaps</span><span class="p">,</span> <span class="n">overlaps</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="n">noverlaps</span> <span class="o">=</span> <span class="n">overlaps</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># For full indexes, set the &#39;is_csi&#39; flag</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span> <span class="o">==</span> <span class="mi">8</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_iswritable</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">is_csi</span> <span class="o">=</span> <span class="p">(</span><span class="n">noverlaps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Save the number of overlaps for future references</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noverlaps</span> <span class="o">=</span> <span class="n">noverlaps</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">noverlaps</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">,</span> <span class="n">toverlap</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute some statistics about overlaping of slices in index.</span>

<span class="sd">        It returns the following info:</span>

<span class="sd">        noverlaps : int</span>
<span class="sd">            The total number of slices that overlaps in index.</span>
<span class="sd">        multiplicity : array of int</span>
<span class="sd">            The number of times that a concrete slice overlaps with any other.</span>
<span class="sd">        toverlap : float</span>
<span class="sd">            An ovelap index: the sum of the values in segment slices that</span>
<span class="sd">            overlaps divided by the entire range of values.  This index is only</span>
<span class="sd">            computed for numerical types.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ranges</span> <span class="o">=</span> <span class="n">where</span><span class="o">.</span><span class="n">ranges</span><span class="p">[:]</span>
        <span class="n">nslices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslices</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelementsILR</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Add the ranges corresponding to the last row</span>
            <span class="n">rangeslr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">bebounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">bebounds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">ranges</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ranges</span><span class="p">,</span> <span class="p">[</span><span class="n">rangeslr</span><span class="p">]))</span>
            <span class="n">nslices</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">noverlaps</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">soverlap</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">toverlap</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span>
        <span class="n">multiplicity</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">nslices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int_&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nslices</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nslices</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ranges</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span>
                    <span class="n">noverlaps</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">multiplicity</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s2">&quot;string&quot;</span><span class="p">:</span>
                        <span class="c1"># Convert ranges into floats in order to allow</span>
                        <span class="c1"># doing operations with them without overflows</span>
                        <span class="n">soverlap</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">ranges</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Return the overlap as the ratio between overlaps and entire range</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s2">&quot;string&quot;</span><span class="p">:</span>
            <span class="n">erange</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ranges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="c1"># Check that there is an effective range of values</span>
            <span class="c1"># Beware, erange can be negative in situations where</span>
            <span class="c1"># the values are suffering overflow. This can happen</span>
            <span class="c1"># specially on big signed integer values (on overflows,</span>
            <span class="c1"># the end value will become negative!).</span>
            <span class="c1"># Also, there is no way to compute overlap ratios for</span>
            <span class="c1"># non-numerical types. So, be careful and always check</span>
            <span class="c1"># that toverlap has a positive value (it must have been</span>
            <span class="c1"># initialized to -1. before) before using it.</span>
            <span class="c1"># F. Altet 2007-01-19</span>
            <span class="k">if</span> <span class="n">erange</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">toverlap</span> <span class="o">=</span> <span class="n">soverlap</span> <span class="o">/</span> <span class="n">erange</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;overlaps (</span><span class="si">%s</span><span class="s2">):&quot;</span> <span class="o">%</span> <span class="n">message</span><span class="p">,</span> <span class="n">noverlaps</span><span class="p">,</span> <span class="n">toverlap</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">multiplicity</span><span class="p">)</span>
        <span class="c1"># For full indexes, set the &#39;is_csi&#39; flag</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span> <span class="o">==</span> <span class="mi">8</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_iswritable</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">is_csi</span> <span class="o">=</span> <span class="p">(</span><span class="n">noverlaps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Save the number of overlaps for future references</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noverlaps</span> <span class="o">=</span> <span class="n">noverlaps</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">noverlaps</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">,</span> <span class="n">toverlap</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_sorted_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the sorted or indices values in the specified range.&quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">stop</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># Correction for negative values of step (reverse indices)</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">start</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelements</span> <span class="o">-</span> <span class="n">stop</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelements</span> <span class="o">-</span> <span class="n">tmp</span>
        <span class="k">if</span> <span class="n">what</span> <span class="o">==</span> <span class="s2">&quot;sorted&quot;</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted</span>
            <span class="n">valuesLR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sortedLR</span>
            <span class="n">buffer_</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span>
            <span class="n">valuesLR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicesLR</span>
            <span class="n">buffer_</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;u</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span><span class="p">)</span>
        <span class="n">ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span>
        <span class="n">nrow_start</span> <span class="o">=</span> <span class="n">start</span> <span class="o">//</span> <span class="n">ss</span>
        <span class="n">istart</span> <span class="o">=</span> <span class="n">start</span> <span class="o">%</span> <span class="n">ss</span>
        <span class="n">nrow_stop</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">//</span> <span class="n">ss</span>
        <span class="n">tlen</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
        <span class="n">bstart</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ilen</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">nrow</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrow_start</span><span class="p">,</span> <span class="n">nrow_stop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">blen</span> <span class="o">=</span> <span class="n">ss</span> <span class="o">-</span> <span class="n">istart</span>
            <span class="k">if</span> <span class="n">ilen</span> <span class="o">+</span> <span class="n">blen</span> <span class="o">&gt;</span> <span class="n">tlen</span><span class="p">:</span>
                <span class="n">blen</span> <span class="o">=</span> <span class="n">tlen</span> <span class="o">-</span> <span class="n">ilen</span>
            <span class="k">if</span> <span class="n">blen</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">nrow</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslices</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">read_slice</span><span class="p">(</span>
                    <span class="n">values</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">bstart</span><span class="p">:</span><span class="n">bstart</span> <span class="o">+</span> <span class="n">blen</span><span class="p">],</span> <span class="n">istart</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">read_slice_lr</span><span class="p">(</span>
                    <span class="n">valuesLR</span><span class="p">,</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">bstart</span><span class="p">:</span><span class="n">bstart</span> <span class="o">+</span> <span class="n">blen</span><span class="p">],</span> <span class="n">istart</span><span class="p">)</span>
            <span class="n">istart</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">bstart</span> <span class="o">+=</span> <span class="n">blen</span>
            <span class="n">ilen</span> <span class="o">+=</span> <span class="n">blen</span>
        <span class="k">return</span> <span class="n">buffer_</span><span class="p">[::</span><span class="n">step</span><span class="p">]</span>

<div class="viewcode-block" id="Index.read_sorted"><a class="viewcode-back" href="../../usersguide/libref/helper_classes.html#tables.index.Index.read_sorted">[docs]</a>    <span class="k">def</span> <span class="nf">read_sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the sorted values of index in the specified range.</span>

<span class="sd">        The meaning of the start, stop and step arguments is the same as in</span>
<span class="sd">        :meth:`Table.read_sorted`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_sorted_indices</span><span class="p">(</span><span class="s1">&#39;sorted&#39;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span></div>


<div class="viewcode-block" id="Index.read_indices"><a class="viewcode-back" href="../../usersguide/libref/helper_classes.html#tables.index.Index.read_indices">[docs]</a>    <span class="k">def</span> <span class="nf">read_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the indices values of index in the specified range.</span>

<span class="sd">        The meaning of the start, stop and step arguments is the same as in</span>
<span class="sd">        :meth:`Table.read_sorted`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_sorted_indices</span><span class="p">(</span><span class="s1">&#39;indices&#39;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_process_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a range specifc for the index usage.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Special case for the behaviour of PyTables iterators</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">idx2long</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">idx2long</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">idx2long</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nelements</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">idx2long</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">idx2long</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>


<div class="viewcode-block" id="Index.__getitem__"><a class="viewcode-back" href="../../usersguide/libref/helper_classes.html#tables.index.Index.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the indices values of index in the specified range.</span>

<span class="sd">        If key argument is an integer, the corresponding index is returned.  If</span>
<span class="sd">        key is a slice, the range of indices determined by it is returned.  A</span>
<span class="sd">        negative value of step in slice is supported, meaning that the results</span>
<span class="sd">        will be returned in reverse order.</span>

<span class="sd">        This method is equivalent to :meth:`Index.read_indices`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">is_idx</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># To support negative values</span>
                <span class="n">key</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelements</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_indices</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_indices</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelements</span>

    <span class="k">def</span> <span class="nf">restorecache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clean the limits cache and resize starts and lengths arrays&quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">params</span>
        <span class="c1"># The sorted IndexArray is absolutely required to be in memory</span>
        <span class="c1"># at the same time than the Index instance, so create a strong</span>
        <span class="c1"># reference to it.  We are not introducing leaks because the</span>
        <span class="c1"># strong reference will disappear when this Index instance is</span>
        <span class="c1"># to be closed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sorted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sorted</span><span class="o">.</span><span class="n">boundscache</span> <span class="o">=</span> <span class="n">ObjectCache</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;BOUNDS_MAX_SLOTS&#39;</span><span class="p">],</span>
                                               <span class="n">params</span><span class="p">[</span><span class="s1">&#39;BOUNDS_MAX_SIZE&#39;</span><span class="p">],</span>
                                               <span class="s1">&#39;non-opt types bounds&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sorted</span><span class="o">.</span><span class="n">boundscache</span> <span class="o">=</span> <span class="n">ObjectCache</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;BOUNDS_MAX_SLOTS&#39;</span><span class="p">],</span>
                                              <span class="n">params</span><span class="p">[</span><span class="s1">&#39;BOUNDS_MAX_SIZE&#39;</span><span class="p">],</span>
                                              <span class="s1">&#39;non-opt types bounds&#39;</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;A cache for the bounds (2nd hash) data. Only used for</span>
<span class="sd">        non-optimized types searches.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limboundscache</span> <span class="o">=</span> <span class="n">ObjectCache</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;LIMBOUNDS_MAX_SLOTS&#39;</span><span class="p">],</span>
                                          <span class="n">params</span><span class="p">[</span><span class="s1">&#39;LIMBOUNDS_MAX_SIZE&#39;</span><span class="p">],</span>
                                          <span class="s1">&#39;bounding limits&#39;</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;A cache for bounding limits.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sortedLRcache</span> <span class="o">=</span> <span class="n">ObjectCache</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;SORTEDLR_MAX_SLOTS&#39;</span><span class="p">],</span>
                                         <span class="n">params</span><span class="p">[</span><span class="s1">&#39;SORTEDLR_MAX_SIZE&#39;</span><span class="p">],</span>
                                         <span class="s1">&#39;last row chunks&#39;</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;A cache for the last row chunks. Only used for searches in</span>
<span class="sd">        the last row, and mainly useful for small indexes.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">starts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lengths</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sorted</span><span class="o">.</span><span class="n">_init_sorted_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dirtycache</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do a binary search in this index for an item.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">tref</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;Entering search&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirtycache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">restorecache</span><span class="p">()</span>

        <span class="c1"># An empty item or if left limit is larger than the right one</span>
        <span class="c1"># means that the number of records is always going to be empty,</span>
        <span class="c1"># so we avoid further computation (including looking up the</span>
        <span class="c1"># limits cache).</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">item</span> <span class="ow">or</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">starts</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lengths</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">tlen</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Check whether the item tuple is in the limits cache or not</span>
        <span class="n">nslot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limboundscache</span><span class="o">.</span><span class="n">getslot</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nslot</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">startlengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limboundscache</span><span class="o">.</span><span class="n">getitem</span><span class="p">(</span><span class="n">nslot</span><span class="p">)</span>
            <span class="c1"># Reset the lengths array (not necessary for starts)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lengths</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Now, set the interesting rows</span>
            <span class="k">for</span> <span class="n">nrow2</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">length</span> <span class="ow">in</span> <span class="n">startlengths</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="n">nrow2</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lengths</span><span class="p">[</span><span class="n">nrow2</span><span class="p">]</span> <span class="o">=</span> <span class="n">length</span>
                <span class="n">tlen</span> <span class="o">=</span> <span class="n">tlen</span> <span class="o">+</span> <span class="n">length</span>
            <span class="k">return</span> <span class="n">tlen</span>
        <span class="c1"># The item is not in cache. Do the real lookup.</span>
        <span class="nb">sorted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslices</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_search_types</span><span class="p">:</span>
                <span class="c1"># The next are optimizations. However, they hide the</span>
                <span class="c1"># CPU functions consumptions from python profiles.</span>
                <span class="c1"># You may want to de-activate them during profiling.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;int32&quot;</span><span class="p">:</span>
                    <span class="n">tlen</span> <span class="o">=</span> <span class="nb">sorted</span><span class="o">.</span><span class="n">_search_bin_na_i</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;int64&quot;</span><span class="p">:</span>
                    <span class="n">tlen</span> <span class="o">=</span> <span class="nb">sorted</span><span class="o">.</span><span class="n">_search_bin_na_ll</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;float16&quot;</span><span class="p">:</span>
                    <span class="n">tlen</span> <span class="o">=</span> <span class="nb">sorted</span><span class="o">.</span><span class="n">_search_bin_na_e</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;float32&quot;</span><span class="p">:</span>
                    <span class="n">tlen</span> <span class="o">=</span> <span class="nb">sorted</span><span class="o">.</span><span class="n">_search_bin_na_f</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;float64&quot;</span><span class="p">:</span>
                    <span class="n">tlen</span> <span class="o">=</span> <span class="nb">sorted</span><span class="o">.</span><span class="n">_search_bin_na_d</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;float96&quot;</span><span class="p">:</span>
                    <span class="n">tlen</span> <span class="o">=</span> <span class="nb">sorted</span><span class="o">.</span><span class="n">_search_bin_na_g</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;float128&quot;</span><span class="p">:</span>
                    <span class="n">tlen</span> <span class="o">=</span> <span class="nb">sorted</span><span class="o">.</span><span class="n">_search_bin_na_g</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;uint32&quot;</span><span class="p">:</span>
                    <span class="n">tlen</span> <span class="o">=</span> <span class="nb">sorted</span><span class="o">.</span><span class="n">_search_bin_na_ui</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;uint64&quot;</span><span class="p">:</span>
                    <span class="n">tlen</span> <span class="o">=</span> <span class="nb">sorted</span><span class="o">.</span><span class="n">_search_bin_na_ull</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;int8&quot;</span><span class="p">:</span>
                    <span class="n">tlen</span> <span class="o">=</span> <span class="nb">sorted</span><span class="o">.</span><span class="n">_search_bin_na_b</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;int16&quot;</span><span class="p">:</span>
                    <span class="n">tlen</span> <span class="o">=</span> <span class="nb">sorted</span><span class="o">.</span><span class="n">_search_bin_na_s</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;uint8&quot;</span><span class="p">:</span>
                    <span class="n">tlen</span> <span class="o">=</span> <span class="nb">sorted</span><span class="o">.</span><span class="n">_search_bin_na_ub</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;uint16&quot;</span><span class="p">:</span>
                    <span class="n">tlen</span> <span class="o">=</span> <span class="nb">sorted</span><span class="o">.</span><span class="n">_search_bin_na_us</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;This can&#39;t happen!&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tlen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_scalar</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">)</span>
        <span class="c1"># Get possible remaining values in last row</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelementsSLR</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Look for more indexes in the last row</span>
            <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_last_row</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lengths</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
            <span class="n">tlen</span> <span class="o">+=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">limboundscache</span><span class="o">.</span><span class="n">couldenablecache</span><span class="p">():</span>
            <span class="c1"># Get a startlengths tuple and save it in cache.</span>
            <span class="c1"># This is quite slow, but it is a good way to compress</span>
            <span class="c1"># the bounds info. Moreover, the .couldenablecache()</span>
            <span class="c1"># is doing a good work so as to avoid computing this</span>
            <span class="c1"># when it is not necessary to do it.</span>
            <span class="n">startlengths</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">length</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lengths</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">startlengths</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="n">nrow</span><span class="p">],</span> <span class="n">length</span><span class="p">))</span>
            <span class="c1"># Compute the size of the recarray (aproximately)</span>
            <span class="c1"># The +1 at the end is important to avoid 0 lengths</span>
            <span class="c1"># (remember, the object headers take some space)</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">startlengths</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># Put this startlengths list in cache</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">limboundscache</span><span class="o">.</span><span class="n">setitem</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">startlengths</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;Exiting search&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tlen</span>

    <span class="c1"># This is an scalar version of search. It works with strings as well.</span>
    <span class="k">def</span> <span class="nf">search_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do a binary search in this index for an item.&quot;&quot;&quot;</span>

        <span class="n">tlen</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Do the lookup for values fullfilling the conditions</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nslices</span><span class="p">):</span>
            <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span> <span class="o">=</span> <span class="nb">sorted</span><span class="o">.</span><span class="n">_search_bin</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
            <span class="n">tlen</span> <span class="o">+=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
        <span class="k">return</span> <span class="n">tlen</span>

    <span class="k">def</span> <span class="nf">search_last_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="c1"># Variable initialization</span>
        <span class="n">item1</span><span class="p">,</span> <span class="n">item2</span> <span class="o">=</span> <span class="n">item</span>
        <span class="n">bebounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bebounds</span>
        <span class="n">b0</span><span class="p">,</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">bebounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bebounds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">bebounds</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">itemsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="n">sortedLRcache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sortedLRcache</span>
        <span class="n">hi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelementsSLR</span>               <span class="c1"># maximum number of elements</span>
        <span class="n">rchunksize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span>

        <span class="n">nchunk</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="c1"># Lookup for item1</span>
        <span class="k">if</span> <span class="n">nan_aware_gt</span><span class="p">(</span><span class="n">item1</span><span class="p">,</span> <span class="n">b0</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nan_aware_le</span><span class="p">(</span><span class="n">item1</span><span class="p">,</span> <span class="n">b1</span><span class="p">):</span>
                <span class="c1"># Search the appropriate chunk in bounds cache</span>
                <span class="n">nchunk</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">item1</span><span class="p">)</span>
                <span class="c1"># Lookup for this chunk in cache</span>
                <span class="n">nslot</span> <span class="o">=</span> <span class="n">sortedLRcache</span><span class="o">.</span><span class="n">getslot</span><span class="p">(</span><span class="n">nchunk</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">nslot</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">chunk</span> <span class="o">=</span> <span class="n">sortedLRcache</span><span class="o">.</span><span class="n">getitem</span><span class="p">(</span><span class="n">nslot</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">begin</span> <span class="o">=</span> <span class="n">rchunksize</span> <span class="o">*</span> <span class="n">nchunk</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">rchunksize</span> <span class="o">*</span> <span class="p">(</span><span class="n">nchunk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="n">hi</span><span class="p">:</span>
                        <span class="n">end</span> <span class="o">=</span> <span class="n">hi</span>
                    <span class="c1"># Read the chunk from disk</span>
                    <span class="n">chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sortedLR</span><span class="o">.</span><span class="n">_read_sorted_slice</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sorted</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
                    <span class="c1"># Put it in cache.  It&#39;s important to *copy*</span>
                    <span class="c1"># the buffer, as it is reused in future reads!</span>
                    <span class="n">sortedLRcache</span><span class="o">.</span><span class="n">setitem</span><span class="p">(</span><span class="n">nchunk</span><span class="p">,</span> <span class="n">chunk</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                                          <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">begin</span><span class="p">)</span> <span class="o">*</span> <span class="n">itemsize</span><span class="p">)</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">item1</span><span class="p">)</span>
                <span class="n">start</span> <span class="o">+=</span> <span class="n">rchunksize</span> <span class="o">*</span> <span class="n">nchunk</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">hi</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Lookup for item2</span>
        <span class="k">if</span> <span class="n">nan_aware_ge</span><span class="p">(</span><span class="n">item2</span><span class="p">,</span> <span class="n">b0</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nan_aware_lt</span><span class="p">(</span><span class="n">item2</span><span class="p">,</span> <span class="n">b1</span><span class="p">):</span>
                <span class="c1"># Search the appropriate chunk in bounds cache</span>
                <span class="n">nchunk2</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">item2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">nchunk2</span> <span class="o">!=</span> <span class="n">nchunk</span><span class="p">:</span>
                    <span class="c1"># Lookup for this chunk in cache</span>
                    <span class="n">nslot</span> <span class="o">=</span> <span class="n">sortedLRcache</span><span class="o">.</span><span class="n">getslot</span><span class="p">(</span><span class="n">nchunk2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">nslot</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">chunk</span> <span class="o">=</span> <span class="n">sortedLRcache</span><span class="o">.</span><span class="n">getitem</span><span class="p">(</span><span class="n">nslot</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">begin</span> <span class="o">=</span> <span class="n">rchunksize</span> <span class="o">*</span> <span class="n">nchunk2</span>
                        <span class="n">end</span> <span class="o">=</span> <span class="n">rchunksize</span> <span class="o">*</span> <span class="p">(</span><span class="n">nchunk2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="n">hi</span><span class="p">:</span>
                            <span class="n">end</span> <span class="o">=</span> <span class="n">hi</span>
                        <span class="c1"># Read the chunk from disk</span>
                        <span class="n">chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sortedLR</span><span class="o">.</span><span class="n">_read_sorted_slice</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">sorted</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
                        <span class="c1"># Put it in cache.  It&#39;s important to *copy*</span>
                        <span class="c1"># the buffer, as it is reused in future reads!</span>
                        <span class="c1"># See bug #60 in xot.carabos.com</span>
                        <span class="n">sortedLRcache</span><span class="o">.</span><span class="n">setitem</span><span class="p">(</span><span class="n">nchunk2</span><span class="p">,</span> <span class="n">chunk</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                                              <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">begin</span><span class="p">)</span> <span class="o">*</span> <span class="n">itemsize</span><span class="p">)</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">item2</span><span class="p">)</span>
                <span class="n">stop</span> <span class="o">+=</span> <span class="n">rchunksize</span> <span class="o">*</span> <span class="n">nchunk2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="n">hi</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_chunkmap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute a map with the interesting chunks in index.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">tref</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;Entering get_chunkmap&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>
        <span class="n">ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span>
        <span class="n">nsb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslicesblock</span>
        <span class="n">nslices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nslices</span>
        <span class="n">lbucket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lbucket</span>
        <span class="n">indsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indsize</span>
        <span class="n">bucketsinblock</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span><span class="p">)</span> <span class="o">/</span> <span class="n">lbucket</span>
        <span class="n">nchunks</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nelements</span><span class="p">)</span> <span class="o">/</span> <span class="n">lbucket</span><span class="p">))</span>
        <span class="n">chunkmap</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">nchunks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
        <span class="n">reduction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span>
        <span class="n">starts</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">starts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">reduction</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">stops</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">starts</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lengths</span><span class="p">)</span> <span class="o">*</span> <span class="n">reduction</span>
        <span class="n">starts</span><span class="p">[</span><span class="n">starts</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>    <span class="c1"># All negative values set to zero</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span>
        <span class="k">for</span> <span class="n">nslice</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">starts</span><span class="p">[</span><span class="n">nslice</span><span class="p">]</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">stops</span><span class="p">[</span><span class="n">nslice</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;u</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">indsize</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">nslice</span> <span class="o">&lt;</span> <span class="n">nslices</span><span class="p">:</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">_read_index_slice</span><span class="p">(</span><span class="n">nslice</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">indicesLR</span><span class="o">.</span><span class="n">_read_index_slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">indsize</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">//=</span> <span class="n">lbucket</span>
                <span class="k">elif</span> <span class="n">indsize</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># The chunkmap size cannot be never larger than &#39;int_&#39;</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int_&quot;</span><span class="p">)</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">nslice</span> <span class="o">//</span> <span class="n">nsb</span><span class="p">)</span> <span class="o">*</span> <span class="n">bucketsinblock</span><span class="p">)</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="n">offset</span>
                <span class="k">elif</span> <span class="n">indsize</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># The chunkmap size cannot be never larger than &#39;int_&#39;</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int_&quot;</span><span class="p">)</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">nslice</span> <span class="o">*</span> <span class="n">ss</span><span class="p">)</span> <span class="o">//</span> <span class="n">lbucket</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="n">offset</span>
                <span class="n">chunkmap</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># The case lbucket &lt; nrowsinchunk should only happen in tests</span>
        <span class="n">nrowsinchunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrowsinchunk</span>
        <span class="k">if</span> <span class="n">lbucket</span> <span class="o">!=</span> <span class="n">nrowsinchunk</span><span class="p">:</span>
            <span class="c1"># Map the &#39;coarse grain&#39; chunkmap into the &#39;true&#39; chunkmap</span>
            <span class="n">nelements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelements</span>
            <span class="n">tnchunks</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">nelements</span><span class="p">)</span> <span class="o">/</span> <span class="n">nrowsinchunk</span><span class="p">))</span>
            <span class="n">tchunkmap</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">tnchunks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lbucket</span><span class="p">)</span> <span class="o">/</span> <span class="n">nrowsinchunk</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">chunkmap</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">starts</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span> <span class="o">*</span> <span class="n">ratio</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int_&#39;</span><span class="p">)</span>
            <span class="n">stops</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ratio</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int_&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">stops</span><span class="p">):</span>
                <span class="n">tchunkmap</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">chunkmap</span> <span class="o">=</span> <span class="n">tchunkmap</span>
        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;Exiting get_chunkmap&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">chunkmap</span>

    <span class="k">def</span> <span class="nf">get_lookup_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">,</span> <span class="n">limits</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span>

        <span class="n">column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span>
        <span class="n">coldtype</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">base</span>
        <span class="n">itemsize</span> <span class="o">=</span> <span class="n">coldtype</span><span class="o">.</span><span class="n">itemsize</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;lt&#39;</span><span class="p">,</span> <span class="s1">&#39;le&#39;</span><span class="p">,</span> <span class="s1">&#39;eq&#39;</span><span class="p">,</span> <span class="s1">&#39;ge&#39;</span><span class="p">,</span> <span class="s1">&#39;gt&#39;</span><span class="p">]</span>
            <span class="n">limit</span> <span class="o">=</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;lt&#39;</span><span class="p">:</span>
                <span class="n">range_</span> <span class="o">=</span> <span class="p">(</span><span class="n">inftype</span><span class="p">(</span><span class="n">coldtype</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">,</span> <span class="n">sign</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span>
                          <span class="n">nextafter</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">coldtype</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;le&#39;</span><span class="p">:</span>
                <span class="n">range_</span> <span class="o">=</span> <span class="p">(</span><span class="n">inftype</span><span class="p">(</span><span class="n">coldtype</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">,</span> <span class="n">sign</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span>
                          <span class="n">limit</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;gt&#39;</span><span class="p">:</span>
                <span class="n">range_</span> <span class="o">=</span> <span class="p">(</span><span class="n">nextafter</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">coldtype</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">),</span>
                          <span class="n">inftype</span><span class="p">(</span><span class="n">coldtype</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">,</span> <span class="n">sign</span><span class="o">=+</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;ge&#39;</span><span class="p">:</span>
                <span class="n">range_</span> <span class="o">=</span> <span class="p">(</span><span class="n">limit</span><span class="p">,</span>
                          <span class="n">inftype</span><span class="p">(</span><span class="n">coldtype</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">,</span> <span class="n">sign</span><span class="o">=+</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;eq&#39;</span><span class="p">:</span>
                <span class="n">range_</span> <span class="o">=</span> <span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;gt&#39;</span><span class="p">,</span> <span class="s1">&#39;ge&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;lt&#39;</span><span class="p">,</span> <span class="s1">&#39;le&#39;</span><span class="p">)</span>

            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">limits</span>
            <span class="k">if</span> <span class="n">lower</span> <span class="o">&gt;</span> <span class="n">upper</span><span class="p">:</span>
                <span class="c1"># ``a &lt;[=] x &lt;[=] b`` is always false if ``a &gt; b``.</span>
                <span class="k">return</span> <span class="p">()</span>

            <span class="k">if</span> <span class="n">ops</span> <span class="o">==</span> <span class="p">(</span><span class="s1">&#39;gt&#39;</span><span class="p">,</span> <span class="s1">&#39;lt&#39;</span><span class="p">):</span>  <span class="c1"># lower &lt; col &lt; upper</span>
                <span class="n">range_</span> <span class="o">=</span> <span class="p">(</span><span class="n">nextafter</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">coldtype</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">),</span>
                          <span class="n">nextafter</span><span class="p">(</span><span class="n">upper</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">coldtype</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">ops</span> <span class="o">==</span> <span class="p">(</span><span class="s1">&#39;ge&#39;</span><span class="p">,</span> <span class="s1">&#39;lt&#39;</span><span class="p">):</span>  <span class="c1"># lower &lt;= col &lt; upper</span>
                <span class="n">range_</span> <span class="o">=</span> <span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">nextafter</span><span class="p">(</span><span class="n">upper</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">coldtype</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">ops</span> <span class="o">==</span> <span class="p">(</span><span class="s1">&#39;gt&#39;</span><span class="p">,</span> <span class="s1">&#39;le&#39;</span><span class="p">):</span>  <span class="c1"># lower &lt; col &lt;= upper</span>
                <span class="n">range_</span> <span class="o">=</span> <span class="p">(</span><span class="n">nextafter</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">coldtype</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">),</span> <span class="n">upper</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ops</span> <span class="o">==</span> <span class="p">(</span><span class="s1">&#39;ge&#39;</span><span class="p">,</span> <span class="s1">&#39;le&#39;</span><span class="p">):</span>  <span class="c1"># lower &lt;= col &lt;= upper</span>
                <span class="n">range_</span> <span class="o">=</span> <span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">range_</span>


    <span class="k">def</span> <span class="nf">_f_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove this Index object.&quot;&quot;&quot;</span>

        <span class="c1"># Index removal is always recursive,</span>
        <span class="c1"># no matter what `recursive` says.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_f_remove</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This provides a more compact representation than __repr__&quot;&quot;&quot;</span>

        <span class="c1"># The filters</span>
        <span class="n">filters</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">complevel</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">shuffle</span><span class="p">:</span>
                <span class="n">filters</span> <span class="o">+=</span> <span class="s2">&quot;, shuffle&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">bitshuffle</span><span class="p">:</span>
                <span class="n">filters</span> <span class="o">+=</span> <span class="s2">&quot;, bitshuffle&quot;</span>
            <span class="n">filters</span> <span class="o">+=</span> <span class="s2">&quot;, </span><span class="si">{}</span><span class="s2">(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">complib</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">complevel</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;Index(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s%s</span><span class="s2">).is_csi=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> \
               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optlevel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_csi</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This provides more metainfo than standard __repr__&quot;&quot;&quot;</span>

        <span class="n">cpathname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">_v_pathname</span> <span class="o">+</span> <span class="s2">&quot;.cols.&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="o">.</span><span class="n">pathname</span>
        <span class="n">retstr</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">{}</span><span class="s2"> (Index for column </span><span class="si">{}</span><span class="s2">)</span>
<span class="s2">  optlevel := </span><span class="si">{}</span><span class="s2"></span>
<span class="s2">  kind := </span><span class="si">{}</span><span class="s2"></span>
<span class="s2">  filters := </span><span class="si">{}</span><span class="s2"></span>
<span class="s2">  is_csi := </span><span class="si">{}</span><span class="s2"></span>
<span class="s2">  nelements := </span><span class="si">{}</span><span class="s2"></span>
<span class="s2">  chunksize := </span><span class="si">{}</span><span class="s2"></span>
<span class="s2">  slicesize := </span><span class="si">{}</span><span class="s2"></span>
<span class="s2">  blocksize := </span><span class="si">{}</span><span class="s2"></span>
<span class="s2">  superblocksize := </span><span class="si">{}</span><span class="s2"></span>
<span class="s2">  dirty := </span><span class="si">{}</span><span class="s2"></span>
<span class="s2">  byteorder := </span><span class="si">{!r}</span><span class="s2">&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span> <span class="n">cpathname</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">optlevel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_csi</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">nelements</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicesize</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">superblocksize</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dirty</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">byteorder</span><span class="p">)</span>
        <span class="n">retstr</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  sorted := </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted</span>
        <span class="n">retstr</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  indices := </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span>
        <span class="n">retstr</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  ranges := </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span>
        <span class="n">retstr</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  bounds := </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span>
        <span class="n">retstr</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  sortedLR := </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">sortedLR</span>
        <span class="n">retstr</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  indicesLR := </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicesLR</span>
        <span class="k">return</span> <span class="n">retstr</span></div>


<span class="k">class</span> <span class="nc">IndexesDescG</span><span class="p">(</span><span class="n">NotLoggedMixin</span><span class="p">,</span> <span class="n">Group</span><span class="p">):</span>
    <span class="n">_c_classid</span> <span class="o">=</span> <span class="s1">&#39;DINDEX&#39;</span>


    <span class="k">def</span> <span class="nf">_g_width_warning</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;the number of indexed columns on a single description group &quot;</span>
            <span class="s2">&quot;is exceeding the recommended maximum (</span><span class="si">%d</span><span class="s2">); &quot;</span>
            <span class="s2">&quot;be ready to see PyTables asking for *lots* of memory &quot;</span>
            <span class="s2">&quot;and possibly slow I/O&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_max_group_width</span><span class="p">,</span>
            <span class="n">PerformanceWarning</span><span class="p">)</span>



<span class="k">class</span> <span class="nc">IndexesTableG</span><span class="p">(</span><span class="n">NotLoggedMixin</span><span class="p">,</span> <span class="n">Group</span><span class="p">):</span>
    <span class="n">_c_classid</span> <span class="o">=</span> <span class="s1">&#39;TINDEX&#39;</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">auto</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;AUTO_INDEX&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default_auto_index</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">AUTO_INDEX</span>

    <span class="nd">@auto</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">auto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">auto</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">AUTO_INDEX</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">auto</span><span class="p">)</span>

    <span class="nd">@auto</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">auto</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">AUTO_INDEX</span>

    <span class="k">def</span> <span class="nf">_g_width_warning</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;the number of indexed columns on a single table &quot;</span>
            <span class="s2">&quot;is exceeding the recommended maximum (</span><span class="si">%d</span><span class="s2">); &quot;</span>
            <span class="s2">&quot;be ready to see PyTables asking for *lots* of memory &quot;</span>
            <span class="s2">&quot;and possibly slow I/O&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_max_group_width</span><span class="p">,</span>
            <span class="n">PerformanceWarning</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_g_check_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_i_&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;names of index groups must start with ``_i_``: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Accessor for the `Table` object of this `IndexesTableG` container.&quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
        <span class="n">tablename</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">pop</span><span class="p">()[</span><span class="mi">3</span><span class="p">:]</span>   <span class="c1"># &quot;_i_&quot; is at the beginning</span>
        <span class="n">parentpathname</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="n">tablepathname</span> <span class="o">=</span> <span class="n">join_path</span><span class="p">(</span><span class="n">parentpathname</span><span class="p">,</span> <span class="n">tablename</span><span class="p">)</span>
        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_get_node</span><span class="p">(</span><span class="n">tablepathname</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">table</span>


<span class="k">class</span> <span class="nc">OldIndex</span><span class="p">(</span><span class="n">NotLoggedMixin</span><span class="p">,</span> <span class="n">Group</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This is meant to hide indexes of PyTables 1.x files.&quot;&quot;&quot;</span>

    <span class="n">_c_classid</span> <span class="o">=</span> <span class="s1">&#39;CINDEX&#39;</span>



<span class="c1">## Local Variables:</span>
<span class="c1">## mode: python</span>
<span class="c1">## py-indent-offset: 4</span>
<span class="c1">## tab-width: 4</span>
<span class="c1">## fill-column: 72</span>
<span class="c1">## End:</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2011â€“2020, PyTables maintainers

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>