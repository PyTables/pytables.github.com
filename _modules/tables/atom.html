<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tables.atom &mdash; PyTables 3.7.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
 
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-111342564-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-111342564-1');
</script>


</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html">
            <img src="../../_static/logo-pytables-small.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                3.7.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../usersguide/index.html">Userâ€™s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cookbook/index.html">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../other_material.html">Other Material</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../MIGRATING_TO_3.x.html">Migrating from 2.x to 3.x</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../downloads.html">Downloads</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release_notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../project_pointers.html">Project pointers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev_team.html">Development Team</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PyTables</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>tables.atom</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tables.atom</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Atom classes for describing dataset contents.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">SizeType</span>
<span class="kn">from</span> <span class="nn">.misc.enum</span> <span class="kn">import</span> <span class="n">Enum</span>

<span class="kn">import</span> <span class="nn">pickle</span>

<span class="kn">from</span> <span class="nn">.exceptions</span> <span class="kn">import</span> <span class="n">FlavorWarning</span>

<span class="n">__docformat__</span> <span class="o">=</span> <span class="s1">&#39;reStructuredText&#39;</span>
<span class="sd">&quot;&quot;&quot;The format of documentation strings in this module.&quot;&quot;&quot;</span>

<span class="n">all_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># filled as atom classes are created</span>
<span class="sd">&quot;&quot;&quot;Set of all PyTables types.&quot;&quot;&quot;</span>

<span class="n">atom_map</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># filled as atom classes are created</span>
<span class="sd">&quot;&quot;&quot;Maps atom kinds to item sizes and atom classes.</span>

<span class="sd">If there is a fixed set of possible item sizes for a given kind, the</span>
<span class="sd">kind maps to another mapping from item size in bytes to atom class.</span>
<span class="sd">Otherwise, the kind maps directly to the atom class.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">deftype_from_kind</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># filled as atom classes are created</span>
<span class="sd">&quot;&quot;&quot;Maps atom kinds to their default atom type (if any).&quot;&quot;&quot;</span>


<span class="n">_type_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^([a-z]+)([0-9]*)$&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="split_type"><a class="viewcode-back" href="../../usersguide/libref/top_level.html#tables.split_type">[docs]</a><span class="k">def</span> <span class="nf">split_type</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Split a PyTables type into a PyTables kind and an item size.</span>

<span class="sd">    Returns a tuple of (kind, itemsize). If no item size is present in the type</span>
<span class="sd">    (in the form of a precision), the returned item size is None::</span>

<span class="sd">        &gt;&gt;&gt; split_type(&#39;int32&#39;)</span>
<span class="sd">        (&#39;int&#39;, 4)</span>
<span class="sd">        &gt;&gt;&gt; split_type(&#39;string&#39;)</span>
<span class="sd">        (&#39;string&#39;, None)</span>
<span class="sd">        &gt;&gt;&gt; split_type(&#39;int20&#39;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: precision must be a multiple of 8: 20</span>
<span class="sd">        &gt;&gt;&gt; split_type(&#39;foo bar&#39;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: malformed type: &#39;foo bar&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">match</span> <span class="o">=</span> <span class="n">_type_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;malformed type: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">)</span>
    <span class="n">kind</span><span class="p">,</span> <span class="n">precision</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
    <span class="n">itemsize</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">precision</span><span class="p">:</span>
        <span class="n">precision</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">precision</span><span class="p">)</span>
        <span class="n">itemsize</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">precision</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">remainder</span><span class="p">:</span>  <span class="c1"># 0 could be a valid item size</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;precision must be a multiple of 8: </span><span class="si">%d</span><span class="s2">&quot;</span>
                             <span class="o">%</span> <span class="n">precision</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_invalid_itemsize_error</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">,</span> <span class="n">itemsizes</span><span class="p">):</span>
    <span class="n">isizes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">itemsizes</span><span class="p">)</span>
    <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid item size for kind ``</span><span class="si">%s</span><span class="s2">``: </span><span class="si">%r</span><span class="s2">; &quot;</span>
                      <span class="s2">&quot;it must be one of ``</span><span class="si">%r</span><span class="s2">``&quot;</span>
                      <span class="o">%</span> <span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">,</span> <span class="n">isizes</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_abstract_atom_init</span><span class="p">(</span><span class="n">deftype</span><span class="p">,</span> <span class="n">defvalue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a constructor for an abstract `Atom` class.&quot;&quot;&quot;</span>

    <span class="n">defitemsize</span> <span class="o">=</span> <span class="n">split_type</span><span class="p">(</span><span class="n">deftype</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">itemsize</span><span class="o">=</span><span class="n">defitemsize</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dflt</span><span class="o">=</span><span class="n">defvalue</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="n">atom_map</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">atomclass</span> <span class="o">=</span> <span class="n">atom_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="p">][</span><span class="n">itemsize</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">_invalid_itemsize_error</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">,</span>
                                          <span class="n">atom_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">atomclass</span>
        <span class="n">atomclass</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dflt</span><span class="p">)</span>
    <span class="k">return</span> <span class="fm">__init__</span>


<span class="k">def</span> <span class="nf">_normalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check that the `shape` is safe to be used and return it as a tuple.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;shape value must be greater than 0: </span><span class="si">%d</span><span class="s2">&quot;</span>
                             <span class="o">%</span> <span class="n">shape</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span>  <span class="c1"># N is a shorthand for (N,)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;shape must be an integer or sequence: </span><span class="si">%r</span><span class="s2">&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">shape</span><span class="p">,))</span>

    <span class="c1"># XXX Get from HDF5 library if possible.</span>
    <span class="c1"># HDF5 does not support ranks greater than 32</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;shapes with rank &gt; 32 are not supported: </span><span class="si">{</span><span class="n">shape</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">SizeType</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_normalize_default</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return `value` as a valid default of NumPy type `dtype`.&quot;&quot;&quot;</span>

    <span class="c1"># Create NumPy objects as defaults</span>
    <span class="c1"># This is better in order to serialize them as attributes</span>
    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">basedtype</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">base</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">basedtype</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">basedtype</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="c1"># Maybe nested dtype with &quot;scalar&quot; value.</span>
        <span class="n">default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">basedtype</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>
    <span class="c1"># 0-dim arrays will be representented as NumPy scalars</span>
    <span class="c1"># (PyTables attribute convention)</span>
    <span class="k">if</span> <span class="n">default</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
        <span class="n">default</span> <span class="o">=</span> <span class="n">default</span><span class="p">[()]</span>
    <span class="k">return</span> <span class="n">default</span>


<span class="k">def</span> <span class="nf">_cmp_dispatcher</span><span class="p">(</span><span class="n">other_method_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Dispatch comparisons to a method of the *other* object.</span>

<span class="sd">    Returns a new *rich comparison* method which dispatches calls to</span>
<span class="sd">    the method `other_method_name` of the *other* object.  If there is</span>
<span class="sd">    no such method in the object, ``False`` is returned.</span>

<span class="sd">    This is part of the implementation of a double dispatch pattern.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">dispatched_cmp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other_method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">other_method_name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">other_method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dispatched_cmp</span>


<span class="k">class</span> <span class="nc">MetaAtom</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Atom metaclass.</span>

<span class="sd">    This metaclass ensures that data about atom classes gets inserted</span>
<span class="sd">    into the suitable registries.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dict_</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dict_</span><span class="p">)</span>

        <span class="n">kind</span> <span class="o">=</span> <span class="n">dict_</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;kind&#39;</span><span class="p">)</span>
        <span class="n">itemsize</span> <span class="o">=</span> <span class="n">dict_</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;itemsize&#39;</span><span class="p">)</span>
        <span class="n">type_</span> <span class="o">=</span> <span class="n">dict_</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">)</span>
        <span class="n">deftype</span> <span class="o">=</span> <span class="n">dict_</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;_deftype&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kind</span> <span class="ow">and</span> <span class="n">deftype</span><span class="p">:</span>
            <span class="n">deftype_from_kind</span><span class="p">[</span><span class="n">kind</span><span class="p">]</span> <span class="o">=</span> <span class="n">deftype</span>

        <span class="k">if</span> <span class="n">type_</span><span class="p">:</span>
            <span class="n">all_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">type_</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kind</span> <span class="ow">and</span> <span class="n">itemsize</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">itemsize</span><span class="p">,</span> <span class="s1">&#39;__int__&#39;</span><span class="p">):</span>
            <span class="c1"># Atom classes with a non-fixed item size do have an</span>
            <span class="c1"># ``itemsize``, but it&#39;s not a number (e.g. property).</span>
            <span class="n">atom_map</span><span class="p">[</span><span class="n">kind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">kind</span><span class="p">:</span>  <span class="c1"># first definition of kind, make new entry</span>
            <span class="n">atom_map</span><span class="p">[</span><span class="n">kind</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">itemsize</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">itemsize</span><span class="p">,</span> <span class="s1">&#39;__int__&#39;</span><span class="p">):</span>  <span class="c1"># fixed</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">kind</span>  <span class="c1"># maybe from superclasses</span>
            <span class="n">atom_map</span><span class="p">[</span><span class="n">kind</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">itemsize</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">cls</span>


<div class="viewcode-block" id="Atom"><a class="viewcode-back" href="../../usersguide/libref/declarative_classes.html#tables.Atom">[docs]</a><span class="k">class</span> <span class="nc">Atom</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">MetaAtom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Defines the type of atomic cells stored in a dataset.</span>

<span class="sd">    The meaning of *atomic* is that individual elements of a cell can</span>
<span class="sd">    not be extracted directly by indexing (i.e.  __getitem__()) the</span>
<span class="sd">    dataset; e.g. if a dataset has shape (2, 2) and its atoms have</span>
<span class="sd">    shape (3,), to get the third element of the cell at (1, 0) one</span>
<span class="sd">    should use dataset[1,0][2] instead of dataset[1,0,2].</span>

<span class="sd">    The Atom class is meant to declare the different properties of the</span>
<span class="sd">    *base element* (also known as *atom*) of CArray, EArray and</span>
<span class="sd">    VLArray datasets, although they are also used to describe the base</span>
<span class="sd">    elements of Array datasets. Atoms have the property that their</span>
<span class="sd">    length is always the same.  However, you can grow datasets along</span>
<span class="sd">    the extensible dimension in the case of EArray or put a variable</span>
<span class="sd">    number of them on a VLArray row. Moreover, they are not restricted</span>
<span class="sd">    to scalar values, and they can be *fully multidimensional</span>
<span class="sd">    objects*.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    itemsize : int</span>
<span class="sd">        For types with a non-fixed size, this sets the size in</span>
<span class="sd">        bytes of individual items in the atom.</span>
<span class="sd">    shape : tuple</span>
<span class="sd">        Sets the shape of the atom. An integer shape of</span>
<span class="sd">        N is equivalent to the tuple (N,).</span>
<span class="sd">    dflt</span>
<span class="sd">        Sets the default value for the atom.</span>

<span class="sd">    The following are the public methods and attributes of the Atom class.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A series of descendant classes are offered in order to make the</span>
<span class="sd">    use of these element descriptions easier. You should use a</span>
<span class="sd">    particular Atom descendant class whenever you know the exact type</span>
<span class="sd">    you will need when writing your code. Otherwise, you may use one</span>
<span class="sd">    of the Atom.from_*() factory Methods.</span>

<span class="sd">    .. rubric:: Atom attributes</span>

<span class="sd">    .. attribute:: dflt</span>

<span class="sd">        The default value of the atom.</span>

<span class="sd">        If the user does not supply a value for an element while</span>
<span class="sd">        filling a dataset, this default value will be written to disk.</span>
<span class="sd">        If the user supplies a scalar value for a multidimensional</span>
<span class="sd">        atom, this value is automatically *broadcast* to all the items</span>
<span class="sd">        in the atom cell. If dflt is not supplied, an appropriate zero</span>
<span class="sd">        value (or *null* string) will be chosen by default.  Please</span>
<span class="sd">        note that default values are kept internally as NumPy objects.</span>

<span class="sd">    .. attribute:: dtype</span>

<span class="sd">        The NumPy dtype that most closely matches this atom.</span>

<span class="sd">    .. attribute:: itemsize</span>

<span class="sd">        Size in bytes of a single item in the atom.</span>
<span class="sd">        Specially useful for atoms of the string kind.</span>

<span class="sd">    .. attribute:: kind</span>

<span class="sd">        The PyTables kind of the atom (a string).</span>

<span class="sd">    .. attribute:: shape</span>

<span class="sd">        The shape of the atom (a tuple for scalar atoms).</span>

<span class="sd">    .. attribute:: type</span>

<span class="sd">        The PyTables type of the atom (a string).</span>

<span class="sd">        Atoms can be compared with atoms and other objects for</span>
<span class="sd">        strict (in)equality without having to compare individual</span>
<span class="sd">        attributes::</span>

<span class="sd">            &gt;&gt;&gt; atom1 = StringAtom(itemsize=10)  # same as ``atom2``</span>
<span class="sd">            &gt;&gt;&gt; atom2 = Atom.from_kind(&#39;string&#39;, 10)  # same as ``atom1``</span>
<span class="sd">            &gt;&gt;&gt; atom3 = IntAtom()</span>
<span class="sd">            &gt;&gt;&gt; atom1 == &#39;foo&#39;</span>
<span class="sd">            False</span>
<span class="sd">            &gt;&gt;&gt; atom1 == atom2</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; atom2 != atom1</span>
<span class="sd">            False</span>
<span class="sd">            &gt;&gt;&gt; atom1 == atom3</span>
<span class="sd">            False</span>
<span class="sd">            &gt;&gt;&gt; atom3 != atom2</span>
<span class="sd">            True</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">prefix</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the atom class prefix.&quot;&quot;&quot;</span>
        <span class="n">cname</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="n">cname</span><span class="p">[:</span><span class="n">cname</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">&#39;Atom&#39;</span><span class="p">)]</span>

<div class="viewcode-block" id="Atom.from_sctype"><a class="viewcode-back" href="../../usersguide/libref/declarative_classes.html#tables.Atom.from_sctype">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_sctype</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">sctype</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dflt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an Atom from a NumPy scalar type sctype.</span>

<span class="sd">        Optional shape and default value may be specified as the</span>
<span class="sd">        shape and dflt</span>
<span class="sd">        arguments, respectively. Information in the</span>
<span class="sd">        sctype not represented in an Atom is ignored::</span>

<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; Atom.from_sctype(np.int16, shape=(2, 2))</span>
<span class="sd">            Int16Atom(shape=(2, 2), dflt=0)</span>
<span class="sd">            &gt;&gt;&gt; Atom.from_sctype(&#39;S5&#39;, dflt=&#39;hello&#39;)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: unknown NumPy scalar type: &#39;S5&#39;</span>
<span class="sd">            &gt;&gt;&gt; Atom.from_sctype(&#39;float64&#39;)</span>
<span class="sd">            Float64Atom(shape=(), dflt=0.0)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sctype</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
           <span class="ow">or</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">sctype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">generic</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">sctype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">sctypeDict</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unknown NumPy scalar type: </span><span class="si">{</span><span class="n">sctype</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">sctype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sctypeDict</span><span class="p">[</span><span class="n">sctype</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">((</span><span class="n">sctype</span><span class="p">,</span> <span class="n">shape</span><span class="p">)),</span> <span class="n">dflt</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atom.from_dtype"><a class="viewcode-back" href="../../usersguide/libref/declarative_classes.html#tables.Atom.from_dtype">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dtype</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">dflt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an Atom from a NumPy dtype.</span>

<span class="sd">        An optional default value may be specified as the dflt</span>
<span class="sd">        argument. Information in the dtype not represented in an Atom is</span>
<span class="sd">        ignored::</span>

<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; Atom.from_dtype(np.dtype((np.int16, (2, 2))))</span>
<span class="sd">            Int16Atom(shape=(2, 2), dflt=0)</span>
<span class="sd">            &gt;&gt;&gt; Atom.from_dtype(np.dtype(&#39;float64&#39;))</span>
<span class="sd">            Float64Atom(shape=(), dflt=0.0)</span>

<span class="sd">        Note: for easier use in Python 3, where all strings lead to the</span>
<span class="sd">        Unicode dtype, this dtype will also generate a StringAtom. Since</span>
<span class="sd">        this is only viable for strings that are castable as ascii, a</span>
<span class="sd">        warning is issued.</span>

<span class="sd">            &gt;&gt;&gt; Atom.from_dtype(np.dtype(&#39;U20&#39;)) # doctest: +SKIP</span>
<span class="sd">            Atom.py:392: FlavorWarning: support for unicode type is very</span>
<span class="sd">                limited, and only works for strings that can be cast as ascii</span>
<span class="sd">            StringAtom(itemsize=20, shape=(), dflt=b&#39;&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">basedtype</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">base</span>
        <span class="k">if</span> <span class="n">basedtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;compound data types are not supported: </span><span class="si">%r</span><span class="s2">&quot;</span>
                             <span class="o">%</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">basedtype</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nested data types are not supported: </span><span class="si">%r</span><span class="s2">&quot;</span>
                             <span class="o">%</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">basedtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span>  <span class="c1"># can not reuse something like &#39;string80&#39;</span>
            <span class="n">itemsize</span> <span class="o">=</span> <span class="n">basedtype</span><span class="o">.</span><span class="n">itemsize</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_kind</span><span class="p">(</span><span class="s1">&#39;string&#39;</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">,</span> <span class="n">dtype</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dflt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">basedtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;U&#39;</span><span class="p">:</span>
            <span class="c1"># workaround for unicode type (standard string type in Python 3)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;support for unicode type is very limited, and &quot;</span>
                          <span class="s2">&quot;only works for strings that can be cast as ascii&quot;</span><span class="p">,</span>
                          <span class="n">FlavorWarning</span><span class="p">)</span>
            <span class="n">itemsize</span> <span class="o">=</span> <span class="n">basedtype</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">//</span> <span class="mi">4</span>
            <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">itemsize</span><span class="p">)</span> <span class="ow">in</span> <span class="n">basedtype</span><span class="o">.</span><span class="n">str</span><span class="p">,</span> <span class="p">(</span>
                <span class="s2">&quot;something went wrong in handling unicode.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_kind</span><span class="p">(</span><span class="s1">&#39;string&#39;</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">,</span> <span class="n">dtype</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dflt</span><span class="p">)</span>
        <span class="c1"># Most NumPy types have direct correspondence with PyTables types.</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_type</span><span class="p">(</span><span class="n">basedtype</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dflt</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atom.from_type"><a class="viewcode-back" href="../../usersguide/libref/declarative_classes.html#tables.Atom.from_type">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_type</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dflt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an Atom from a PyTables type.</span>

<span class="sd">        Optional shape and default value may be specified as the</span>
<span class="sd">        shape and dflt arguments, respectively::</span>

<span class="sd">            &gt;&gt;&gt; Atom.from_type(&#39;bool&#39;)</span>
<span class="sd">            BoolAtom(shape=(), dflt=False)</span>
<span class="sd">            &gt;&gt;&gt; Atom.from_type(&#39;int16&#39;, shape=(2, 2))</span>
<span class="sd">            Int16Atom(shape=(2, 2), dflt=0)</span>
<span class="sd">            &gt;&gt;&gt; Atom.from_type(&#39;string40&#39;, dflt=&#39;hello&#39;)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: unknown type: &#39;string40&#39;</span>
<span class="sd">            &gt;&gt;&gt; Atom.from_type(&#39;Float64&#39;)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: unknown type: &#39;Float64&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_types</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unknown type: </span><span class="si">{</span><span class="nb">type</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">kind</span><span class="p">,</span> <span class="n">itemsize</span> <span class="o">=</span> <span class="n">split_type</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_kind</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dflt</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atom.from_kind"><a class="viewcode-back" href="../../usersguide/libref/declarative_classes.html#tables.Atom.from_kind">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_kind</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">itemsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dflt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an Atom from a PyTables kind.</span>

<span class="sd">        Optional item size, shape and default value may be</span>
<span class="sd">        specified as the itemsize, shape and dflt</span>
<span class="sd">        arguments, respectively. Bear in mind that not all atoms support</span>
<span class="sd">        a default item size::</span>

<span class="sd">            &gt;&gt;&gt; Atom.from_kind(&#39;int&#39;, itemsize=2, shape=(2, 2))</span>
<span class="sd">            Int16Atom(shape=(2, 2), dflt=0)</span>
<span class="sd">            &gt;&gt;&gt; Atom.from_kind(&#39;int&#39;, shape=(2, 2))</span>
<span class="sd">            Int32Atom(shape=(2, 2), dflt=0)</span>
<span class="sd">            &gt;&gt;&gt; Atom.from_kind(&#39;int&#39;, shape=1)</span>
<span class="sd">            Int32Atom(shape=(1,), dflt=0)</span>
<span class="sd">            &gt;&gt;&gt; Atom.from_kind(&#39;string&#39;, dflt=b&#39;hello&#39;)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: no default item size for kind ``string``</span>
<span class="sd">            &gt;&gt;&gt; Atom.from_kind(&#39;Float&#39;)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: unknown kind: &#39;Float&#39;</span>

<span class="sd">        Moreover, some kinds with atypical constructor signatures</span>
<span class="sd">        are not supported; you need to use the proper</span>
<span class="sd">        constructor::</span>

<span class="sd">            &gt;&gt;&gt; Atom.from_kind(&#39;enum&#39;) #doctest: +ELLIPSIS</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: the ``enum`` kind is not supported...</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="n">shape</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atom_map</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unknown kind: </span><span class="si">{</span><span class="n">kind</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># This incompatibility detection may get out-of-date and is</span>
        <span class="c1"># too hard-wired, but I couldn&#39;t come up with something</span>
        <span class="c1"># smarter.  -- Ivan (2007-02-08)</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;enum&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the ``</span><span class="si">%s</span><span class="s2">`` kind is not supported; &quot;</span>
                             <span class="s2">&quot;please use the appropriate constructor&quot;</span>
                             <span class="o">%</span> <span class="n">kind</span><span class="p">)</span>
        <span class="c1"># If no `itemsize` is given, try to get the default type of the</span>
        <span class="c1"># kind (which has a fixed item size).</span>
        <span class="k">if</span> <span class="n">itemsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">deftype_from_kind</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no default item size for kind ``</span><span class="si">%s</span><span class="s2">``&quot;</span>
                                 <span class="o">%</span> <span class="n">kind</span><span class="p">)</span>
            <span class="n">type_</span> <span class="o">=</span> <span class="n">deftype_from_kind</span><span class="p">[</span><span class="n">kind</span><span class="p">]</span>
            <span class="n">kind</span><span class="p">,</span> <span class="n">itemsize</span> <span class="o">=</span> <span class="n">split_type</span><span class="p">(</span><span class="n">type_</span><span class="p">)</span>
        <span class="n">kdata</span> <span class="o">=</span> <span class="n">atom_map</span><span class="p">[</span><span class="n">kind</span><span class="p">]</span>
        <span class="c1"># Look up the class and set a possible item size.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">kdata</span><span class="p">,</span> <span class="s1">&#39;kind&#39;</span><span class="p">):</span>  <span class="c1"># atom class: non-fixed item size</span>
            <span class="n">atomclass</span> <span class="o">=</span> <span class="n">kdata</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;itemsize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">itemsize</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># dictionary: fixed item size</span>
            <span class="k">if</span> <span class="n">itemsize</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kdata</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">_invalid_itemsize_error</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">,</span> <span class="n">kdata</span><span class="p">)</span>
            <span class="n">atomclass</span> <span class="o">=</span> <span class="n">kdata</span><span class="p">[</span><span class="n">itemsize</span><span class="p">]</span>
        <span class="c1"># Only set a `dflt` argument if given (`None` may not be understood).</span>
        <span class="k">if</span> <span class="n">dflt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dflt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dflt</span>

        <span class="k">return</span> <span class="n">atomclass</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total size in bytes of the atom.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">recarrtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String type to be used in numpy.rec.array().&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of dimensions of the atom.</span>

<span class="sd">        .. versionadded:: 2.4&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nptype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dflt</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;``</span><span class="si">%s</span><span class="s2">`` is an abstract class; &quot;</span>
                                      <span class="s2">&quot;please use one of its subclasses&quot;</span>
                                      <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">_normalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The shape of the atom (a tuple for scalar atoms).&quot;&quot;&quot;</span>
        <span class="c1"># Curiously enough, NumPy isn&#39;t generally able to accept NumPy</span>
        <span class="c1"># integers in a shape. ;(</span>
        <span class="n">npshape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">((</span><span class="n">nptype</span><span class="p">,</span> <span class="n">npshape</span><span class="p">))</span>
        <span class="sd">&quot;&quot;&quot;The NumPy dtype that most closely matches this atom.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dflt</span> <span class="o">=</span> <span class="n">_normalize_default</span><span class="p">(</span><span class="n">dflt</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The default value of the atom.</span>

<span class="sd">        If the user does not supply a value for an element while</span>
<span class="sd">        filling a dataset, this default value will be written to</span>
<span class="sd">        disk. If the user supplies a scalar value for a</span>
<span class="sd">        multidimensional atom, this value is automatically *broadcast*</span>
<span class="sd">        to all the items in the atom cell. If dflt is not supplied, an</span>
<span class="sd">        appropriate zero value (or *null* string) will be chosen by</span>
<span class="sd">        default.  Please note that default values are kept internally</span>
<span class="sd">        as NumPy objects.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;shape=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">, dflt=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dflt</span><span class="si">!r}</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">itemsize</span><span class="p">,</span> <span class="s1">&#39;__int__&#39;</span><span class="p">):</span>  <span class="c1"># non-fixed</span>
            <span class="n">args</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;itemsize=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">(</span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s1">)&#39;</span>

    <span class="fm">__eq__</span> <span class="o">=</span> <span class="n">_cmp_dispatcher</span><span class="p">(</span><span class="s1">&#39;_is_equal_to_atom&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="c1"># XXX: API incompatible change for PyTables 3 line</span>
    <span class="c1"># Overriding __eq__ blocks inheritance of __hash__ in 3.x</span>
    <span class="c1"># def __hash__(self):</span>
    <span class="c1">#    return hash((self.__class__, self.type, self.shape, self.itemsize,</span>
    <span class="c1">#                 self.dflt))</span>

<div class="viewcode-block" id="Atom.copy"><a class="viewcode-back" href="../../usersguide/libref/declarative_classes.html#tables.Atom.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">override</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a copy of the atom, possibly overriding some arguments.</span>

<span class="sd">        Constructor arguments to be overridden must be passed as</span>
<span class="sd">        keyword arguments::</span>

<span class="sd">            &gt;&gt;&gt; atom1 = Int32Atom(shape=12)</span>
<span class="sd">            &gt;&gt;&gt; atom2 = atom1.copy()</span>
<span class="sd">            &gt;&gt;&gt; print(atom1)</span>
<span class="sd">            Int32Atom(shape=(12,), dflt=0)</span>
<span class="sd">            &gt;&gt;&gt; print(atom2)</span>
<span class="sd">            Int32Atom(shape=(12,), dflt=0)</span>
<span class="sd">            &gt;&gt;&gt; atom1 is atom2</span>
<span class="sd">            False</span>
<span class="sd">            &gt;&gt;&gt; atom3 = atom1.copy(shape=(2, 2))</span>
<span class="sd">            &gt;&gt;&gt; print(atom3)</span>
<span class="sd">            Int32Atom(shape=(2, 2), dflt=0)</span>
<span class="sd">            &gt;&gt;&gt; atom1.copy(foobar=42) #doctest: +ELLIPSIS</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            TypeError: ...__init__() got an unexpected keyword argument &#39;foobar&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_init_args</span><span class="p">()</span>
        <span class="n">newargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">override</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">newargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_init_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a dictionary of instance constructor arguments.</span>

<span class="sd">        This implementation works on classes which use the same names</span>
<span class="sd">        for both constructor arguments and instance attributes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">signature</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="n">signature</span><span class="o">.</span><span class="n">parameters</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg</span> <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">is</span> <span class="n">p</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">{</span><span class="n">arg</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span> <span class="k">if</span> <span class="n">arg</span> <span class="o">!=</span> <span class="s1">&#39;self&#39;</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_is_equal_to_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Is this object equal to the given `atom`?&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">atom</span><span class="o">.</span><span class="n">type</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">atom</span><span class="o">.</span><span class="n">shape</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">==</span> <span class="n">atom</span><span class="o">.</span><span class="n">itemsize</span>
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dflt</span> <span class="o">==</span> <span class="n">atom</span><span class="o">.</span><span class="n">dflt</span><span class="p">))</span></div>


<div class="viewcode-block" id="StringAtom"><a class="viewcode-back" href="../../usersguide/libref/declarative_classes.html#tables.StringAtom">[docs]</a><span class="k">class</span> <span class="nc">StringAtom</span><span class="p">(</span><span class="n">Atom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Defines an atom of type string.</span>

<span class="sd">    The item size is the *maximum* length in characters of strings.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;string&#39;</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="s1">&#39;string&#39;</span>
    <span class="n">_defvalue</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">itemsize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Size in bytes of a sigle item in the atom.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">itemsize</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dflt</span><span class="o">=</span><span class="n">_defvalue</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">itemsize</span><span class="p">,</span> <span class="s1">&#39;__int__&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">int</span><span class="p">(</span><span class="n">itemsize</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid item size for kind ``</span><span class="si">%s</span><span class="s2">``: </span><span class="si">%r</span><span class="s2">; &quot;</span>
                             <span class="s2">&quot;it must be a positive integer&quot;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;string&#39;</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">))</span>
        <span class="n">Atom</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;S</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">itemsize</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dflt</span><span class="p">)</span></div>


<div class="viewcode-block" id="BoolAtom"><a class="viewcode-back" href="../../usersguide/libref/declarative_classes.html#tables.BoolAtom">[docs]</a><span class="k">class</span> <span class="nc">BoolAtom</span><span class="p">(</span><span class="n">Atom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Defines an atom of type bool.&quot;&quot;&quot;</span>

    <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;bool&#39;</span>
    <span class="n">itemsize</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="s1">&#39;bool&#39;</span>
    <span class="n">_deftype</span> <span class="o">=</span> <span class="s1">&#39;bool8&#39;</span>
    <span class="n">_defvalue</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dflt</span><span class="o">=</span><span class="n">_defvalue</span><span class="p">):</span>
        <span class="n">Atom</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dflt</span><span class="p">)</span></div>


<div class="viewcode-block" id="IntAtom"><a class="viewcode-back" href="../../usersguide/libref/declarative_classes.html#tables.IntAtom">[docs]</a><span class="k">class</span> <span class="nc">IntAtom</span><span class="p">(</span><span class="n">Atom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Defines an atom of a signed integral type (int kind).&quot;&quot;&quot;</span>

    <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;int&#39;</span>
    <span class="n">signed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_deftype</span> <span class="o">=</span> <span class="s1">&#39;int32&#39;</span>
    <span class="n">_defvalue</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="fm">__init__</span> <span class="o">=</span> <span class="n">_abstract_atom_init</span><span class="p">(</span><span class="n">_deftype</span><span class="p">,</span> <span class="n">_defvalue</span><span class="p">)</span></div>


<div class="viewcode-block" id="UIntAtom"><a class="viewcode-back" href="../../usersguide/libref/declarative_classes.html#tables.UIntAtom">[docs]</a><span class="k">class</span> <span class="nc">UIntAtom</span><span class="p">(</span><span class="n">Atom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Defines an atom of an unsigned integral type (uint kind).&quot;&quot;&quot;</span>

    <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;uint&#39;</span>
    <span class="n">signed</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_deftype</span> <span class="o">=</span> <span class="s1">&#39;uint32&#39;</span>
    <span class="n">_defvalue</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="fm">__init__</span> <span class="o">=</span> <span class="n">_abstract_atom_init</span><span class="p">(</span><span class="n">_deftype</span><span class="p">,</span> <span class="n">_defvalue</span><span class="p">)</span></div>


<div class="viewcode-block" id="FloatAtom"><a class="viewcode-back" href="../../usersguide/libref/declarative_classes.html#tables.FloatAtom">[docs]</a><span class="k">class</span> <span class="nc">FloatAtom</span><span class="p">(</span><span class="n">Atom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Defines an atom of a floating point type (float kind).&quot;&quot;&quot;</span>

    <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;float&#39;</span>
    <span class="n">_deftype</span> <span class="o">=</span> <span class="s1">&#39;float64&#39;</span>
    <span class="n">_defvalue</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="fm">__init__</span> <span class="o">=</span> <span class="n">_abstract_atom_init</span><span class="p">(</span><span class="n">_deftype</span><span class="p">,</span> <span class="n">_defvalue</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_create_numeric_class</span><span class="p">(</span><span class="n">baseclass</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a numeric atom class with the given `baseclass` and an</span>
<span class="sd">    `itemsize`.&quot;&quot;&quot;</span>

    <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">baseclass</span><span class="o">.</span><span class="n">prefix</span><span class="p">(),</span> <span class="n">itemsize</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">type_</span> <span class="o">=</span> <span class="n">prefix</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">classdict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;itemsize&#39;</span><span class="p">:</span> <span class="n">itemsize</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="n">type_</span><span class="p">,</span>
                 <span class="s1">&#39;__doc__&#39;</span><span class="p">:</span> <span class="s2">&quot;Defines an atom of type ``</span><span class="si">%s</span><span class="s2">``.&quot;</span> <span class="o">%</span> <span class="n">type_</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dflt</span><span class="o">=</span><span class="n">baseclass</span><span class="o">.</span><span class="n">_defvalue</span><span class="p">):</span>
        <span class="n">Atom</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dflt</span><span class="p">)</span>
    <span class="n">classdict</span><span class="p">[</span><span class="s1">&#39;__init__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="fm">__init__</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">Atom&#39;</span> <span class="o">%</span> <span class="n">prefix</span><span class="p">,</span> <span class="p">(</span><span class="n">baseclass</span><span class="p">,),</span> <span class="n">classdict</span><span class="p">)</span>


<span class="n">Int8Atom</span> <span class="o">=</span> <span class="n">_create_numeric_class</span><span class="p">(</span><span class="n">IntAtom</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Int16Atom</span> <span class="o">=</span> <span class="n">_create_numeric_class</span><span class="p">(</span><span class="n">IntAtom</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">Int32Atom</span> <span class="o">=</span> <span class="n">_create_numeric_class</span><span class="p">(</span><span class="n">IntAtom</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">Int64Atom</span> <span class="o">=</span> <span class="n">_create_numeric_class</span><span class="p">(</span><span class="n">IntAtom</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">UInt8Atom</span> <span class="o">=</span> <span class="n">_create_numeric_class</span><span class="p">(</span><span class="n">UIntAtom</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">UInt16Atom</span> <span class="o">=</span> <span class="n">_create_numeric_class</span><span class="p">(</span><span class="n">UIntAtom</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">UInt32Atom</span> <span class="o">=</span> <span class="n">_create_numeric_class</span><span class="p">(</span><span class="n">UIntAtom</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">UInt64Atom</span> <span class="o">=</span> <span class="n">_create_numeric_class</span><span class="p">(</span><span class="n">UIntAtom</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>

<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s1">&#39;float16&#39;</span><span class="p">):</span>
    <span class="n">Float16Atom</span> <span class="o">=</span> <span class="n">_create_numeric_class</span><span class="p">(</span><span class="n">FloatAtom</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">Float32Atom</span> <span class="o">=</span> <span class="n">_create_numeric_class</span><span class="p">(</span><span class="n">FloatAtom</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">Float64Atom</span> <span class="o">=</span> <span class="n">_create_numeric_class</span><span class="p">(</span><span class="n">FloatAtom</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s1">&#39;float96&#39;</span><span class="p">):</span>
    <span class="n">Float96Atom</span> <span class="o">=</span> <span class="n">_create_numeric_class</span><span class="p">(</span><span class="n">FloatAtom</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s1">&#39;float128&#39;</span><span class="p">):</span>
    <span class="n">Float128Atom</span> <span class="o">=</span> <span class="n">_create_numeric_class</span><span class="p">(</span><span class="n">FloatAtom</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>


<div class="viewcode-block" id="ComplexAtom"><a class="viewcode-back" href="../../usersguide/libref/declarative_classes.html#tables.ComplexAtom">[docs]</a><span class="k">class</span> <span class="nc">ComplexAtom</span><span class="p">(</span><span class="n">Atom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Defines an atom of kind complex.</span>

<span class="sd">    Allowed item sizes are 8 (single precision) and 16 (double precision). This</span>
<span class="sd">    class must be used instead of more concrete ones to avoid confusions with</span>
<span class="sd">    numarray-like precision specifications used in PyTables 1.X.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This definition is a little more complex (no pun intended)</span>
    <span class="c1"># because, although the complex kind is a normal numerical one,</span>
    <span class="c1"># the usage of bottom-level classes is artificially forbidden.</span>
    <span class="c1"># Everything will be back to normality when people has stopped</span>
    <span class="c1"># using the old bottom-level complex classes.</span>

    <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;complex&#39;</span>
    <span class="n">_deftype</span> <span class="o">=</span> <span class="s1">&#39;complex128&#39;</span>
    <span class="n">_defvalue</span> <span class="o">=</span> <span class="mi">0</span><span class="n">j</span>
    <span class="n">_isizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">itemsize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Size in bytes of a sigle item in the atom.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">itemsize</span>

    <span class="c1"># Only instances have a `type` attribute, so complex types must be</span>
    <span class="c1"># registered by hand.</span>
    <span class="n">all_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;complex64&#39;</span><span class="p">)</span>
    <span class="n">all_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;complex128&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s1">&#39;complex192&#39;</span><span class="p">):</span>
        <span class="n">all_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;complex192&#39;</span><span class="p">)</span>
        <span class="n">_isizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s1">&#39;complex256&#39;</span><span class="p">):</span>
        <span class="n">all_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;complex256&#39;</span><span class="p">)</span>
        <span class="n">_isizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dflt</span><span class="o">=</span><span class="n">_defvalue</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">itemsize</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isizes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">_invalid_itemsize_error</span><span class="p">(</span><span class="s1">&#39;complex&#39;</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isizes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="n">itemsize</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span>
        <span class="n">Atom</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dflt</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">_ComplexErrorAtom</span><span class="p">(</span><span class="n">ComplexAtom</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="nb">type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reminds the user to stop using the old complex atom names.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dflt</span><span class="o">=</span><span class="n">ComplexAtom</span><span class="o">.</span><span class="n">_defvalue</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;to avoid confusions with PyTables 1.X complex atom names, &quot;</span>
            <span class="s2">&quot;please use ``ComplexAtom(itemsize=N)``, &quot;</span>
            <span class="s2">&quot;where N=8 for single precision complex atoms, &quot;</span>
            <span class="s2">&quot;and N=16 for double precision complex atoms&quot;</span><span class="p">)</span>


<span class="n">Complex32Atom</span> <span class="o">=</span> <span class="n">Complex64Atom</span> <span class="o">=</span> <span class="n">Complex128Atom</span> <span class="o">=</span> <span class="n">_ComplexErrorAtom</span>
<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s1">&#39;complex192&#39;</span><span class="p">):</span>
    <span class="n">Complex192Atom</span> <span class="o">=</span> <span class="n">_ComplexErrorAtom</span>
<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s1">&#39;complex256&#39;</span><span class="p">):</span>
    <span class="n">Complex256Atom</span> <span class="o">=</span> <span class="n">_ComplexErrorAtom</span>


<span class="k">class</span> <span class="nc">TimeAtom</span><span class="p">(</span><span class="n">Atom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Defines an atom of time type (time kind).</span>

<span class="sd">    There are two distinct supported types of time: a 32 bit integer value and</span>
<span class="sd">    a 64 bit floating point value. Both of them reflect the number of seconds</span>
<span class="sd">    since the Unix epoch. This atom has the property of being stored using the</span>
<span class="sd">    HDF5 time datatypes.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span>
    <span class="n">_deftype</span> <span class="o">=</span> <span class="s1">&#39;time32&#39;</span>
    <span class="n">_defvalue</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="fm">__init__</span> <span class="o">=</span> <span class="n">_abstract_atom_init</span><span class="p">(</span><span class="n">_deftype</span><span class="p">,</span> <span class="n">_defvalue</span><span class="p">)</span>


<div class="viewcode-block" id="Time32Atom"><a class="viewcode-back" href="../../usersguide/libref/declarative_classes.html#tables.Time32Atom">[docs]</a><span class="k">class</span> <span class="nc">Time32Atom</span><span class="p">(</span><span class="n">TimeAtom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Defines an atom of type time32.&quot;&quot;&quot;</span>

    <span class="n">itemsize</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="s1">&#39;time32&#39;</span>
    <span class="n">_defvalue</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dflt</span><span class="o">=</span><span class="n">_defvalue</span><span class="p">):</span>
        <span class="n">Atom</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dflt</span><span class="p">)</span></div>


<div class="viewcode-block" id="Time64Atom"><a class="viewcode-back" href="../../usersguide/libref/declarative_classes.html#tables.Time64Atom">[docs]</a><span class="k">class</span> <span class="nc">Time64Atom</span><span class="p">(</span><span class="n">TimeAtom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Defines an atom of type time64.&quot;&quot;&quot;</span>

    <span class="n">itemsize</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="s1">&#39;time64&#39;</span>
    <span class="n">_defvalue</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dflt</span><span class="o">=</span><span class="n">_defvalue</span><span class="p">):</span>
        <span class="n">Atom</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dflt</span><span class="p">)</span></div>


<div class="viewcode-block" id="EnumAtom"><a class="viewcode-back" href="../../usersguide/libref/declarative_classes.html#tables.EnumAtom">[docs]</a><span class="k">class</span> <span class="nc">EnumAtom</span><span class="p">(</span><span class="n">Atom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Description of an atom of an enumerated type.</span>

<span class="sd">    Instances of this class describe the atom type used to store enumerated</span>
<span class="sd">    values. Those values belong to an enumerated type, defined by the first</span>
<span class="sd">    argument (enum) in the constructor of the atom, which accepts the same</span>
<span class="sd">    kinds of arguments as the Enum class (see :ref:`EnumClassDescr`).  The</span>
<span class="sd">    enumerated type is stored in the enum attribute of the atom.</span>

<span class="sd">    A default value must be specified as the second argument (dflt) in the</span>
<span class="sd">    constructor; it must be the *name* (a string) of one of the enumerated</span>
<span class="sd">    values in the enumerated type. When the atom is created, the corresponding</span>
<span class="sd">    concrete value is broadcast and stored in the dflt attribute (setting</span>
<span class="sd">    different default values for items in a multidimensional atom is not</span>
<span class="sd">    supported yet). If the name does not match any value in the enumerated</span>
<span class="sd">    type, a KeyError is raised.</span>

<span class="sd">    Another atom must be specified as the base argument in order to determine</span>
<span class="sd">    the base type used for storing the values of enumerated values in memory</span>
<span class="sd">    and disk. This *storage atom* is kept in the base attribute of the created</span>
<span class="sd">    atom. As a shorthand, you may specify a PyTables type instead of the</span>
<span class="sd">    storage atom, implying that this has a scalar shape.</span>

<span class="sd">    The storage atom should be able to represent each and every concrete value</span>
<span class="sd">    in the enumeration. If it is not, a TypeError is raised. The default value</span>
<span class="sd">    of the storage atom is ignored.</span>

<span class="sd">    The type attribute of enumerated atoms is always enum.</span>

<span class="sd">    Enumerated atoms also support comparisons with other objects::</span>

<span class="sd">        &gt;&gt;&gt; enum = [&#39;T0&#39;, &#39;T1&#39;, &#39;T2&#39;]</span>
<span class="sd">        &gt;&gt;&gt; atom1 = EnumAtom(enum, &#39;T0&#39;, &#39;int8&#39;)  # same as ``atom2``</span>
<span class="sd">        &gt;&gt;&gt; atom2 = EnumAtom(enum, &#39;T0&#39;, Int8Atom())  # same as ``atom1``</span>
<span class="sd">        &gt;&gt;&gt; atom3 = EnumAtom(enum, &#39;T0&#39;, &#39;int16&#39;)</span>
<span class="sd">        &gt;&gt;&gt; atom4 = Int8Atom()</span>
<span class="sd">        &gt;&gt;&gt; atom1 == enum</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; atom1 == atom2</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; atom2 != atom1</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; atom1 == atom3</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; atom1 == atom4</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; atom4 != atom1</span>
<span class="sd">        True</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    The next C enum construction::</span>

<span class="sd">        enum myEnum {</span>
<span class="sd">            T0,</span>
<span class="sd">            T1,</span>
<span class="sd">            T2</span>
<span class="sd">        };</span>

<span class="sd">    would correspond to the following PyTables</span>
<span class="sd">    declaration::</span>

<span class="sd">        &gt;&gt;&gt; my_enum_atom = EnumAtom([&#39;T0&#39;, &#39;T1&#39;, &#39;T2&#39;], &#39;T0&#39;, &#39;int32&#39;)</span>

<span class="sd">    Please note the dflt argument with a value of &#39;T0&#39;. Since the concrete</span>
<span class="sd">    value matching T0 is unknown right now (we have not used explicit concrete</span>
<span class="sd">    values), using the name is the only option left for defining a default</span>
<span class="sd">    value for the atom.</span>

<span class="sd">    The chosen representation of values for this enumerated atom uses unsigned</span>
<span class="sd">    32-bit integers, which surely wastes quite a lot of memory. Another size</span>
<span class="sd">    could be selected by using the base argument (this time with a full-blown</span>
<span class="sd">    storage atom)::</span>

<span class="sd">        &gt;&gt;&gt; my_enum_atom = EnumAtom([&#39;T0&#39;, &#39;T1&#39;, &#39;T2&#39;], &#39;T0&#39;, UInt8Atom())</span>

<span class="sd">    You can also define multidimensional arrays for data elements::</span>

<span class="sd">        &gt;&gt;&gt; my_enum_atom = EnumAtom(</span>
<span class="sd">        ...    [&#39;T0&#39;, &#39;T1&#39;, &#39;T2&#39;], &#39;T0&#39;, base=&#39;uint32&#39;, shape=(3,2))</span>

<span class="sd">    for 3x2 arrays of uint32.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Registering this class in the class map may be a little wrong,</span>
    <span class="c1"># since the ``Atom.from_kind()`` method fails miserably with</span>
    <span class="c1"># enumerations, as they don&#39;t support an ``itemsize`` argument.</span>
    <span class="c1"># However, resetting ``__metaclass__`` to ``type`` doesn&#39;t seem to</span>
    <span class="c1"># work and I don&#39;t feel like creating a subclass of ``MetaAtom``.</span>

    <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;enum&#39;</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="s1">&#39;enum&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">itemsize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Size in bytes of a single item in the atom.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">itemsize</span>

    <span class="k">def</span> <span class="nf">_checkbase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check the `base` storage atom.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;enum&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;can not use an enumerated atom &quot;</span>
                            <span class="s2">&quot;as a storage atom: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">base</span><span class="p">)</span>

        <span class="c1"># Check whether the storage atom can represent concrete values</span>
        <span class="c1"># in the enumeration...</span>
        <span class="n">basedtype</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">pyvalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span> <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">enum</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">npgenvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pyvalues</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;concrete values are not uniformly-shaped&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">npvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">npgenvalues</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">basedtype</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;storage atom type is incompatible with &quot;</span>
                            <span class="s2">&quot;concrete values in the enumeration&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">npvalues</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">basedtype</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;storage atom shape does not match that of &quot;</span>
                            <span class="s2">&quot;concrete values in the enumeration&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">npvalues</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">!=</span> <span class="n">npgenvalues</span><span class="o">.</span><span class="n">tolist</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;storage atom type lacks precision for &quot;</span>
                            <span class="s2">&quot;concrete values in the enumeration&quot;</span><span class="p">)</span>

        <span class="c1"># ...with some implementation limitations.</span>
        <span class="k">if</span> <span class="n">npvalues</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;only integer concrete values &quot;</span>
                                      <span class="s2">&quot;are supported for the moment, sorry&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">npvalues</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;only scalar concrete values &quot;</span>
                                      <span class="s2">&quot;are supported for the moment, sorry&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_init_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a dictionary of instance constructor arguments.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">enum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">enum</span><span class="p">,</span> <span class="n">dflt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_defname</span><span class="p">,</span>
                    <span class="n">base</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_equal_to_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Is this object equal to the given `atom`?&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_is_equal_to_enumatom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">enumatom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Is this object equal to the given `enumatom`?&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">enum</span> <span class="o">==</span> <span class="n">enumatom</span><span class="o">.</span><span class="n">enum</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">enumatom</span><span class="o">.</span><span class="n">shape</span>
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dflt</span> <span class="o">==</span> <span class="n">enumatom</span><span class="o">.</span><span class="n">dflt</span><span class="p">)</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">==</span> <span class="n">enumatom</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">enum</span><span class="p">,</span> <span class="n">dflt</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">()):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">enum</span><span class="p">,</span> <span class="n">Enum</span><span class="p">):</span>
            <span class="n">enum</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">(</span><span class="n">enum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enum</span> <span class="o">=</span> <span class="n">enum</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">Atom</span><span class="o">.</span><span class="n">from_type</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkbase</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span>

        <span class="n">default</span> <span class="o">=</span> <span class="n">enum</span><span class="p">[</span><span class="n">dflt</span><span class="p">]</span>  <span class="c1"># check default value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_defname</span> <span class="o">=</span> <span class="n">dflt</span>  <span class="c1"># kept for representation purposes</span>

        <span class="c1"># These are kept to ease dumping this particular</span>
        <span class="c1"># representation of the enumeration to storage.</span>
        <span class="n">names</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">enum</span><span class="p">:</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">basedtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">dtype</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_names</span> <span class="o">=</span> <span class="n">names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">basedtype</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>

        <span class="n">Atom</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basedtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;EnumAtom(enum=</span><span class="si">%r</span><span class="s1">, dflt=</span><span class="si">%r</span><span class="s1">, base=</span><span class="si">%r</span><span class="s1">, shape=</span><span class="si">%r</span><span class="s1">)&#39;</span>
                <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">enum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_defname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="fm">__eq__</span> <span class="o">=</span> <span class="n">_cmp_dispatcher</span><span class="p">(</span><span class="s1">&#39;_is_equal_to_enumatom&#39;</span><span class="p">)</span></div>

    <span class="c1"># XXX: API incompatible change for PyTables 3 line</span>
    <span class="c1"># Overriding __eq__ blocks inheritance of __hash__ in 3.x</span>
    <span class="c1"># def __hash__(self):</span>
    <span class="c1">#    return hash((self.__class__, self.enum, self.shape, self.dflt,</span>
    <span class="c1">#                 self.base))</span>


<span class="k">class</span> <span class="nc">ReferenceAtom</span><span class="p">(</span><span class="n">Atom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Defines an atom of type object to read references.</span>
<span class="sd">    This atom is read-only.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;reference&#39;</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="s1">&#39;object&#39;</span>
    <span class="n">_deftype</span> <span class="o">=</span> <span class="s1">&#39;NoneType&#39;</span>
    <span class="n">_defvalue</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">itemsize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Size in bytes of a single item in the atom.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">itemsize</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">()):</span>
        <span class="n">Atom</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_defvalue</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;ReferenceAtom(shape=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">)&#39;</span>

<span class="c1"># Pseudo-atom classes</span>
<span class="c1"># ===================</span>
<span class="c1">#</span>
<span class="c1"># Now, there come three special classes, `ObjectAtom`, `VLStringAtom`</span>
<span class="c1"># and `VLUnicodeAtom`, that actually do not descend from `Atom`, but</span>
<span class="c1"># which goal is so similar that they should be described here.</span>
<span class="c1"># Pseudo-atoms can only be used with `VLArray` datasets, and they do</span>
<span class="c1"># not support multidimensional values, nor multiple values per row.</span>
<span class="c1">#</span>
<span class="c1"># They can be recognised because they also have ``kind``, ``type`` and</span>
<span class="c1"># ``shape`` attributes, but no ``size``, ``itemsize`` or ``dflt``</span>
<span class="c1"># ones.  Instead, they have a ``base`` atom which defines the elements</span>
<span class="c1"># used for storage.</span>
<span class="c1">#</span>
<span class="c1"># See ``examples/vlarray1.py`` and ``examples/vlarray2.py`` for</span>
<span class="c1"># further examples on `VLArray` datasets, including object</span>
<span class="c1"># serialization and string management.</span>


<span class="k">class</span> <span class="nc">PseudoAtom</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Pseudo-atoms can only be used in ``VLArray`` nodes.</span>

<span class="sd">    They can be recognised because they also have `kind`, `type` and</span>
<span class="sd">    `shape` attributes, but no `size`, `itemsize` or `dflt` ones.</span>
<span class="sd">    Instead, they have a `base` atom which defines the elements used</span>
<span class="sd">    for storage.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">()&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="k">def</span> <span class="nf">toarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">object_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert an `object_` into an array of base atoms.&quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">fromarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert an `array` of base atoms into an object.&quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span>


<span class="k">class</span> <span class="nc">_BufferedAtom</span><span class="p">(</span><span class="n">PseudoAtom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pseudo-atom which stores data as a buffer (flat array of uints).&quot;&quot;&quot;</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">toarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">object_</span><span class="p">):</span>
        <span class="n">buffer_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tobuffer</span><span class="p">(</span><span class="n">object_</span><span class="p">)</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">buffer</span><span class="o">=</span><span class="n">buffer_</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                           <span class="n">shape</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">buffer_</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">array</span>

    <span class="k">def</span> <span class="nf">_tobuffer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">object_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert an `object_` into a buffer.&quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span>


<div class="viewcode-block" id="VLStringAtom"><a class="viewcode-back" href="../../usersguide/libref/declarative_classes.html#tables.VLStringAtom">[docs]</a><span class="k">class</span> <span class="nc">VLStringAtom</span><span class="p">(</span><span class="n">_BufferedAtom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Defines an atom of type ``vlstring``.</span>

<span class="sd">    This class describes a *row* of the VLArray class, rather than an atom. It</span>
<span class="sd">    differs from the StringAtom class in that you can only add *one instance of</span>
<span class="sd">    it to one specific row*, i.e. the :meth:`VLArray.append` method only</span>
<span class="sd">    accepts one object when the base atom is of this type.</span>

<span class="sd">    This class stores bytestrings. It does not make assumptions on the</span>
<span class="sd">    encoding of the string, and raw bytes are stored as is. To store a string</span>
<span class="sd">    you will need to *explicitly* convert it to a bytestring before you can</span>
<span class="sd">    save them::</span>

<span class="sd">        &gt;&gt;&gt; s = &#39;A unicode string: hbar = \u210f&#39;</span>
<span class="sd">        &gt;&gt;&gt; bytestring = s.encode(&#39;utf-8&#39;)</span>
<span class="sd">        &gt;&gt;&gt; VLArray.append(bytestring) # doctest: +SKIP</span>

<span class="sd">    For full Unicode support, using VLUnicodeAtom (see :ref:`VLUnicodeAtom`) is</span>
<span class="sd">    recommended.</span>

<span class="sd">    Variable-length string atoms do not accept parameters and they cause the</span>
<span class="sd">    reads of rows to always return Python bytestrings.  You can regard vlstring</span>
<span class="sd">    atoms as an easy way to save generic variable length strings.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;vlstring&#39;</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="s1">&#39;vlstring&#39;</span>
    <span class="n">base</span> <span class="o">=</span> <span class="n">UInt8Atom</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_tobuffer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">object_</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">object_</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Storing non bytestrings in VLStringAtom is &quot;</span>
                          <span class="s2">&quot;deprecated.&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">object_</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;object is not a string: </span><span class="si">{</span><span class="n">object_</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">string_</span><span class="p">(</span><span class="n">object_</span><span class="p">)</span>

<div class="viewcode-block" id="VLStringAtom.fromarray"><a class="viewcode-back" href="../../usersguide/libref/declarative_classes.html#tables.VLStringAtom.fromarray">[docs]</a>    <span class="k">def</span> <span class="nf">fromarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="VLUnicodeAtom"><a class="viewcode-back" href="../../usersguide/libref/declarative_classes.html#tables.VLUnicodeAtom">[docs]</a><span class="k">class</span> <span class="nc">VLUnicodeAtom</span><span class="p">(</span><span class="n">_BufferedAtom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Defines an atom of type vlunicode.</span>

<span class="sd">    This class describes a *row* of the VLArray class, rather than an atom.  It</span>
<span class="sd">    is very similar to VLStringAtom (see :ref:`VLStringAtom`), but it stores</span>
<span class="sd">    Unicode strings (using 32-bit characters a la UCS-4, so all strings of the</span>
<span class="sd">    same length also take up the same space).</span>

<span class="sd">    This class does not make assumptions on the encoding of plain input</span>
<span class="sd">    strings.  Plain strings are supported as long as no character is out of the</span>
<span class="sd">    ASCII set; otherwise, you will need to *explicitly* convert them to Unicode</span>
<span class="sd">    before you can save them.</span>

<span class="sd">    Variable-length Unicode atoms do not accept parameters and they cause the</span>
<span class="sd">    reads of rows to always return Python Unicode strings.  You can regard</span>
<span class="sd">    vlunicode atoms as an easy way to save variable length Unicode strings.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;vlunicode&#39;</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="s1">&#39;vlunicode&#39;</span>
    <span class="n">base</span> <span class="o">=</span> <span class="n">UInt32Atom</span><span class="p">()</span>

    <span class="c1"># numpy.unicode_ no more implements the buffer interface in Python 3</span>
    <span class="c1">#</span>
    <span class="c1"># When the Python build is UCS-2, we need to promote the</span>
    <span class="c1"># Unicode string to UCS-4.  We *must* use a 0-d array since</span>
    <span class="c1"># NumPy scalars inherit the UCS-2 encoding from Python (see</span>
    <span class="c1"># NumPy ticket #525).  Since ``_tobuffer()`` can&#39;t return an</span>
    <span class="c1"># array, we must override ``toarray()`` itself.</span>
<div class="viewcode-block" id="VLUnicodeAtom.toarray"><a class="viewcode-back" href="../../usersguide/libref/declarative_classes.html#tables.VLUnicodeAtom.toarray">[docs]</a>    <span class="k">def</span> <span class="nf">toarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">object_</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">object_</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Storing bytestrings in VLUnicodeAtom is &quot;</span>
                          <span class="s2">&quot;deprecated.&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">object_</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;object is not a string: </span><span class="si">{</span><span class="n">object_</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">ustr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">object_</span><span class="p">)</span>
        <span class="n">uarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ustr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span>
            <span class="n">buffer</span><span class="o">=</span><span class="n">uarr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ustr</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_tobuffer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">object_</span><span class="p">):</span>
        <span class="c1"># This works (and is used) only with UCS-4 builds of Python,</span>
        <span class="c1"># where the width of the internal representation of a</span>
        <span class="c1"># character matches that of the base atoms.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">object_</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Storing bytestrings in VLUnicodeAtom is &quot;</span>
                          <span class="s2">&quot;deprecated.&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">object_</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;object is not a string: </span><span class="si">{</span><span class="n">object_</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unicode_</span><span class="p">(</span><span class="n">object_</span><span class="p">)</span>

<div class="viewcode-block" id="VLUnicodeAtom.fromarray"><a class="viewcode-back" href="../../usersguide/libref/declarative_classes.html#tables.VLUnicodeAtom.fromarray">[docs]</a>    <span class="k">def</span> <span class="nf">fromarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span>  <span class="c1"># ``array.view(&#39;U0&#39;)`` raises a `TypeError`</span>
        <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s1">&#39;U</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">length</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="ObjectAtom"><a class="viewcode-back" href="../../usersguide/libref/declarative_classes.html#tables.ObjectAtom">[docs]</a><span class="k">class</span> <span class="nc">ObjectAtom</span><span class="p">(</span><span class="n">_BufferedAtom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Defines an atom of type object.</span>

<span class="sd">    This class is meant to fit *any* kind of Python object in a row of a</span>
<span class="sd">    VLArray dataset by using pickle behind the scenes. Due to the fact that</span>
<span class="sd">    you can not foresee how long will be the output of the pickle</span>
<span class="sd">    serialization (i.e. the atom already has a *variable* length), you can only</span>
<span class="sd">    fit *one object per row*. However, you can still group several objects in a</span>
<span class="sd">    single tuple or list and pass it to the :meth:`VLArray.append` method.</span>

<span class="sd">    Object atoms do not accept parameters and they cause the reads of rows to</span>
<span class="sd">    always return Python objects. You can regard object atoms as an easy way to</span>
<span class="sd">    save an arbitrary number of generic Python objects in a VLArray dataset.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;object&#39;</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="s1">&#39;object&#39;</span>
    <span class="n">base</span> <span class="o">=</span> <span class="n">UInt8Atom</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_tobuffer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">object_</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">object_</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>

<div class="viewcode-block" id="ObjectAtom.fromarray"><a class="viewcode-back" href="../../usersguide/libref/declarative_classes.html#tables.ObjectAtom.fromarray">[docs]</a>    <span class="k">def</span> <span class="nf">fromarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="c1"># We have to check for an empty array because of a possible</span>
        <span class="c1"># bug in HDF5 which makes it claim that a dataset has one</span>
        <span class="c1"># record when in fact it is empty.</span>
        <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2011â€“2021, PyTables maintainers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>