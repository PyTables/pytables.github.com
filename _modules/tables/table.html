<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tables.table &mdash; PyTables 3.9.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/documentation_options.js?v=e55a5be6"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
 
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-111342564-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-111342564-1');
</script>


</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/logo-pytables-small.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                3.9.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../usersguide/index.html">Userâ€™s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cookbook/index.html">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../other_material.html">Other Material</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../MIGRATING_TO_3.x.html">Migrating from 2.x to 3.x</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../downloads.html">Downloads</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release_notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../project_pointers.html">Project pointers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev_team.html">Development Team</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PyTables</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">tables.table</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tables.table</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Here is defined the Table class.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">weakref</span>

<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">perf_counter</span> <span class="k">as</span> <span class="n">clock</span>

<span class="kn">import</span> <span class="nn">numexpr</span> <span class="k">as</span> <span class="nn">ne</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">tableextension</span>
<span class="kn">from</span> <span class="nn">.lrucacheextension</span> <span class="kn">import</span> <span class="n">ObjectCache</span><span class="p">,</span> <span class="n">NumCache</span>
<span class="kn">from</span> <span class="nn">.atom</span> <span class="kn">import</span> <span class="n">Atom</span>
<span class="kn">from</span> <span class="nn">.conditions</span> <span class="kn">import</span> <span class="n">compile_condition</span>
<span class="kn">from</span> <span class="nn">.flavor</span> <span class="kn">import</span> <span class="n">flavor_of</span><span class="p">,</span> <span class="n">array_as_internal</span><span class="p">,</span> <span class="n">internal_to_flavor</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">is_idx</span><span class="p">,</span> <span class="n">lazyattr</span><span class="p">,</span> <span class="n">SizeType</span><span class="p">,</span> <span class="n">NailedDict</span> <span class="k">as</span> <span class="n">CacheDict</span>
<span class="kn">from</span> <span class="nn">.leaf</span> <span class="kn">import</span> <span class="n">Leaf</span>
<span class="kn">from</span> <span class="nn">.description</span> <span class="kn">import</span> <span class="p">(</span><span class="n">IsDescription</span><span class="p">,</span> <span class="n">Description</span><span class="p">,</span> <span class="n">Col</span><span class="p">,</span> <span class="n">descr_from_dtype</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.exceptions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">NodeError</span><span class="p">,</span> <span class="n">HDF5ExtError</span><span class="p">,</span> <span class="n">PerformanceWarning</span><span class="p">,</span> <span class="n">OldIndexWarning</span><span class="p">,</span>
    <span class="n">NoSuchNodeError</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.utilsextension</span> <span class="kn">import</span> <span class="n">get_nested_field</span>

<span class="kn">from</span> <span class="nn">.path</span> <span class="kn">import</span> <span class="n">join_path</span><span class="p">,</span> <span class="n">split_path</span>
<span class="kn">from</span> <span class="nn">.index</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">OldIndex</span><span class="p">,</span> <span class="n">default_index_filters</span><span class="p">,</span> <span class="n">default_auto_index</span><span class="p">,</span> <span class="n">Index</span><span class="p">,</span> <span class="n">IndexesDescG</span><span class="p">,</span>
    <span class="n">IndexesTableG</span><span class="p">)</span>


<span class="n">profile</span> <span class="o">=</span> <span class="kc">False</span>
<span class="c1"># profile = True  # Uncomment for profiling</span>
<span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">show_stats</span>


<span class="c1"># 2.2: Added support for complex types. Introduced in version 0.9.</span>
<span class="c1"># 2.2.1: Added support for time types.</span>
<span class="c1"># 2.3: Changed the indexes naming schema.</span>
<span class="c1"># 2.4: Changed indexes naming schema (again).</span>
<span class="c1"># 2.5: Added the FIELD_%d_FILL attributes.</span>
<span class="c1"># 2.6: Added the FLAVOR attribute (optional).</span>
<span class="c1"># 2.7: Numeric and numarray flavors are gone.</span>
<span class="n">obversion</span> <span class="o">=</span> <span class="s2">&quot;2.7&quot;</span>  <span class="c1"># The Table VERSION number</span>


<span class="c1"># Maps NumPy types to the types used by Numexpr.</span>
<span class="n">_nxtype_from_nptype</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">:</span> <span class="n">ne</span><span class="o">.</span><span class="n">necompiler</span><span class="o">.</span><span class="n">int_</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">:</span> <span class="n">ne</span><span class="o">.</span><span class="n">necompiler</span><span class="o">.</span><span class="n">int_</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">:</span> <span class="n">ne</span><span class="o">.</span><span class="n">necompiler</span><span class="o">.</span><span class="n">int_</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">:</span> <span class="n">ne</span><span class="o">.</span><span class="n">necompiler</span><span class="o">.</span><span class="n">long_</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span> <span class="n">ne</span><span class="o">.</span><span class="n">necompiler</span><span class="o">.</span><span class="n">int_</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">:</span> <span class="n">ne</span><span class="o">.</span><span class="n">necompiler</span><span class="o">.</span><span class="n">int_</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">:</span> <span class="n">ne</span><span class="o">.</span><span class="n">necompiler</span><span class="o">.</span><span class="n">long_</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">:</span> <span class="n">ne</span><span class="o">.</span><span class="n">necompiler</span><span class="o">.</span><span class="n">long_</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span> <span class="n">ne</span><span class="o">.</span><span class="n">necompiler</span><span class="o">.</span><span class="n">double</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">bytes_</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">_nxtype_from_nptype</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span>

<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s1">&#39;float16&#39;</span><span class="p">):</span>
    <span class="n">_nxtype_from_nptype</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span>    <span class="c1"># XXX: check</span>
<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s1">&#39;float96&#39;</span><span class="p">):</span>
    <span class="n">_nxtype_from_nptype</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float96</span><span class="p">]</span> <span class="o">=</span> <span class="n">ne</span><span class="o">.</span><span class="n">necompiler</span><span class="o">.</span><span class="n">double</span>   <span class="c1"># XXX: check</span>
<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s1">&#39;float128&#39;</span><span class="p">):</span>
    <span class="n">_nxtype_from_nptype</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float128</span><span class="p">]</span> <span class="o">=</span> <span class="n">ne</span><span class="o">.</span><span class="n">necompiler</span><span class="o">.</span><span class="n">double</span>  <span class="c1"># XXX: check</span>
<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s1">&#39;complex192&#39;</span><span class="p">):</span>
    <span class="n">_nxtype_from_nptype</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">complex192</span><span class="p">]</span> <span class="o">=</span> <span class="nb">complex</span>  <span class="c1"># XXX: check</span>
<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s1">&#39;complex256&#39;</span><span class="p">):</span>
    <span class="n">_nxtype_from_nptype</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">complex256</span><span class="p">]</span> <span class="o">=</span> <span class="nb">complex</span>  <span class="c1"># XXX: check</span>


<span class="c1"># The NumPy scalar type corresponding to `SizeType`.</span>
<span class="n">_npsizetype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SizeType</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span>


<span class="k">def</span> <span class="nf">_index_name_of</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;_i_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">node</span><span class="o">.</span><span class="n">_v_name</span>


<span class="k">def</span> <span class="nf">_index_pathname_of</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="n">nodeParentPath</span> <span class="o">=</span> <span class="n">split_path</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">join_path</span><span class="p">(</span><span class="n">nodeParentPath</span><span class="p">,</span> <span class="n">_index_name_of</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_index_pathname_of_column</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">colpathname</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">join_path</span><span class="p">(</span><span class="n">_index_pathname_of</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">colpathname</span><span class="p">)</span>


<span class="c1"># The next are versions that work with just paths (i.e. we don&#39;t need</span>
<span class="c1"># a node instance for using them, which can be critical in certain</span>
<span class="c1"># situations)</span>


<span class="k">def</span> <span class="nf">_index_name_of_</span><span class="p">(</span><span class="n">nodeName</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;_i_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">nodeName</span>


<span class="k">def</span> <span class="nf">_index_pathname_of_</span><span class="p">(</span><span class="n">nodePath</span><span class="p">):</span>
    <span class="n">nodeParentPath</span><span class="p">,</span> <span class="n">nodeName</span> <span class="o">=</span> <span class="n">split_path</span><span class="p">(</span><span class="n">nodePath</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">join_path</span><span class="p">(</span><span class="n">nodeParentPath</span><span class="p">,</span> <span class="n">_index_name_of_</span><span class="p">(</span><span class="n">nodeName</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_index_pathname_of_column_</span><span class="p">(</span><span class="n">tablePath</span><span class="p">,</span> <span class="n">colpathname</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">join_path</span><span class="p">(</span><span class="n">_index_pathname_of_</span><span class="p">(</span><span class="n">tablePath</span><span class="p">),</span> <span class="n">colpathname</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">restorecache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Define a cache for sparse table reads</span>
    <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">params</span>
    <span class="n">chunksize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_chunkshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nslots</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;TABLE_MAX_SIZE&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">chunksize</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_chunkcache</span> <span class="o">=</span> <span class="n">NumCache</span><span class="p">((</span><span class="n">nslots</span><span class="p">,</span> <span class="n">chunksize</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_dtype</span><span class="p">,</span>
                                <span class="s1">&#39;table chunk cache&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_seqcache</span> <span class="o">=</span> <span class="n">ObjectCache</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;ITERSEQ_MAX_SLOTS&#39;</span><span class="p">],</span>
                                 <span class="n">params</span><span class="p">[</span><span class="s1">&#39;ITERSEQ_MAX_SIZE&#39;</span><span class="p">],</span>
                                 <span class="s1">&#39;Iter sequence cache&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_dirtycache</span> <span class="o">=</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">_table__where_indexed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compiled</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">condvars</span><span class="p">,</span>
                          <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
        <span class="n">tref</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
        <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;Entering table_whereIndexed&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_use_index</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># Clean the table caches for indexed queries if needed</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirtycache</span><span class="p">:</span>
        <span class="n">restorecache</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># Get the values in expression that are not columns</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">condvars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">item</span><span class="p">()))</span>
    <span class="c1"># Build a key for the sequence cache</span>
    <span class="n">seqkey</span> <span class="o">=</span> <span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">))</span>
    <span class="c1"># Do a lookup in sequential cache for this query</span>
    <span class="n">nslot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seqcache</span><span class="o">.</span><span class="n">getslot</span><span class="p">(</span><span class="n">seqkey</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nslot</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Get the row sequence from the cache</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seqcache</span><span class="o">.</span><span class="n">getitem</span><span class="p">(</span><span class="n">nslot</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">([])</span>
        <span class="c1"># seq is a list.</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int64&#39;</span><span class="p">)</span>
        <span class="c1"># Correct the ranges in cached sequence</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[(</span><span class="n">seq</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span>
                <span class="n">seq</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">seq</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">%</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">itersequence</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># No luck.  self._seqcache will be populated</span>
        <span class="c1"># in the iterator if possible. (Row._finish_riterator)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seqcache_key</span> <span class="o">=</span> <span class="n">seqkey</span>

    <span class="c1"># Compute the chunkmap for every index in indexed expression</span>
    <span class="n">idxexprs</span> <span class="o">=</span> <span class="n">compiled</span><span class="o">.</span><span class="n">index_expressions</span>
    <span class="n">strexpr</span> <span class="o">=</span> <span class="n">compiled</span><span class="o">.</span><span class="n">string_expression</span>
    <span class="n">cmvars</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">tcoords</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idxexpr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idxexprs</span><span class="p">):</span>
        <span class="n">var</span><span class="p">,</span> <span class="n">ops</span><span class="p">,</span> <span class="n">lims</span> <span class="o">=</span> <span class="n">idxexpr</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">condvars</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">index</span>
        <span class="k">assert</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;the chosen column is not indexed&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">index</span><span class="o">.</span><span class="n">dirty</span><span class="p">,</span> <span class="s2">&quot;the chosen column has a dirty index&quot;</span>

        <span class="c1"># Get the number of rows that the indexed condition yields.</span>
        <span class="n">range_</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">get_lookup_range</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">lims</span><span class="p">)</span>
        <span class="n">ncoords</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">range_</span><span class="p">)</span>
        <span class="n">tcoords</span> <span class="o">+=</span> <span class="n">ncoords</span>
        <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">reduction</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">ncoords</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># No values from index condition, thus the chunkmap should be empty</span>
            <span class="n">nrowsinchunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunkshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nchunks</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span> <span class="o">/</span> <span class="n">nrowsinchunk</span><span class="p">)</span>
            <span class="n">chunkmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">nchunks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get the chunkmap from the index</span>
            <span class="n">chunkmap</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">get_chunkmap</span><span class="p">()</span>
        <span class="c1"># Assign the chunkmap to the cmvars dictionary</span>
        <span class="n">cmvars</span><span class="p">[</span><span class="s2">&quot;e</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">chunkmap</span>

    <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">reduction</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">tcoords</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># No candidates found in any indexed expression component, so leave now</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seqcache</span><span class="o">.</span><span class="n">setitem</span><span class="p">(</span><span class="n">seqkey</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">([])</span>

    <span class="c1"># Compute the final chunkmap</span>
    <span class="n">chunkmap</span> <span class="o">=</span> <span class="n">ne</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">strexpr</span><span class="p">,</span> <span class="n">cmvars</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">chunkmap</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="c1"># The chunkmap is all False, so the result is empty</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seqcache</span><span class="o">.</span><span class="n">setitem</span><span class="p">(</span><span class="n">seqkey</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">([])</span>

    <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
        <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;Exiting table_whereIndexed&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">chunkmap</span>


<span class="k">def</span> <span class="nf">create_indexes_table</span><span class="p">(</span><span class="n">table</span><span class="p">):</span>
    <span class="n">itgroup</span> <span class="o">=</span> <span class="n">IndexesTableG</span><span class="p">(</span>
        <span class="n">table</span><span class="o">.</span><span class="n">_v_parent</span><span class="p">,</span> <span class="n">_index_name_of</span><span class="p">(</span><span class="n">table</span><span class="p">),</span>
        <span class="s2">&quot;Indexes container for table &quot;</span> <span class="o">+</span> <span class="n">table</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">itgroup</span>


<span class="k">def</span> <span class="nf">create_indexes_descr</span><span class="p">(</span><span class="n">igroup</span><span class="p">,</span> <span class="n">dname</span><span class="p">,</span> <span class="n">iname</span><span class="p">,</span> <span class="n">filters</span><span class="p">):</span>
    <span class="n">idgroup</span> <span class="o">=</span> <span class="n">IndexesDescG</span><span class="p">(</span>
        <span class="n">igroup</span><span class="p">,</span> <span class="n">iname</span><span class="p">,</span>
        <span class="s2">&quot;Indexes container for sub-description &quot;</span> <span class="o">+</span> <span class="n">dname</span><span class="p">,</span>
        <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">idgroup</span>


<span class="k">def</span> <span class="nf">_column__create_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">optlevel</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">tmp_dir</span><span class="p">,</span>
                          <span class="n">blocksizes</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
    <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">descr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descr</span>
    <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>
    <span class="n">get_node</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_get_node</span>

    <span class="c1"># Warn if the index already exists</span>
    <span class="k">if</span> <span class="n">index</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> for column &#39;</span><span class="si">%s</span><span class="s2">&#39; already exists. If you want to &quot;</span>
                         <span class="s2">&quot;re-create it, please, try with reindex() method &quot;</span>
                         <span class="s2">&quot;better&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">)))</span>

    <span class="c1"># Check that the datatype is indexable.</span>
    <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="s1">&#39;u8&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;indexing 64-bit unsigned integer columns &quot;</span>
            <span class="s2">&quot;is not supported yet, sorry&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;complex columns can not be indexed&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">():</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;multidimensional columns can not be indexed&quot;</span><span class="p">)</span>

    <span class="c1"># Get the indexes group for table, and if not exists, create it</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">itgroup</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">_index_pathname_of</span><span class="p">(</span><span class="n">table</span><span class="p">))</span>
    <span class="k">except</span> <span class="n">NoSuchNodeError</span><span class="p">:</span>
        <span class="n">itgroup</span> <span class="o">=</span> <span class="n">create_indexes_table</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>

    <span class="c1"># Create the necessary intermediate groups for descriptors</span>
    <span class="n">idgroup</span> <span class="o">=</span> <span class="n">itgroup</span>
    <span class="n">dname</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">pathname</span> <span class="o">=</span> <span class="n">descr</span><span class="o">.</span><span class="n">_v_pathname</span>
    <span class="k">if</span> <span class="n">pathname</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="n">inames</span> <span class="o">=</span> <span class="n">pathname</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iname</span> <span class="ow">in</span> <span class="n">inames</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dname</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="n">dname</span> <span class="o">=</span> <span class="n">iname</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dname</span> <span class="o">+=</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">iname</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">idgroup</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">itgroup</span><span class="o">.</span><span class="n">_v_pathname</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">dname</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">NoSuchNodeError</span><span class="p">:</span>
                <span class="n">idgroup</span> <span class="o">=</span> <span class="n">create_indexes_descr</span><span class="p">(</span><span class="n">idgroup</span><span class="p">,</span> <span class="n">dname</span><span class="p">,</span> <span class="n">iname</span><span class="p">,</span> <span class="n">filters</span><span class="p">)</span>

    <span class="c1"># Create the atom</span>
    <span class="k">assert</span> <span class="n">dtype</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="n">Atom</span><span class="o">.</span><span class="n">from_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">((</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))))</span>

    <span class="c1"># Protection on tables larger than the expected rows (perhaps the</span>
    <span class="c1"># user forgot to pass this parameter to the Table constructor?)</span>
    <span class="n">expectedrows</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">_v_expectedrows</span>
    <span class="k">if</span> <span class="n">table</span><span class="o">.</span><span class="n">nrows</span> <span class="o">&gt;</span> <span class="n">expectedrows</span><span class="p">:</span>
        <span class="n">expectedrows</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">nrows</span>

    <span class="c1"># Create the index itself</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span>
        <span class="n">idgroup</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="n">atom</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Index for </span><span class="si">%s</span><span class="s2"> column&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">,</span>
        <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
        <span class="n">optlevel</span><span class="o">=</span><span class="n">optlevel</span><span class="p">,</span>
        <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">,</span>
        <span class="n">tmp_dir</span><span class="o">=</span><span class="n">tmp_dir</span><span class="p">,</span>
        <span class="n">expectedrows</span><span class="o">=</span><span class="n">expectedrows</span><span class="p">,</span>
        <span class="n">byteorder</span><span class="o">=</span><span class="n">table</span><span class="o">.</span><span class="n">byteorder</span><span class="p">,</span>
        <span class="n">blocksizes</span><span class="o">=</span><span class="n">blocksizes</span><span class="p">)</span>

    <span class="n">table</span><span class="o">.</span><span class="n">_set_column_indexing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Feed the index with values</span>

    <span class="c1"># Add rows to the index if necessary</span>
    <span class="k">if</span> <span class="n">table</span><span class="o">.</span><span class="n">nrows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">indexedrows</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">_add_rows_to_index</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span> <span class="n">lastrow</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">indexedrows</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">index</span><span class="o">.</span><span class="n">dirty</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">table</span><span class="o">.</span><span class="n">_indexedrows</span> <span class="o">=</span> <span class="n">indexedrows</span>
    <span class="n">table</span><span class="o">.</span><span class="n">_unsaved_indexedrows</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">nrows</span> <span class="o">-</span> <span class="n">indexedrows</span>

    <span class="c1"># Optimize the index that has been already filled-up</span>
    <span class="n">index</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="c1"># We cannot do a flush here because when reindexing during a</span>
    <span class="c1"># flush, the indexes are created anew, and that creates a nested</span>
    <span class="c1"># call to flush().</span>
    <span class="c1"># table.flush()</span>

    <span class="k">return</span> <span class="n">indexedrows</span>


<span class="k">class</span> <span class="nc">_ColIndexes</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Provides a nice representation of column indexes.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives a detailed Description column representation.&quot;&quot;&quot;</span>

        <span class="n">rep</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;  </span><span class="se">\&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="se">\&quot;</span><span class="s1">: </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="k">return</span> <span class="s1">&#39;{</span><span class="se">\n</span><span class="s1">  </span><span class="si">%s</span><span class="s1">}&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">  &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rep</span><span class="p">))</span>


<div class="viewcode-block" id="Table">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table">[docs]</a>
<span class="k">class</span> <span class="nc">Table</span><span class="p">(</span><span class="n">tableextension</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">Leaf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This class represents heterogeneous datasets in an HDF5 file.</span>

<span class="sd">    Tables are leaves (see the Leaf class in :ref:`LeafClassDescr`) whose data</span>
<span class="sd">    consists of a unidimensional sequence of *rows*, where each row contains</span>
<span class="sd">    one or more *fields*.  Fields have an associated unique *name* and</span>
<span class="sd">    *position*, with the first field having position 0.  All rows have the same</span>
<span class="sd">    fields, which are arranged in *columns*.</span>

<span class="sd">    Fields can have any type supported by the Col class (see</span>
<span class="sd">    :ref:`ColClassDescr`) and its descendants, which support multidimensional</span>
<span class="sd">    data.  Moreover, a field can be *nested* (to an arbitrary depth), meaning</span>
<span class="sd">    that it includes further fields inside.  A field named x inside a nested</span>
<span class="sd">    field a in a table can be accessed as the field a/x (its *path name*) from</span>
<span class="sd">    the table.</span>

<span class="sd">    The structure of a table is declared by its description, which is made</span>
<span class="sd">    available in the Table.description attribute (see :class:`Table`).</span>

<span class="sd">    This class provides new methods to read, write and search table data</span>
<span class="sd">    efficiently.  It also provides special Python methods to allow accessing</span>
<span class="sd">    the table as a normal sequence or array (with extended slicing supported).</span>

<span class="sd">    PyTables supports *in-kernel* searches working simultaneously on several</span>
<span class="sd">    columns using complex conditions.  These are faster than selections using</span>
<span class="sd">    Python expressions.  See the :meth:`Table.where` method for more</span>
<span class="sd">    information on in-kernel searches.</span>

<span class="sd">    Non-nested columns can be *indexed*.  Searching an indexed column can be</span>
<span class="sd">    several times faster than searching a non-nested one.  Search methods</span>
<span class="sd">    automatically take advantage of indexing where available.</span>

<span class="sd">    When iterating a table, an object from the Row (see :ref:`RowClassDescr`)</span>
<span class="sd">    class is used.  This object allows to read and write data one row at a</span>
<span class="sd">    time, as well as to perform queries which are not supported by in-kernel</span>
<span class="sd">    syntax (at a much lower speed, of course).</span>

<span class="sd">    Objects of this class support access to individual columns via *natural</span>
<span class="sd">    naming* through the :attr:`Table.cols` accessor.  Nested columns are</span>
<span class="sd">    mapped to Cols instances, and non-nested ones to Column instances.</span>
<span class="sd">    See the Column class in :ref:`ColumnClassDescr` for examples of this</span>
<span class="sd">    feature.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parentnode</span>
<span class="sd">        The parent :class:`Group` object.</span>

<span class="sd">        .. versionchanged:: 3.0</span>
<span class="sd">           Renamed from *parentNode* to *parentnode*.</span>

<span class="sd">    name : str</span>
<span class="sd">        The name of this node in its parent group.</span>
<span class="sd">    description</span>
<span class="sd">        An IsDescription subclass or a dictionary where the keys are the field</span>
<span class="sd">        names, and the values the type definitions. In addition, a pure NumPy</span>
<span class="sd">        dtype is accepted.  If None, the table metadata is read from disk,</span>
<span class="sd">        else, it&#39;s taken from previous parameters.</span>
<span class="sd">    title</span>
<span class="sd">        Sets a TITLE attribute on the HDF5 table entity.</span>
<span class="sd">    filters : Filters</span>
<span class="sd">        An instance of the Filters class that provides information about the</span>
<span class="sd">        desired I/O filters to be applied during the life of this object.</span>
<span class="sd">    expectedrows</span>
<span class="sd">        A user estimate about the number of rows that will be on table. If not</span>
<span class="sd">        provided, the default value is ``EXPECTED_ROWS_TABLE`` (see</span>
<span class="sd">        ``tables/parameters.py``).  If you plan to save bigger tables, try</span>
<span class="sd">        providing a guess; this will optimize the HDF5 B-Tree creation and</span>
<span class="sd">        management process time and memory used.</span>
<span class="sd">    chunkshape</span>
<span class="sd">        The shape of the data chunk to be read or written as a single HDF5 I/O</span>
<span class="sd">        operation. The filters are applied to those chunks of data. Its rank</span>
<span class="sd">        for tables has to be 1.  If ``None``, a sensible value is calculated</span>
<span class="sd">        based on the `expectedrows` parameter (which is recommended).</span>
<span class="sd">    byteorder</span>
<span class="sd">        The byteorder of the data *on-disk*, specified as &#39;little&#39; or &#39;big&#39;. If</span>
<span class="sd">        this is not specified, the byteorder is that of the platform, unless</span>
<span class="sd">        you passed a recarray as the `description`, in which case the recarray</span>
<span class="sd">        byteorder will be chosen.</span>
<span class="sd">    track_times</span>
<span class="sd">        Whether time data associated with the leaf are recorded (object</span>
<span class="sd">        access time, raw data modification time, metadata change time, object</span>
<span class="sd">        birth time); default True.  Semantics of these times depend on their</span>
<span class="sd">        implementation in the HDF5 library: refer to documentation of the</span>
<span class="sd">        H5O_info_t data structure.  As of HDF5 1.8.15, only ctime (metadata</span>
<span class="sd">        change time) is implemented.</span>

<span class="sd">        .. versionadded:: 3.4.3</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The instance variables below are provided in addition to those in</span>
<span class="sd">    Leaf (see :ref:`LeafClassDescr`).  Please note that there are several</span>
<span class="sd">    col* dictionaries to ease retrieving information about a column</span>
<span class="sd">    directly by its path name, avoiding the need to walk through</span>
<span class="sd">    Table.description or Table.cols.</span>


<span class="sd">    .. rubric:: Table attributes</span>

<span class="sd">    .. attribute:: coldescrs</span>

<span class="sd">        Maps the name of a column to its Col description (see</span>
<span class="sd">        :ref:`ColClassDescr`).</span>

<span class="sd">    .. attribute:: coldflts</span>

<span class="sd">        Maps the name of a column to its default value.</span>

<span class="sd">    .. attribute:: coldtypes</span>

<span class="sd">        Maps the name of a column to its NumPy data type.</span>

<span class="sd">    .. attribute:: colindexed</span>

<span class="sd">        Is the column which name is used as a key indexed?</span>

<span class="sd">    .. attribute:: colinstances</span>

<span class="sd">        Maps the name of a column to its Column (see</span>
<span class="sd">        :ref:`ColumnClassDescr`) or Cols (see :ref:`ColsClassDescr`)</span>
<span class="sd">        instance.</span>

<span class="sd">    .. attribute:: colnames</span>

<span class="sd">        A list containing the names of *top-level* columns in the table.</span>

<span class="sd">    .. attribute:: colpathnames</span>

<span class="sd">        A list containing the pathnames of *bottom-level* columns in</span>
<span class="sd">        the table.</span>

<span class="sd">        These are the leaf columns obtained when walking the table</span>
<span class="sd">        description left-to-right, bottom-first. Columns inside a</span>
<span class="sd">        nested column have slashes (/) separating name components in</span>
<span class="sd">        their pathname.</span>

<span class="sd">    .. attribute:: cols</span>

<span class="sd">        A Cols instance that provides *natural naming* access to</span>
<span class="sd">        non-nested (Column, see :ref:`ColumnClassDescr`) and nested</span>
<span class="sd">        (Cols, see :ref:`ColsClassDescr`) columns.</span>

<span class="sd">    .. attribute:: coltypes</span>

<span class="sd">        Maps the name of a column to its PyTables data type.</span>

<span class="sd">    .. attribute:: description</span>

<span class="sd">        A Description instance (see :ref:`DescriptionClassDescr`)</span>
<span class="sd">        reflecting the structure of the table.</span>

<span class="sd">    .. attribute:: extdim</span>

<span class="sd">        The index of the enlargeable dimension (always 0 for tables).</span>

<span class="sd">    .. attribute:: indexed</span>

<span class="sd">        Does this table have any indexed columns?</span>

<span class="sd">    .. attribute:: nrows</span>

<span class="sd">        The current number of rows in the table.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Class identifier.</span>
    <span class="n">_c_classid</span> <span class="o">=</span> <span class="s1">&#39;TABLE&#39;</span>

    <span class="nd">@lazyattr</span>
    <span class="k">def</span> <span class="nf">row</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The associated Row instance (see :ref:`RowClassDescr`).&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">tableextension</span><span class="o">.</span><span class="n">Row</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@lazyattr</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The NumPy ``dtype`` that most closely matches this table.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">_v_dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The shape of this table.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">,)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rowsize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The size in bytes of each row in the table.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">_v_dtype</span><span class="o">.</span><span class="n">itemsize</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size_in_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The size of this table&#39;s data in bytes when it is fully loaded into</span>
<span class="sd">        memory.  This may be used in combination with size_on_disk to calculate</span>
<span class="sd">        the compression ratio of the data.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rowsize</span>

    <span class="nd">@lazyattr</span>
    <span class="k">def</span> <span class="nf">_v_iobuf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A buffer for doing I/O.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_container</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrowsinbuf</span><span class="p">)</span>

    <span class="nd">@lazyattr</span>
    <span class="k">def</span> <span class="nf">_v_wdflts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The defaults for writing in recarray format.&quot;&quot;&quot;</span>

        <span class="c1"># First, do a check to see whether we need to set default values</span>
        <span class="c1"># different from 0 or not.</span>
        <span class="k">for</span> <span class="n">coldflt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coldflts</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coldflt</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">coldflt</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># No default different from 0 found.  Returning None.</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">wdflts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_container</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">colname</span><span class="p">,</span> <span class="n">coldflt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coldflts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ra</span> <span class="o">=</span> <span class="n">get_nested_field</span><span class="p">(</span><span class="n">wdflts</span><span class="p">,</span> <span class="n">colname</span><span class="p">)</span>
            <span class="n">ra</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">coldflt</span>
        <span class="k">return</span> <span class="n">wdflts</span>

    <span class="nd">@lazyattr</span>
    <span class="k">def</span> <span class="nf">_colunaligned</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The pathnames of unaligned, *unidimensional* columns.&quot;&quot;&quot;</span>
        <span class="n">colunaligned</span><span class="p">,</span> <span class="n">rarr</span> <span class="o">=</span> <span class="p">[],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_container</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">colpathname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colpathnames</span><span class="p">:</span>
            <span class="n">carr</span> <span class="o">=</span> <span class="n">get_nested_field</span><span class="p">(</span><span class="n">rarr</span><span class="p">,</span> <span class="n">colpathname</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">carr</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">aligned</span> <span class="ow">and</span> <span class="n">carr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">colunaligned</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">colpathname</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">colunaligned</span><span class="p">)</span>

    <span class="c1"># **************** WARNING! ***********************</span>
    <span class="c1"># This function can be called during the destruction time of a table</span>
    <span class="c1"># so measures have been taken so that it doesn&#39;t have to revive</span>
    <span class="c1"># another node (which can fool the LRU cache). The solution devised</span>
    <span class="c1"># has been to add a cache for autoindex (Table._autoindex), populate</span>
    <span class="c1"># it in creation time of the cache (which is a safe period) and then</span>
    <span class="c1"># update the cache whenever it changes.</span>
    <span class="c1"># This solves the error when running test_indexes.py ManyNodesTestCase.</span>
    <span class="c1"># F. Alted 2007-04-20</span>
    <span class="c1"># **************************************************</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">autoindex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Automatically keep column indexes up to date?</span>

<span class="sd">        Setting this value states whether existing indexes should be</span>
<span class="sd">        automatically updated after an append operation or recomputed</span>
<span class="sd">        after an index-invalidating operation (i.e. removal and</span>
<span class="sd">        modification of rows).  The default is true.</span>

<span class="sd">        This value gets into effect whenever a column is altered.  If you</span>
<span class="sd">        don&#39;t have automatic indexing activated and you want to do an an</span>
<span class="sd">        immediate update use `Table.flush_rows_to_index()`; for an immediate</span>
<span class="sd">        reindexing of invalidated indexes, use `Table.reindex_dirty()`.</span>

<span class="sd">        This value is persistent.</span>

<span class="sd">        .. versionchanged:: 3.0</span>
<span class="sd">           The *autoIndex* property has been renamed into *autoindex*.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autoindex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">indexgroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_get_node</span><span class="p">(</span><span class="n">_index_pathname_of</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">except</span> <span class="n">NoSuchNodeError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_autoindex</span> <span class="o">=</span> <span class="n">default_auto_index</span>  <span class="c1"># update cache</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autoindex</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_autoindex</span> <span class="o">=</span> <span class="n">indexgroup</span><span class="o">.</span><span class="n">auto</span>   <span class="c1"># update cache</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autoindex</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The value is in cache, return it</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autoindex</span>

    <span class="nd">@autoindex</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">autoindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">auto</span><span class="p">):</span>
        <span class="n">auto</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">auto</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">indexgroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_get_node</span><span class="p">(</span><span class="n">_index_pathname_of</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">NoSuchNodeError</span><span class="p">:</span>
            <span class="n">indexgroup</span> <span class="o">=</span> <span class="n">create_indexes_table</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">indexgroup</span><span class="o">.</span><span class="n">auto</span> <span class="o">=</span> <span class="n">auto</span>
        <span class="c1"># Update the cache in table instance as well</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_autoindex</span> <span class="o">=</span> <span class="n">auto</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indexedcolpathnames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of pathnames of indexed columns in the table.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">_colpname</span>
                <span class="k">for</span> <span class="n">_colpname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colpathnames</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colindexed</span><span class="p">[</span><span class="n">_colpname</span><span class="p">]]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">colindexes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A dictionary with the indexes of the indexed columns.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_ColIndexes</span><span class="p">((</span><span class="n">_colpname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">_f_col</span><span class="p">(</span><span class="n">_colpname</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">_colpname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colpathnames</span>
                           <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colindexed</span><span class="p">[</span><span class="n">_colpname</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_dirtyindexes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether some index in table is dirty.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition_cache</span><span class="o">.</span><span class="n">_nailcount</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parentnode</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                 <span class="n">description</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">expectedrows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chunkshape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">byteorder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">track_times</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_v_new</span> <span class="o">=</span> <span class="n">new</span> <span class="o">=</span> <span class="n">description</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Is this the first time the node has been created?&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_new_title</span> <span class="o">=</span> <span class="n">title</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;New title for this node.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_new_filters</span> <span class="o">=</span> <span class="n">filters</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;New filter properties for this node.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extdim</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># Tables only have one dimension currently</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The index of the enlargeable dimension (always 0 for tables).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_recarray</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A structured array to be stored in the table.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rabyteorder</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The computed byteorder of the self._v_recarray.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">expectedrows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">expectedrows</span> <span class="o">=</span> <span class="n">parentnode</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;EXPECTED_ROWS_TABLE&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_expectedrows</span> <span class="o">=</span> <span class="n">expectedrows</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The expected number of rows to be stored in the table.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span> <span class="o">=</span> <span class="n">SizeType</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The current number of rows in the table.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A Description instance (see :ref:`DescriptionClassDescr`)</span>
<span class="sd">        reflecting the structure of the table.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time64colnames</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The names of ``Time64`` columns.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strcolnames</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The names of ``String`` columns.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_colenums</span> <span class="o">=</span> <span class="p">{}</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maps the name of an enumerated column to its ``Enum`` instance.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_chunkshape</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Private storage for the `chunkshape` property of the leaf.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">indexed</span> <span class="o">=</span> <span class="kc">False</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Does this table have any indexed columns?&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indexedrows</span> <span class="o">=</span> <span class="mi">0</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of rows indexed in disk.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsaved_indexedrows</span> <span class="o">=</span> <span class="mi">0</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of rows indexed in memory but still not in disk.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_listoldindexes</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The list of columns with old indexes.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_autoindex</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Private variable that caches the value for autoindex.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A list containing the names of *top-level* columns in the table.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colpathnames</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A list containing the pathnames of *bottom-level* columns in the</span>
<span class="sd">        table.</span>

<span class="sd">        These are the leaf columns obtained when walking the</span>
<span class="sd">        table description left-to-right, bottom-first.  Columns inside a</span>
<span class="sd">        nested column have slashes (/) separating name components in</span>
<span class="sd">        their pathname.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colinstances</span> <span class="o">=</span> <span class="p">{}</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maps the name of a column to its Column (see</span>
<span class="sd">        :ref:`ColumnClassDescr`) or Cols (see :ref:`ColsClassDescr`)</span>
<span class="sd">        instance.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coldescrs</span> <span class="o">=</span> <span class="p">{}</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maps the name of a column to its Col description (see</span>
<span class="sd">        :ref:`ColClassDescr`).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coltypes</span> <span class="o">=</span> <span class="p">{}</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maps the name of a column to its PyTables data type.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coldtypes</span> <span class="o">=</span> <span class="p">{}</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maps the name of a column to its NumPy data type.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coldflts</span> <span class="o">=</span> <span class="p">{}</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maps the name of a column to its default value.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colindexed</span> <span class="o">=</span> <span class="p">{}</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Is the column which name is used as a key indexed?&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_use_index</span> <span class="o">=</span> <span class="kc">False</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether an index can be used or not in a search.  Boolean.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_where_condition</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Condition function and argument list for selection of values.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seqcache_key</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The key under which to save a query&#39;s results (list of row indexes)</span>
<span class="sd">        or None to not save.&quot;&quot;&quot;</span>
        <span class="n">max_slots</span> <span class="o">=</span> <span class="n">parentnode</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;COND_CACHE_SLOTS&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_condition_cache</span> <span class="o">=</span> <span class="n">CacheDict</span><span class="p">(</span><span class="n">max_slots</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cache of already compiled conditions.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exprvars_cache</span> <span class="o">=</span> <span class="p">{}</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cache of variables participating in numexpr expressions.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enabled_indexing_in_queries</span> <span class="o">=</span> <span class="kc">True</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Is indexing enabled in queries?  *Use only for testing.*&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_empty_array_cache</span> <span class="o">=</span> <span class="p">{}</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cache of empty arrays.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_v_dtype</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The NumPy datatype fopr this table.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A Cols instance that provides *natural naming* access to non-nested</span>
<span class="sd">        (Column, see :ref:`ColumnClassDescr`) and nested (Cols, see</span>
<span class="sd">        :ref:`ColsClassDescr`) columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dirtycache</span> <span class="o">=</span> <span class="kc">True</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the data caches are dirty or not. Initially set to yes.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_descflavor</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Temporarily keeps the flavor of a description with data.&quot;&quot;&quot;</span>

        <span class="c1"># Initialize this object in case is a new Table</span>

        <span class="c1"># Try purely descriptive description objects.</span>
        <span class="k">if</span> <span class="n">new</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">description</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># Dictionary case</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">Description</span><span class="p">(</span><span class="n">description</span><span class="p">,</span>
                                           <span class="n">ptparams</span><span class="o">=</span><span class="n">parentnode</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">new</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">description</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">IsDescription</span><span class="p">)</span>
                      <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">description</span><span class="p">,</span> <span class="n">IsDescription</span><span class="p">)):</span>
            <span class="c1"># IsDescription subclass case</span>
            <span class="n">descr</span> <span class="o">=</span> <span class="n">description</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">Description</span><span class="p">(</span><span class="n">descr</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
                                           <span class="n">ptparams</span><span class="o">=</span><span class="n">parentnode</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">new</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">description</span><span class="p">,</span> <span class="n">Description</span><span class="p">):</span>
            <span class="c1"># It is a Description instance already</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">description</span>

        <span class="c1"># No description yet?</span>
        <span class="k">if</span> <span class="n">new</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Try NumPy dtype instances</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">description</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="n">tup</span> <span class="o">=</span> <span class="n">descr_from_dtype</span><span class="p">(</span><span class="n">description</span><span class="p">,</span>
                                       <span class="n">ptparams</span><span class="o">=</span><span class="n">parentnode</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rabyteorder</span> <span class="o">=</span> <span class="n">tup</span>

        <span class="c1"># No description yet?</span>
        <span class="k">if</span> <span class="n">new</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Try structured array description objects.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_descflavor</span> <span class="o">=</span> <span class="n">flavor</span> <span class="o">=</span> <span class="n">flavor_of</span><span class="p">(</span><span class="n">description</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># probably not an array</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">flavor</span> <span class="o">==</span> <span class="s1">&#39;python&#39;</span><span class="p">:</span>
                    <span class="n">nparray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">description</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nparray</span> <span class="o">=</span> <span class="n">array_as_internal</span><span class="p">(</span><span class="n">description</span><span class="p">,</span> <span class="n">flavor</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span> <span class="o">=</span> <span class="n">nrows</span> <span class="o">=</span> <span class="n">SizeType</span><span class="p">(</span><span class="n">nparray</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="c1"># If `self._v_recarray` is set, it will be used as the</span>
                <span class="c1"># initial buffer.</span>
                <span class="k">if</span> <span class="n">nrows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_v_recarray</span> <span class="o">=</span> <span class="n">nparray</span>
                <span class="n">tup</span> <span class="o">=</span> <span class="n">descr_from_dtype</span><span class="p">(</span><span class="n">nparray</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                       <span class="n">ptparams</span><span class="o">=</span><span class="n">parentnode</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rabyteorder</span> <span class="o">=</span> <span class="n">tup</span>

        <span class="c1"># No description yet?</span>
        <span class="k">if</span> <span class="n">new</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;the ``description`` argument is not of a supported type: &quot;</span>
                <span class="s2">&quot;``IsDescription`` subclass, ``Description`` instance, &quot;</span>
                <span class="s2">&quot;dictionary, or structured array&quot;</span><span class="p">)</span>

        <span class="c1"># Check the chunkshape parameter</span>
        <span class="k">if</span> <span class="n">new</span> <span class="ow">and</span> <span class="n">chunkshape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunkshape</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
                <span class="n">chunkshape</span> <span class="o">=</span> <span class="p">(</span><span class="n">chunkshape</span><span class="p">,)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">chunkshape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">chunkshape</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;`chunkshape` parameter must be an integer or sequence &quot;</span>
                    <span class="s2">&quot;and you passed a </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">chunkshape</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunkshape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`chunkshape` rank (length) must be 1: </span><span class="si">%r</span><span class="s2">&quot;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="n">chunkshape</span><span class="p">,))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_chunkshape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">SizeType</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">chunkshape</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parentnode</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">byteorder</span><span class="p">,</span> <span class="n">_log</span><span class="p">,</span>
                         <span class="n">track_times</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_g_post_init_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># We are putting here the index-related issues</span>
        <span class="c1"># as well as filling general info for table</span>
        <span class="c1"># This is needed because we need first the index objects created</span>

        <span class="c1"># First, get back the flavor of input data (if any) for</span>
        <span class="c1"># `Leaf._g_post_init_hook()`.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flavor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_descflavor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_descflavor</span><span class="p">,</span> <span class="kc">None</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_g_post_init_hook</span><span class="p">()</span>

        <span class="c1"># Create a cols accessor.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="n">Cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>

        <span class="c1"># Place the `Cols` and `Column` objects into `self.colinstances`.</span>
        <span class="n">colinstances</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colinstances</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
        <span class="k">for</span> <span class="n">colpathname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">_v_pathnames</span><span class="p">:</span>
            <span class="n">colinstances</span><span class="p">[</span><span class="n">colpathname</span><span class="p">]</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="n">_g_col</span><span class="p">(</span><span class="n">colpathname</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_new</span><span class="p">:</span>
            <span class="c1"># Columns are never indexed on creation.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">colindexed</span> <span class="o">=</span> <span class="p">{</span><span class="n">cpn</span><span class="p">:</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">cpn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colpathnames</span><span class="p">}</span>
            <span class="k">return</span>

        <span class="c1"># The following code is only for opened tables.</span>

        <span class="c1"># Do the indexes group exist?</span>
        <span class="n">indexesgrouppath</span> <span class="o">=</span> <span class="n">_index_pathname_of</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">igroup</span> <span class="o">=</span> <span class="n">indexesgrouppath</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span>
        <span class="n">oldindexes</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">colobj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">_f_walk</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s2">&quot;Col&quot;</span><span class="p">):</span>
            <span class="n">colname</span> <span class="o">=</span> <span class="n">colobj</span><span class="o">.</span><span class="n">_v_pathname</span>
            <span class="c1"># Is this column indexed?</span>
            <span class="k">if</span> <span class="n">igroup</span><span class="p">:</span>
                <span class="n">indexname</span> <span class="o">=</span> <span class="n">_index_pathname_of_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colname</span><span class="p">)</span>
                <span class="n">indexed</span> <span class="o">=</span> <span class="n">indexname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">colindexed</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span> <span class="o">=</span> <span class="n">indexed</span>
                <span class="k">if</span> <span class="n">indexed</span><span class="p">:</span>
                    <span class="n">column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">_g_col</span><span class="p">(</span><span class="n">colname</span><span class="p">)</span>
                    <span class="n">indexobj</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">index</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexobj</span><span class="p">,</span> <span class="n">OldIndex</span><span class="p">):</span>
                        <span class="n">indexed</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Not a vaild index</span>
                        <span class="n">oldindexes</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_listoldindexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">colname</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Tell the condition cache about columns with dirty</span>
                        <span class="c1"># indexes.</span>
                        <span class="k">if</span> <span class="n">indexobj</span><span class="o">.</span><span class="n">dirty</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_condition_cache</span><span class="o">.</span><span class="n">nail</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indexed</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">colindexed</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">indexed</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indexed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">oldindexes</span><span class="p">:</span>  <span class="c1"># this should only appear under 2.x Pro</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;table ``</span><span class="si">%s</span><span class="s2">`` has column indexes with PyTables 1.x format. &quot;</span>
                <span class="s2">&quot;Unfortunately, this format is not supported in &quot;</span>
                <span class="s2">&quot;PyTables 2.x series. Note that you can use the &quot;</span>
                <span class="s2">&quot;``ptrepack`` utility in order to recreate the indexes. &quot;</span>
                <span class="s2">&quot;The 1.x indexed columns found are: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listoldindexes</span><span class="p">),</span>
                <span class="n">OldIndexWarning</span><span class="p">)</span>

        <span class="c1"># It does not matter to which column &#39;indexobj&#39; belongs,</span>
        <span class="c1"># since their respective index objects share</span>
        <span class="c1"># the same number of elements.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indexedrows</span> <span class="o">=</span> <span class="n">indexobj</span><span class="o">.</span><span class="n">nelements</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unsaved_indexedrows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexedrows</span>
            <span class="c1"># Put the autoindex value in a cache variable</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_autoindex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoindex</span>

    <span class="k">def</span> <span class="nf">_calc_nrowsinbuf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the number of rows that fits on a PyTables buffer.&quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">params</span>
        <span class="c1"># Compute the nrowsinbuf</span>
        <span class="n">rowsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rowsize</span>
        <span class="n">buffersize</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;IO_BUFFER_SIZE&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rowsize</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nrowsinbuf</span> <span class="o">=</span> <span class="n">buffersize</span> <span class="o">//</span> <span class="n">rowsize</span>
            <span class="c1"># The number of rows in buffer needs to be an exact multiple of</span>
            <span class="c1"># chunkshape[0] for queries using indexed columns.</span>
            <span class="c1"># Fixes #319 and probably #409 too.</span>
            <span class="n">nrowsinbuf</span> <span class="o">-=</span> <span class="n">nrowsinbuf</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunkshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nrowsinbuf</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># tableextension.pyx performs an assertion</span>
        <span class="c1"># to make sure nrowsinbuf is greater than or</span>
        <span class="c1"># equal to the chunksize.</span>
        <span class="c1"># See gh-206 and gh-238</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunkshape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nrowsinbuf</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunkshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">nrowsinbuf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunkshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Safeguard against row sizes being extremely large</span>
        <span class="k">if</span> <span class="n">nrowsinbuf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nrowsinbuf</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1"># If rowsize is too large, issue a Performance warning</span>
            <span class="n">maxrowsize</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;BUFFER_TIMES&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">buffersize</span>
            <span class="k">if</span> <span class="n">rowsize</span> <span class="o">&gt;</span> <span class="n">maxrowsize</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">The Table ``</span><span class="si">%s</span><span class="s2">`` is exceeding the maximum recommended rowsize (</span><span class="si">%d</span><span class="s2"> bytes);</span>
<span class="s2">be ready to see PyTables asking for *lots* of memory and possibly slow</span>
<span class="s2">I/O.  You may want to reduce the rowsize by trimming the value of</span>
<span class="s2">dimensions that are orthogonal (and preferably close) to the *main*</span>
<span class="s2">dimension of this leave.  Alternatively, in case you have specified a</span>
<span class="s2">very small/large chunksize, you may want to increase/decrease it.&quot;&quot;&quot;</span>
                              <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span> <span class="n">maxrowsize</span><span class="p">),</span>
                              <span class="n">PerformanceWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nrowsinbuf</span>

    <span class="k">def</span> <span class="nf">_getemptyarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="c1"># Acts as a cache for empty arrays</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_empty_array_cache</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_empty_array_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_empty_array_cache</span><span class="p">[</span>
                <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">arr</span>

    <span class="k">def</span> <span class="nf">_get_container</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the appropriate buffer for data depending on table</span>
<span class="sd">        nestedness.&quot;&quot;&quot;</span>

        <span class="c1"># This is *much* faster than the numpy.rec.array counterpart</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_type_col_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a list containing &#39;type_&#39; column names.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">colobj</span><span class="o">.</span><span class="n">_v_pathname</span>
                <span class="k">for</span> <span class="n">colobj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">_f_walk</span><span class="p">(</span><span class="s1">&#39;Col&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">colobj</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">type_</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_enum_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return mapping from enumerated column names to `Enum` instances.&quot;&quot;&quot;</span>

        <span class="n">enumMap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">colobj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">_f_walk</span><span class="p">(</span><span class="s1">&#39;Col&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">colobj</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;enum&#39;</span><span class="p">:</span>
                <span class="n">enumMap</span><span class="p">[</span><span class="n">colobj</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">]</span> <span class="o">=</span> <span class="n">colobj</span><span class="o">.</span><span class="n">enum</span>
        <span class="k">return</span> <span class="n">enumMap</span>

    <span class="k">def</span> <span class="nf">_g_create</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new table on disk.&quot;&quot;&quot;</span>

        <span class="c1"># Warning against assigning too much columns...</span>
        <span class="c1"># F. Alted 2005-06-05</span>
        <span class="n">maxColumns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;MAX_COLUMNS&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">_v_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxColumns</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;table ``</span><span class="si">%s</span><span class="s2">`` is exceeding the recommended &quot;</span>
                <span class="s2">&quot;maximum number of columns (</span><span class="si">%d</span><span class="s2">); &quot;</span>
                <span class="s2">&quot;be ready to see PyTables asking for *lots* of memory &quot;</span>
                <span class="s2">&quot;and possibly slow I/O&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span> <span class="n">maxColumns</span><span class="p">),</span>
                <span class="n">PerformanceWarning</span><span class="p">)</span>

        <span class="c1"># 1. Create the HDF5 table (some parameters need to be computed).</span>

        <span class="c1"># Fix the byteorder of the recarray and update the number of</span>
        <span class="c1"># expected rows if necessary</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_recarray</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_recarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g_fix_byteorder_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_recarray</span><span class="p">,</span>
                                                          <span class="bp">self</span><span class="o">.</span><span class="n">_rabyteorder</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_recarray</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_expectedrows</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_v_expectedrows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_recarray</span><span class="p">)</span>
        <span class="c1"># Compute a sensible chunkshape</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_chunkshape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_chunkshape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_chunkshape</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_v_expectedrows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rowsize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rowsize</span><span class="p">)</span>
        <span class="c1"># Correct the byteorder, if still needed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">byteorder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span>

        <span class="c1"># Cache some data which is already in the description.</span>
        <span class="c1"># This is necessary to happen before creation time in order</span>
        <span class="c1"># to be able to populate the self._v_wdflts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache_description_data</span><span class="p">()</span>

        <span class="c1"># After creating the table, ``self._v_objectid`` needs to be</span>
        <span class="c1"># set because it is needed for setting attributes afterwards.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_objectid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_table</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_new_title</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">complib</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">obversion</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_recarray</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># not useful anymore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rabyteorder</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># not useful anymore</span>

        <span class="c1"># 2. Compute or get chunk shape and buffer size parameters.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nrowsinbuf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_nrowsinbuf</span><span class="p">()</span>

        <span class="c1"># 3. Get field fill attributes from the table description and</span>
        <span class="c1">#    set them on disk.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;PYTABLES_SYS_ATTRS&#39;</span><span class="p">]:</span>
            <span class="n">set_attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">_g__setattr</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">colobj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">_f_walk</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s2">&quot;Col&quot;</span><span class="p">)):</span>
                <span class="n">fieldname</span> <span class="o">=</span> <span class="s2">&quot;FIELD_</span><span class="si">%d</span><span class="s2">_FILL&quot;</span> <span class="o">%</span> <span class="n">i</span>
                <span class="n">set_attr</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">colobj</span><span class="o">.</span><span class="n">dflt</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_objectid</span>

    <span class="k">def</span> <span class="nf">_g_open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Opens a table from disk and read the metadata on it.</span>

<span class="sd">        Creates an user description on the flight to easy the access to</span>
<span class="sd">        the actual data.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># 1. Open the HDF5 table and get some data from it.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_objectid</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">chunksize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_expectedrows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span>  <span class="c1"># the actual number of rows</span>

        <span class="c1"># 2. Create an instance description to host the record fields.</span>
        <span class="n">validate</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_isPTFile</span>  <span class="c1"># only for non-PyTables files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">Description</span><span class="p">(</span><span class="n">description</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="n">validate</span><span class="p">,</span>
                                       <span class="n">ptparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># 3. Compute or get chunk shape and buffer size parameters.</span>
        <span class="k">if</span> <span class="n">chunksize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_chunkshape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_chunkshape</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_v_expectedrows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rowsize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rowsize</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_chunkshape</span> <span class="o">=</span> <span class="p">(</span><span class="n">chunksize</span><span class="p">,)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nrowsinbuf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_nrowsinbuf</span><span class="p">()</span>

        <span class="c1"># 4. If there are field fill attributes, get them from disk and</span>
        <span class="c1">#    set them in the table description.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;PYTABLES_SYS_ATTRS&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="s2">&quot;FIELD_0_FILL&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">_f_list</span><span class="p">(</span><span class="s2">&quot;sys&quot;</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">get_attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="fm">__getattr__</span>
                <span class="k">for</span> <span class="n">objcol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">_f_walk</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s2">&quot;Col&quot;</span><span class="p">):</span>
                    <span class="n">colname</span> <span class="o">=</span> <span class="n">objcol</span><span class="o">.</span><span class="n">_v_pathname</span>
                    <span class="c1"># Get the default values for each column</span>
                    <span class="n">fieldname</span> <span class="o">=</span> <span class="s2">&quot;FIELD_</span><span class="si">%s</span><span class="s2">_FILL&quot;</span> <span class="o">%</span> <span class="n">i</span>
                    <span class="n">defval</span> <span class="o">=</span> <span class="n">get_attr</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">defval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">objcol</span><span class="o">.</span><span class="n">dflt</span> <span class="o">=</span> <span class="n">defval</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;could not load default value &quot;</span>
                                      <span class="s2">&quot;for the ``</span><span class="si">%s</span><span class="s2">`` column of table ``</span><span class="si">%s</span><span class="s2">``; &quot;</span>
                                      <span class="s2">&quot;using ``</span><span class="si">%r</span><span class="s2">`` instead&quot;</span>
                                      <span class="o">%</span> <span class="p">(</span><span class="n">colname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span>
                                          <span class="n">objcol</span><span class="o">.</span><span class="n">dflt</span><span class="p">))</span>
                        <span class="n">defval</span> <span class="o">=</span> <span class="n">objcol</span><span class="o">.</span><span class="n">dflt</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># Set also the correct value in the desc._v_dflts dictionary</span>
                <span class="k">for</span> <span class="n">descr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">_f_walk</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s2">&quot;Description&quot;</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">descr</span><span class="o">.</span><span class="n">_v_names</span><span class="p">:</span>
                        <span class="n">objcol</span> <span class="o">=</span> <span class="n">descr</span><span class="o">.</span><span class="n">_v_colobjects</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">objcol</span><span class="p">,</span> <span class="n">Col</span><span class="p">):</span>
                            <span class="n">descr</span><span class="o">.</span><span class="n">_v_dflts</span><span class="p">[</span><span class="n">objcol</span><span class="o">.</span><span class="n">_v_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">objcol</span><span class="o">.</span><span class="n">dflt</span>

        <span class="c1"># 5. Cache some data which is already in the description.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache_description_data</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_objectid</span>

    <span class="k">def</span> <span class="nf">_cache_description_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cache some data which is already in the description.</span>

<span class="sd">        Some information is extracted from `self.description` to build</span>
<span class="sd">        some useful (but redundant) structures:</span>

<span class="sd">        * `self.colnames`</span>
<span class="sd">        * `self.colpathnames`</span>
<span class="sd">        * `self.coldescrs`</span>
<span class="sd">        * `self.coltypes`</span>
<span class="sd">        * `self.coldtypes`</span>
<span class="sd">        * `self.coldflts`</span>
<span class="sd">        * `self._v_dtype`</span>
<span class="sd">        * `self._time64colnames`</span>
<span class="sd">        * `self._strcolnames`</span>
<span class="sd">        * `self._colenums`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">_v_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colpathnames</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">col</span><span class="o">.</span><span class="n">_v_pathname</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">_f_walk</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;_v_names&#39;</span><span class="p">)]</span>  <span class="c1"># bottom-level</span>

        <span class="c1"># Find ``time64`` column names.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time64colnames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_type_col_names</span><span class="p">(</span><span class="s1">&#39;time64&#39;</span><span class="p">)</span>
        <span class="c1"># Find ``string`` column names.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strcolnames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_type_col_names</span><span class="p">(</span><span class="s1">&#39;string&#39;</span><span class="p">)</span>
        <span class="c1"># Get a mapping of enumerated columns to their `Enum` instances.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_colenums</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_enum_map</span><span class="p">()</span>

        <span class="c1"># Get info about columns</span>
        <span class="k">for</span> <span class="n">colobj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">_f_walk</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s2">&quot;Col&quot;</span><span class="p">):</span>
            <span class="n">colname</span> <span class="o">=</span> <span class="n">colobj</span><span class="o">.</span><span class="n">_v_pathname</span>
            <span class="c1"># Get the column types, types and defaults</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coldescrs</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span> <span class="o">=</span> <span class="n">colobj</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coltypes</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span> <span class="o">=</span> <span class="n">colobj</span><span class="o">.</span><span class="n">type</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coldtypes</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span> <span class="o">=</span> <span class="n">colobj</span><span class="o">.</span><span class="n">dtype</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coldflts</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span> <span class="o">=</span> <span class="n">colobj</span><span class="o">.</span><span class="n">dflt</span>

        <span class="c1"># Assign _v_dtype for this table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">_v_dtype</span>

    <span class="k">def</span> <span class="nf">_get_column_instance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colpathname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the instance of the column with the given `colpathname`.</span>

<span class="sd">        If the column does not exist in the table, a `KeyError` is</span>
<span class="sd">        raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
                <span class="nb">getattr</span><span class="p">,</span> <span class="n">colpathname</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;table ``</span><span class="si">%s</span><span class="s2">`` does not have a column named ``</span><span class="si">%s</span><span class="s2">``&quot;</span>
                           <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span> <span class="n">colpathname</span><span class="p">))</span>

    <span class="n">_check_column</span> <span class="o">=</span> <span class="n">_get_column_instance</span>

    <span class="k">def</span> <span class="nf">_disable_indexing_in_queries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Force queries not to use indexing.</span>

<span class="sd">        *Use only for testing.*</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enabled_indexing_in_queries</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c1"># already disabled</span>
        <span class="c1"># The nail avoids setting/getting compiled conditions in/from</span>
        <span class="c1"># the cache where indexing is used.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_condition_cache</span><span class="o">.</span><span class="n">nail</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enabled_indexing_in_queries</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_enable_indexing_in_queries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Allow queries to use indexing.</span>

<span class="sd">        *Use only for testing.*</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enabled_indexing_in_queries</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c1"># already enabled</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_condition_cache</span><span class="o">.</span><span class="n">unnail</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enabled_indexing_in_queries</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_required_expr_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">uservars</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the variables required by the `expression`.</span>

<span class="sd">        A new dictionary defining the variables used in the `expression`</span>
<span class="sd">        is returned.  Required variables are first looked up in the</span>
<span class="sd">        `uservars` mapping, then in the set of top-level columns of the</span>
<span class="sd">        table.  Unknown variables cause a `NameError` to be raised.</span>

<span class="sd">        When `uservars` is `None`, the local and global namespace where</span>
<span class="sd">        the API callable which uses this method is called is sought</span>
<span class="sd">        instead.  This mechanism will not work as expected if this</span>
<span class="sd">        method is not used *directly* from an API callable.  To disable</span>
<span class="sd">        this mechanism, just specify a mapping as `uservars`.</span>

<span class="sd">        Nested columns and columns from other tables are not allowed</span>
<span class="sd">        (`TypeError` and `ValueError` are raised, respectively).  Also,</span>
<span class="sd">        non-column variable values are converted to NumPy arrays.</span>

<span class="sd">        `depth` specifies the depth of the frame in order to reach local</span>
<span class="sd">        or global variables.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the names of variables used in the expression.</span>
        <span class="n">exprvarscache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exprvars_cache</span>
        <span class="k">if</span> <span class="n">expression</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exprvarscache</span><span class="p">:</span>
            <span class="c1"># Protection against growing the cache too much</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">exprvarscache</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">256</span><span class="p">:</span>
                <span class="c1"># Remove 10 (arbitrary) elements from the cache</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">exprvarscache</span><span class="p">)[:</span><span class="mi">10</span><span class="p">]:</span>
                    <span class="k">del</span> <span class="n">exprvarscache</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">cexpr</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="s1">&#39;&lt;string&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;eval&#39;</span><span class="p">)</span>
            <span class="n">exprvars</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">cexpr</span><span class="o">.</span><span class="n">co_names</span>
                        <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="s1">&#39;False&#39;</span><span class="p">,</span> <span class="s1">&#39;True&#39;</span><span class="p">]</span>
                        <span class="ow">and</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ne</span><span class="o">.</span><span class="n">expressions</span><span class="o">.</span><span class="n">functions</span><span class="p">]</span>
            <span class="n">exprvarscache</span><span class="p">[</span><span class="n">expression</span><span class="p">]</span> <span class="o">=</span> <span class="n">exprvars</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exprvars</span> <span class="o">=</span> <span class="n">exprvarscache</span><span class="p">[</span><span class="n">expression</span><span class="p">]</span>

        <span class="c1"># Get the local and global variable mappings of the user frame</span>
        <span class="c1"># if no mapping has been explicitly given for user variables.</span>
        <span class="n">user_locals</span><span class="p">,</span> <span class="n">user_globals</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">uservars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We use specified depth to get the frame where the API</span>
            <span class="c1"># callable using this method is called.  For instance:</span>
            <span class="c1">#</span>
            <span class="c1"># * ``table._required_expr_vars()`` (depth 0) is called by</span>
            <span class="c1"># * ``table._where()`` (depth 1) is called by</span>
            <span class="c1"># * ``table.where()`` (depth 2) is called by</span>
            <span class="c1"># * user-space functions (depth 3)</span>
            <span class="n">user_frame</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="n">depth</span><span class="p">)</span>
            <span class="n">user_locals</span> <span class="o">=</span> <span class="n">user_frame</span><span class="o">.</span><span class="n">f_locals</span>
            <span class="n">user_globals</span> <span class="o">=</span> <span class="n">user_frame</span><span class="o">.</span><span class="n">f_globals</span>

        <span class="n">colinstances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colinstances</span>
        <span class="n">tblfile</span><span class="p">,</span> <span class="n">tblpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span>
        <span class="c1"># Look for the required variables first among the ones</span>
        <span class="c1"># explicitly provided by the user, then among implicit columns,</span>
        <span class="c1"># then among external variables (only if no explicit variables).</span>
        <span class="n">reqvars</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">exprvars</span><span class="p">:</span>
            <span class="c1"># Get the value.</span>
            <span class="k">if</span> <span class="n">uservars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">uservars</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">uservars</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">colinstances</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">colinstances</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">uservars</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">user_locals</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">user_locals</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">uservars</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">user_globals</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">user_globals</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;name ``</span><span class="si">%s</span><span class="s2">`` is not defined&quot;</span> <span class="o">%</span> <span class="n">var</span><span class="p">)</span>

            <span class="c1"># Check the value.</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s1">&#39;pathname&#39;</span><span class="p">):</span>  <span class="c1"># non-nested column</span>
                <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s2">&quot;variable ``</span><span class="si">%s</span><span class="s2">`` refers to &quot;</span>
                        <span class="s2">&quot;a multidimensional column, &quot;</span>
                        <span class="s2">&quot;not yet supported in conditions, sorry&quot;</span> <span class="o">%</span> <span class="n">var</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">_table_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">tblfile</span> <span class="ow">or</span>
                        <span class="n">val</span><span class="o">.</span><span class="n">_table_path</span> <span class="o">!=</span> <span class="n">tblpath</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;variable ``</span><span class="si">%s</span><span class="s2">`` refers to a column &quot;</span>
                                     <span class="s2">&quot;which is not part of table ``</span><span class="si">%s</span><span class="s2">``&quot;</span>
                                     <span class="o">%</span> <span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">tblpath</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="s1">&#39;u8&#39;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s2">&quot;variable ``</span><span class="si">%s</span><span class="s2">`` refers to &quot;</span>
                        <span class="s2">&quot;a 64-bit unsigned integer column, &quot;</span>
                        <span class="s2">&quot;not yet supported in conditions, sorry; &quot;</span>
                        <span class="s2">&quot;please use regular Python selections&quot;</span> <span class="o">%</span> <span class="n">var</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s1">&#39;_v_colpathnames&#39;</span><span class="p">):</span>  <span class="c1"># nested column</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;variable ``</span><span class="si">%s</span><span class="s2">`` refers to a nested column, &quot;</span>
                    <span class="s2">&quot;not allowed in conditions&quot;</span> <span class="o">%</span> <span class="n">var</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># only non-column values are converted to arrays</span>
                <span class="c1"># XXX: not 100% sure about this</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="n">reqvars</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">reqvars</span>

    <span class="k">def</span> <span class="nf">_get_condition_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">condvars</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the condition cache key for `condition` with `condvars`.</span>

<span class="sd">        Currently, the key is a tuple of `condition`, column variables</span>
<span class="sd">        names, normal variables names, column paths and variable paths</span>
<span class="sd">        (all are tuples).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Variable names for column and normal variables.</span>
        <span class="n">colnames</span><span class="p">,</span> <span class="n">varnames</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="c1"># Column paths and types for each of the previous variable.</span>
        <span class="n">colpaths</span><span class="p">,</span> <span class="n">vartypes</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">condvars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s1">&#39;pathname&#39;</span><span class="p">):</span>  <span class="c1"># column</span>
                <span class="n">colnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
                <span class="n">colpaths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">pathname</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># array</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">varnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
                    <span class="n">vartypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ne</span><span class="o">.</span><span class="n">necompiler</span><span class="o">.</span><span class="n">getType</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>  <span class="c1"># expensive</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="c1"># This is more clear than the error given by Numexpr.</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;variable ``</span><span class="si">%s</span><span class="s2">`` has data type ``</span><span class="si">%s</span><span class="s2">``, &quot;</span>
                                    <span class="s2">&quot;not allowed in conditions&quot;</span>
                                    <span class="o">%</span> <span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="n">colnames</span><span class="p">,</span> <span class="n">varnames</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">colnames</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">varnames</span><span class="p">)</span>
        <span class="n">colpaths</span><span class="p">,</span> <span class="n">vartypes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">colpaths</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">vartypes</span><span class="p">)</span>
        <span class="n">condkey</span> <span class="o">=</span> <span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">colnames</span><span class="p">,</span> <span class="n">varnames</span><span class="p">,</span> <span class="n">colpaths</span><span class="p">,</span> <span class="n">vartypes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">condkey</span>

    <span class="k">def</span> <span class="nf">_compile_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">condvars</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compile the `condition` and extract usable index conditions.</span>

<span class="sd">        This method returns an instance of ``CompiledCondition``.  See</span>
<span class="sd">        the ``compile_condition()`` function in the ``conditions``</span>
<span class="sd">        module for more information about the compilation process.</span>

<span class="sd">        This method makes use of the condition cache when possible.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Look up the condition in the condition cache.</span>
        <span class="n">condcache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition_cache</span>
        <span class="n">condkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_condition_key</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">condvars</span><span class="p">)</span>
        <span class="n">compiled</span> <span class="o">=</span> <span class="n">condcache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">condkey</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">compiled</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">compiled</span><span class="o">.</span><span class="n">with_replaced_vars</span><span class="p">(</span><span class="n">condvars</span><span class="p">)</span>  <span class="c1"># bingo!</span>

        <span class="c1"># Bad luck, the condition must be parsed and compiled.</span>
        <span class="c1"># Fortunately, the key provides some valuable information. ;)</span>
        <span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">colnames</span><span class="p">,</span> <span class="n">varnames</span><span class="p">,</span> <span class="n">colpaths</span><span class="p">,</span> <span class="n">vartypes</span><span class="p">)</span> <span class="o">=</span> <span class="n">condkey</span>

        <span class="c1"># Extract more information from referenced columns.</span>

        <span class="c1"># start with normal variables</span>
        <span class="n">typemap</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">varnames</span><span class="p">,</span> <span class="n">vartypes</span><span class="p">)))</span>
        <span class="n">indexedcols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">colname</span> <span class="ow">in</span> <span class="n">colnames</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">condvars</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span>

            <span class="c1"># Extract types from *all* the given variables.</span>
            <span class="n">coltype</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span>
            <span class="n">typemap</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span> <span class="o">=</span> <span class="n">_nxtype_from_nptype</span><span class="p">[</span><span class="n">coltype</span><span class="p">]</span>

            <span class="c1"># Get the set of columns with usable indexes.</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_enabled_indexing_in_queries</span>  <span class="c1"># no in-kernel searches</span>
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">colindexed</span><span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">pathname</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">col</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">dirty</span><span class="p">):</span>
                <span class="n">indexedcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">colname</span><span class="p">)</span>

        <span class="n">indexedcols</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">indexedcols</span><span class="p">)</span>
        <span class="c1"># Now let ``compile_condition()`` do the Numexpr-related job.</span>
        <span class="n">compiled</span> <span class="o">=</span> <span class="n">compile_condition</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">typemap</span><span class="p">,</span> <span class="n">indexedcols</span><span class="p">)</span>

        <span class="c1"># Check that there actually are columns in the condition.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">compiled</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">colnames</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;there are no columns taking part &quot;</span>
                             <span class="s2">&quot;in condition ``</span><span class="si">%s</span><span class="s2">``&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">condition</span><span class="p">,))</span>

        <span class="c1"># Store the compiled condition in the cache and return it.</span>
        <span class="n">condcache</span><span class="p">[</span><span class="n">condkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">compiled</span>
        <span class="k">return</span> <span class="n">compiled</span><span class="o">.</span><span class="n">with_replaced_vars</span><span class="p">(</span><span class="n">condvars</span><span class="p">)</span>

<div class="viewcode-block" id="Table.will_query_use_indexing">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.will_query_use_indexing">[docs]</a>
    <span class="k">def</span> <span class="nf">will_query_use_indexing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">condvars</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Will a query for the condition use indexing?</span>

<span class="sd">        The meaning of the condition and *condvars* arguments is the same as in</span>
<span class="sd">        the :meth:`Table.where` method. If condition can use indexing, this</span>
<span class="sd">        method returns a frozenset with the path names of the columns whose</span>
<span class="sd">        index is usable. Otherwise, it returns an empty list.</span>

<span class="sd">        This method is mainly intended for testing. Keep in mind that changing</span>
<span class="sd">        the set of indexed columns or their dirtiness may make this method</span>
<span class="sd">        return different values for the same arguments at different times.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Compile the condition and extract usable index conditions.</span>
        <span class="n">condvars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_required_expr_vars</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">condvars</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">compiled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compile_condition</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">condvars</span><span class="p">)</span>
        <span class="c1"># Return the columns in indexed expressions</span>
        <span class="n">idxcols</span> <span class="o">=</span> <span class="p">[</span><span class="n">condvars</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">pathname</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">compiled</span><span class="o">.</span><span class="n">index_variables</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">idxcols</span><span class="p">)</span></div>


<div class="viewcode-block" id="Table.where">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.where">[docs]</a>
    <span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">condvars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Iterate over values fulfilling a condition.</span>

<span class="sd">        This method returns a Row iterator (see :ref:`RowClassDescr`) which</span>
<span class="sd">        only selects rows in the table that satisfy the given condition (an</span>
<span class="sd">        expression-like string).</span>

<span class="sd">        The condvars mapping may be used to define the variable names appearing</span>
<span class="sd">        in the condition. condvars should consist of identifier-like strings</span>
<span class="sd">        pointing to Column (see :ref:`ColumnClassDescr`) instances *of this</span>
<span class="sd">        table*, or to other values (which will be converted to arrays). A</span>
<span class="sd">        default set of condition variables is provided where each top-level,</span>
<span class="sd">        non-nested column with an identifier-like name appears. Variables in</span>
<span class="sd">        condvars override the default ones.</span>

<span class="sd">        When condvars is not provided or None, the current local and global</span>
<span class="sd">        namespace is sought instead of condvars. The previous mechanism is</span>
<span class="sd">        mostly intended for interactive usage. To disable it, just specify a</span>
<span class="sd">        (maybe empty) mapping as condvars.</span>

<span class="sd">        If a range is supplied (by setting some of the start, stop or step</span>
<span class="sd">        parameters), only the rows in that range and fulfilling the condition</span>
<span class="sd">        are used. The meaning of the start, stop and step parameters is the</span>
<span class="sd">        same as for Python slices.</span>

<span class="sd">        When possible, indexed columns participating in the condition will be</span>
<span class="sd">        used to speed up the search. It is recommended that you place the</span>
<span class="sd">        indexed columns as left and out in the condition as possible. Anyway,</span>
<span class="sd">        this method has always better performance than regular Python</span>
<span class="sd">        selections on the table.</span>

<span class="sd">        You can mix this method with regular Python selections in order to</span>
<span class="sd">        support even more complex queries. It is strongly recommended that you</span>
<span class="sd">        pass the most restrictive condition as the parameter to this method if</span>
<span class="sd">        you want to achieve maximum performance.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            When in the middle of a table row iterator, you should not</span>
<span class="sd">            use methods that can change the number of rows in the table</span>
<span class="sd">            (like :meth:`Table.append` or :meth:`Table.remove_rows`) or</span>
<span class="sd">            unexpected errors will happen.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            passvalues = [ row[&#39;col3&#39;] for row in</span>
<span class="sd">                           table.where(&#39;(col1 &gt; 0) &amp; (col2 &lt;= 20)&#39;, step=5)</span>
<span class="sd">                           if your_function(row[&#39;col2&#39;]) ]</span>
<span class="sd">            print(&quot;Values that pass the cuts:&quot;, passvalues)</span>

<span class="sd">        .. note::</span>

<span class="sd">            A special care should be taken when the query condition includes</span>
<span class="sd">            string literals.</span>

<span class="sd">            Let&#39;s assume that the table ``table`` has the following</span>
<span class="sd">            structure::</span>

<span class="sd">                class Record(IsDescription):</span>
<span class="sd">                    col1 = StringCol(4)  # 4-character String of bytes</span>
<span class="sd">                    col2 = IntCol()</span>
<span class="sd">                    col3 = FloatCol()</span>

<span class="sd">            The type of &quot;col1&quot; corresponds to strings of bytes.</span>

<span class="sd">            Any condition involving &quot;col1&quot; should be written using the</span>
<span class="sd">            appropriate type for string literals in order to avoid</span>
<span class="sd">            :exc:`TypeError`\ s.</span>

<span class="sd">            The code below will fail with a :exc:`TypeError`::</span>

<span class="sd">                condition = &#39;col1 == &quot;AAAA&quot;&#39;</span>
<span class="sd">                for record in table.where(condition):  # TypeError in Python3</span>
<span class="sd">                    # do something with &quot;record&quot;</span>

<span class="sd">            The reason is that in Python 3 &quot;condition&quot; implies a comparison</span>
<span class="sd">            between a string of bytes (&quot;col1&quot; contents) and a unicode literal</span>
<span class="sd">            (&quot;AAAA&quot;).</span>

<span class="sd">            The correct way to write the condition is::</span>

<span class="sd">                condition = &#39;col1 == b&quot;AAAA&quot;&#39;</span>

<span class="sd">        .. versionchanged:: 3.0</span>
<span class="sd">           The start, stop and step parameters now behave like in slice.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_where</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">condvars</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_where</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">condvars</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Low-level counterpart of `self.where()`.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">tref</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;Entering table._where&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>
        <span class="c1"># Adjust the slice to be used.</span>
        <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_range_read</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">stop</span><span class="p">:</span>  <span class="c1"># empty range, reset conditions</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_use_index</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_where_condition</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">([])</span>

        <span class="c1"># Compile the condition and extract usable index conditions.</span>
        <span class="n">condvars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_required_expr_vars</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">condvars</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">compiled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compile_condition</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">condvars</span><span class="p">)</span>

        <span class="c1"># Can we use indexes?</span>
        <span class="k">if</span> <span class="n">compiled</span><span class="o">.</span><span class="n">index_expressions</span><span class="p">:</span>
            <span class="n">chunkmap</span> <span class="o">=</span> <span class="n">_table__where_indexed</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">compiled</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">condvars</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunkmap</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="c1"># If it is not a NumPy array it should be an iterator</span>
                <span class="c1"># Reset conditions</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_use_index</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_where_condition</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># ...and return the iterator</span>
                <span class="k">return</span> <span class="n">chunkmap</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chunkmap</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># default to an in-kernel query</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">condvars</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">compiled</span><span class="o">.</span><span class="n">parameters</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_where_condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">compiled</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">compiled</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">tableextension</span><span class="o">.</span><span class="n">Row</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">show_stats</span><span class="p">(</span><span class="s2">&quot;Exiting table._where&quot;</span><span class="p">,</span> <span class="n">tref</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">row</span><span class="o">.</span><span class="n">_iter</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">chunkmap</span><span class="o">=</span><span class="n">chunkmap</span><span class="p">)</span>

<div class="viewcode-block" id="Table.read_where">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.read_where">[docs]</a>
    <span class="k">def</span> <span class="nf">read_where</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">condvars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read table data fulfilling the given *condition*.</span>

<span class="sd">        This method is similar to :meth:`Table.read`, having their common</span>
<span class="sd">        arguments and return values the same meanings. However, only the rows</span>
<span class="sd">        fulfilling the *condition* are included in the result.</span>

<span class="sd">        The meaning of the other arguments is the same as in the</span>
<span class="sd">        :meth:`Table.where` method.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_open</span><span class="p">()</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">nrow</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">_where</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">condvars</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_where_condition</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># reset the conditions</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cstart</span><span class="p">,</span> <span class="n">cstop</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">cstop</span> <span class="o">-</span> <span class="n">cstart</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
                <span class="c1"># Chances for monotonically increasing row values. Refine.</span>
                <span class="n">inc_seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cstart</span><span class="p">,</span> <span class="n">cstop</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">inc_seq</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">cstart</span><span class="p">,</span> <span class="n">cstop</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="n">field</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_coordinates</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span></div>


<div class="viewcode-block" id="Table.append_where">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.append_where">[docs]</a>
    <span class="k">def</span> <span class="nf">append_where</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dstTable</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">condvars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Append rows fulfilling the condition to the dstTable table.</span>

<span class="sd">        dstTable must be capable of taking the rows resulting from the query,</span>
<span class="sd">        i.e. it must have columns with the expected names and compatible</span>
<span class="sd">        types. The meaning of the other arguments is the same as in the</span>
<span class="sd">        :meth:`Table.where` method.</span>

<span class="sd">        The number of rows appended to dstTable is returned as a result.</span>

<span class="sd">        .. versionchanged:: 3.0</span>
<span class="sd">           The *whereAppend* method has been renamed into *append_where*.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_open</span><span class="p">()</span>

        <span class="c1"># Check that the destination file is not in read-only mode.</span>
        <span class="n">dstTable</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_check_writable</span><span class="p">()</span>

        <span class="c1"># Row objects do not support nested columns, so we must iterate</span>
        <span class="c1"># over the flat column paths.  When rows support nesting,</span>
        <span class="c1"># ``self.colnames`` can be directly iterated upon.</span>
        <span class="n">colNames</span> <span class="o">=</span> <span class="p">[</span><span class="n">colName</span> <span class="k">for</span> <span class="n">colName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colpathnames</span><span class="p">]</span>
        <span class="n">dstRow</span> <span class="o">=</span> <span class="n">dstTable</span><span class="o">.</span><span class="n">row</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">condition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">srcRows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_where</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">condvars</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">srcRows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterrows</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">srcRow</span> <span class="ow">in</span> <span class="n">srcRows</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">colName</span> <span class="ow">in</span> <span class="n">colNames</span><span class="p">:</span>
                <span class="n">dstRow</span><span class="p">[</span><span class="n">colName</span><span class="p">]</span> <span class="o">=</span> <span class="n">srcRow</span><span class="p">[</span><span class="n">colName</span><span class="p">]</span>
            <span class="n">dstRow</span><span class="o">.</span><span class="n">append</span><span class="p">()</span>
            <span class="n">nrows</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">dstTable</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">nrows</span></div>


<div class="viewcode-block" id="Table.get_where_list">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.get_where_list">[docs]</a>
    <span class="k">def</span> <span class="nf">get_where_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">condvars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the row coordinates fulfilling the given condition.</span>

<span class="sd">        The coordinates are returned as a list of the current flavor.  sort</span>
<span class="sd">        means that you want to retrieve the coordinates ordered. The default is</span>
<span class="sd">        to not sort them.</span>

<span class="sd">        The meaning of the other arguments is the same as in the</span>
<span class="sd">        :meth:`Table.where` method.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_open</span><span class="p">()</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">nrow</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">_where</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">condvars</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)]</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">SizeType</span><span class="p">)</span>
        <span class="c1"># Reset the conditions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_where_condition</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">internal_to_flavor</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flavor</span><span class="p">)</span></div>


<div class="viewcode-block" id="Table.itersequence">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.itersequence">[docs]</a>
    <span class="k">def</span> <span class="nf">itersequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate over a sequence of row coordinates.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="s1">&#39;__getitem__&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Wrong &#39;sequence&#39; parameter type. Only sequences &quot;</span>
                            <span class="s2">&quot;are suported.&quot;</span><span class="p">)</span>
        <span class="c1"># start, stop and step are necessary for the new iterator for</span>
        <span class="c1"># coordinates, and perhaps it would be useful to add them as</span>
        <span class="c1"># parameters in the future (not now, because I&#39;ve just removed</span>
        <span class="c1"># the `sort` argument for 2.1).</span>
        <span class="c1">#</span>
        <span class="c1"># *Important note*: Negative values for step are not supported</span>
        <span class="c1"># for the general case, but only for the itersorted() and</span>
        <span class="c1"># read_sorted() purposes!  The self._process_range_read will raise</span>
        <span class="c1"># an appropiate error.</span>
        <span class="c1"># F. Alted 2008-09-18</span>
        <span class="c1"># A.V. 20130513: _process_range_read --&gt; _process_range</span>
        <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">stop</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">([])</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">tableextension</span><span class="o">.</span><span class="n">Row</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">row</span><span class="o">.</span><span class="n">_iter</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">sequence</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_check_sortby_csi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sortby</span><span class="p">,</span> <span class="n">checkCSI</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sortby</span><span class="p">,</span> <span class="n">Column</span><span class="p">):</span>
            <span class="n">icol</span> <span class="o">=</span> <span class="n">sortby</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sortby</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">icol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">_f_col</span><span class="p">(</span><span class="n">sortby</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;`sortby` can only be a `Column` or string object, &quot;</span>
                <span class="s2">&quot;but you passed an object of type: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">sortby</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">icol</span><span class="o">.</span><span class="n">is_indexed</span> <span class="ow">and</span> <span class="n">icol</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">checkCSI</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">icol</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_csi</span><span class="p">:</span>
                <span class="c1"># The index exists, but it is not a CSI one.</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Field `</span><span class="si">%s</span><span class="s2">` must have associated a CSI index &quot;</span>
                    <span class="s2">&quot;in table `</span><span class="si">%s</span><span class="s2">`, but the existing one is not. &quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">sortby</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">icol</span><span class="o">.</span><span class="n">index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Field `</span><span class="si">%s</span><span class="s2">` must have associated a &#39;full&#39; index &quot;</span>
                <span class="s2">&quot;in table `</span><span class="si">%s</span><span class="s2">`.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sortby</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>

<div class="viewcode-block" id="Table.itersorted">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.itersorted">[docs]</a>
    <span class="k">def</span> <span class="nf">itersorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sortby</span><span class="p">,</span> <span class="n">checkCSI</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate table data following the order of the index of sortby</span>
<span class="sd">        column.</span>

<span class="sd">        The sortby column must have associated a full index.  If you want to</span>
<span class="sd">        ensure a fully sorted order, the index must be a CSI one.  You may want</span>
<span class="sd">        to use the checkCSI argument in order to explicitly check for the</span>
<span class="sd">        existence of a CSI index.</span>

<span class="sd">        The meaning of the start, stop and step arguments is the same as in</span>
<span class="sd">        :meth:`Table.read`.</span>

<span class="sd">        .. versionchanged:: 3.0</span>
<span class="sd">           If the *start* parameter is provided and *stop* is None then the</span>
<span class="sd">           table is iterated from *start* to the last line.</span>
<span class="sd">           In PyTables &lt; 3.0 only one element was returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_sortby_csi</span><span class="p">(</span><span class="n">sortby</span><span class="p">,</span> <span class="n">checkCSI</span><span class="p">)</span>
        <span class="c1"># Adjust the slice to be used.</span>
        <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span>
                                                  <span class="n">warn_negstep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">stop</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">step</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">stop</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&gt;</span> <span class="n">step</span><span class="p">):</span>
            <span class="c1"># Fall-back action is to return an empty iterator</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">([])</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">tableextension</span><span class="o">.</span><span class="n">Row</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">row</span><span class="o">.</span><span class="n">_iter</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="Table.read_sorted">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.read_sorted">[docs]</a>
    <span class="k">def</span> <span class="nf">read_sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sortby</span><span class="p">,</span> <span class="n">checkCSI</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read table data following the order of the index of sortby column.</span>

<span class="sd">        The sortby column must have associated a full index.  If you want to</span>
<span class="sd">        ensure a fully sorted order, the index must be a CSI one.  You may want</span>
<span class="sd">        to use the checkCSI argument in order to explicitly check for the</span>
<span class="sd">        existence of a CSI index.</span>

<span class="sd">        If field is supplied only the named column will be selected.  If the</span>
<span class="sd">        column is not nested, an *array* of the current flavor will be</span>
<span class="sd">        returned; if it is, a *structured array* will be used instead.  If no</span>
<span class="sd">        field is specified, all the columns will be returned in a structured</span>
<span class="sd">        array of the current flavor.</span>

<span class="sd">        The meaning of the start, stop and step arguments is the same as in</span>
<span class="sd">        :meth:`Table.read`.</span>

<span class="sd">        .. versionchanged:: 3.0</span>
<span class="sd">           The start, stop and step parameters now behave like in slice.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_open</span><span class="p">()</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_sortby_csi</span><span class="p">(</span><span class="n">sortby</span><span class="p">,</span> <span class="n">checkCSI</span><span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_coordinates</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span></div>


<div class="viewcode-block" id="Table.iterrows">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.iterrows">[docs]</a>
    <span class="k">def</span> <span class="nf">iterrows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate over the table using a Row instance.</span>

<span class="sd">        If a range is not supplied, *all the rows* in the table are iterated</span>
<span class="sd">        upon - you can also use the :meth:`Table.__iter__` special method for</span>
<span class="sd">        that purpose. If you want to iterate over a given *range of rows* in</span>
<span class="sd">        the table, you may use the start, stop and step parameters.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            When in the middle of a table row iterator, you should not</span>
<span class="sd">            use methods that can change the number of rows in the table</span>
<span class="sd">            (like :meth:`Table.append` or :meth:`Table.remove_rows`) or</span>
<span class="sd">            unexpected errors will happen.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tableextension.Row : the table row iterator and field accessor</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            result = [ row[&#39;var2&#39;] for row in table.iterrows(step=5)</span>
<span class="sd">                                                    if row[&#39;var1&#39;] &lt;= 20 ]</span>

<span class="sd">        .. versionchanged:: 3.0</span>
<span class="sd">           If the *start* parameter is provided and *stop* is None then the</span>
<span class="sd">           table is iterated from *start* to the last line.</span>
<span class="sd">           In PyTables &lt; 3.0 only one element was returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span>
                                                  <span class="n">warn_negstep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">stop</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">step</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">stop</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&gt;</span> <span class="n">step</span><span class="p">):</span>
            <span class="c1"># Fall-back action is to return an empty iterator</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">([])</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">tableextension</span><span class="o">.</span><span class="n">Row</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">row</span><span class="o">.</span><span class="n">_iter</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span></div>


<div class="viewcode-block" id="Table.__iter__">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.__iter__">[docs]</a>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate over the table using a Row instance.</span>

<span class="sd">        This is equivalent to calling :meth:`Table.iterrows` with default</span>
<span class="sd">        arguments, i.e. it iterates over *all the rows* in the table.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tableextension.Row : the table row iterator and field accessor</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            result = [ row[&#39;var2&#39;] for row in table if row[&#39;var1&#39;] &lt;= 20 ]</span>

<span class="sd">        Which is equivalent to::</span>

<span class="sd">            result = [ row[&#39;var2&#39;] for row in table.iterrows()</span>
<span class="sd">                                                    if row[&#39;var1&#39;] &lt;= 20 ]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read a range of rows and return an in-memory object.&quot;&quot;&quot;</span>

        <span class="n">select_field</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">field</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coldtypes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">_v_names</span><span class="p">:</span>
                    <span class="c1"># Remember to select this field</span>
                    <span class="n">select_field</span> <span class="o">=</span> <span class="n">field</span>
                    <span class="n">field</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">((</span><span class="s2">&quot;Field </span><span class="si">{}</span><span class="s2"> not found in table &quot;</span>
                                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># The column hangs directly from the top</span>
                <span class="n">dtype_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coldtypes</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>

        <span class="c1"># Return a rank-0 array if start &gt; stop</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">stop</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">step</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">stop</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&gt;</span> <span class="n">step</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">nra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_container</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">nra</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype_field</span><span class="p">)</span>

        <span class="n">nrows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Compute the shape of the resulting column object</span>
            <span class="k">if</span> <span class="n">field</span><span class="p">:</span>
                <span class="c1"># Create a container for the results</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">nrows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype_field</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Recarray case</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_container</span><span class="p">(</span><span class="n">nrows</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># there is no fast way to byteswap, since different columns may</span>
            <span class="c1"># have different byteorders</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">isnative</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;output array must be in system&#39;s byteorder &quot;</span>
                                 <span class="s2">&quot;or results will be incorrect&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">field</span><span class="p">:</span>
                <span class="n">bytes_required</span> <span class="o">=</span> <span class="n">dtype_field</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">*</span> <span class="n">nrows</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bytes_required</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rowsize</span> <span class="o">*</span> <span class="n">nrows</span>
            <span class="k">if</span> <span class="n">bytes_required</span> <span class="o">!=</span> <span class="n">out</span><span class="o">.</span><span class="n">nbytes</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;output array size invalid, got </span><span class="si">{</span><span class="n">out</span><span class="o">.</span><span class="n">nbytes</span><span class="si">}</span><span class="s1">&#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39; bytes, need </span><span class="si">{</span><span class="n">bytes_required</span><span class="si">}</span><span class="s1"> bytes&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">out</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;C_CONTIGUOUS&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;output array not C contiguous&#39;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">out</span>

        <span class="c1"># Call the routine to fill-up the resulting array</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">field</span><span class="p">:</span>
            <span class="c1"># This optimization works three times faster than</span>
            <span class="c1"># the row._fill_col method (up to 170 MB/s on a pentium IV @ 2GHz)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_records</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
        <span class="c1"># Warning!: _read_field_name should not be used until</span>
        <span class="c1"># H5TBread_fields_name in tableextension will be finished</span>
        <span class="c1"># F. Alted 2005/05/26</span>
        <span class="c1"># XYX Ho implementem per a PyTables 2.0??</span>
        <span class="k">elif</span> <span class="n">field</span> <span class="ow">and</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="mi">15</span> <span class="ow">and</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># For step&gt;15, this seems to work always faster than row._fill_col.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_field_name</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="o">.</span><span class="n">_fill_col</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">select_field</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="n">select_field</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Table.read">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.read">[docs]</a>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get data in the table as a (record) array.</span>

<span class="sd">        The start, stop and step parameters can be used to select only</span>
<span class="sd">        a *range of rows* in the table. Their meanings are the same as</span>
<span class="sd">        in the built-in Python slices.</span>

<span class="sd">        If field is supplied only the named column will be selected.</span>
<span class="sd">        If the column is not nested, an *array* of the current flavor</span>
<span class="sd">        will be returned; if it is, a *structured array* will be used</span>
<span class="sd">        instead.  If no field is specified, all the columns will be</span>
<span class="sd">        returned in a structured array of the current flavor.</span>

<span class="sd">        Columns under a nested column can be specified in the field</span>
<span class="sd">        parameter by using a slash character (/) as a separator (e.g.</span>
<span class="sd">        &#39;position/x&#39;).</span>

<span class="sd">        The out parameter may be used to specify a NumPy array to</span>
<span class="sd">        receive the output data.  Note that the array must have the</span>
<span class="sd">        same size as the data selected with the other parameters.</span>
<span class="sd">        Note that the array&#39;s datatype is not checked and no type</span>
<span class="sd">        casting is performed, so if it does not match the datatype on</span>
<span class="sd">        disk, the output will not be correct.</span>

<span class="sd">        When specifying a single nested column with the field parameter,</span>
<span class="sd">        and supplying an output buffer with the out parameter, the</span>
<span class="sd">        output buffer must contain all columns in the table.</span>
<span class="sd">        The data in all columns will be read into the output buffer.</span>
<span class="sd">        However, only the specified nested column will be returned from</span>
<span class="sd">        the method call.</span>

<span class="sd">        When data is read from disk in NumPy format, the output will be</span>
<span class="sd">        in the current system&#39;s byteorder, regardless of how it is</span>
<span class="sd">        stored on disk. If the out parameter is specified, the output</span>
<span class="sd">        array also must be in the current system&#39;s byteorder.</span>

<span class="sd">        .. versionchanged:: 3.0</span>
<span class="sd">           Added the *out* parameter.  Also the start, stop and step</span>
<span class="sd">           parameters now behave like in slice.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Reading the entire table::</span>

<span class="sd">            t.read()</span>

<span class="sd">        Reading record n. 6::</span>

<span class="sd">            t.read(6, 7)</span>

<span class="sd">        Reading from record n. 6 to the end of the table::</span>

<span class="sd">            t.read(6)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_open</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">field</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_column</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">flavor</span> <span class="o">!=</span> <span class="s1">&#39;numpy&#39;</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Optional &#39;out&#39; argument may only be supplied if array &quot;</span>
                   <span class="s2">&quot;flavor is &#39;numpy&#39;, currently is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flavor</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span>
                                                <span class="n">warn_negstep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">internal_to_flavor</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flavor</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_read_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Private part of `read_coordinates()` with no flavor conversion.&quot;&quot;&quot;</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_point_selection</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

        <span class="n">ncoords</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="c1"># Create a read buffer only if needed</span>
        <span class="k">if</span> <span class="n">field</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ncoords</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Doing a copy is faster when ncoords is small (&lt;1000)</span>
            <span class="k">if</span> <span class="n">ncoords</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrowsinbuf</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_iobuf</span><span class="p">[:</span><span class="n">ncoords</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_container</span><span class="p">(</span><span class="n">ncoords</span><span class="p">)</span>

        <span class="c1"># Do the real read</span>
        <span class="k">if</span> <span class="n">ncoords</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Turn coords into an array of coordinate indexes, if necessary</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="n">coords</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">_npsizetype</span> <span class="ow">and</span>
                    <span class="n">coords</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">contiguous</span> <span class="ow">and</span>
                    <span class="n">coords</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">aligned</span><span class="p">):</span>
                <span class="c1"># Get a contiguous and aligned coordinate array</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">SizeType</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_elements</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

        <span class="c1"># Do the final conversions, if needed</span>
        <span class="k">if</span> <span class="n">field</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ncoords</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">get_nested_field</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Get an empty array from the cache</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getemptyarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coldtypes</span><span class="p">[</span><span class="n">field</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Table.read_coordinates">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.read_coordinates">[docs]</a>
    <span class="k">def</span> <span class="nf">read_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a set of rows given their indexes as a (record) array.</span>

<span class="sd">        This method works much like the :meth:`Table.read` method, but it uses</span>
<span class="sd">        a sequence (coords) of row indexes to select the wanted columns,</span>
<span class="sd">        instead of a column range.</span>

<span class="sd">        The selected rows are returned in an array or structured array of the</span>
<span class="sd">        current flavor.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_open</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_coordinates</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">internal_to_flavor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flavor</span><span class="p">)</span></div>


<div class="viewcode-block" id="Table.get_enum">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.get_enum">[docs]</a>
    <span class="k">def</span> <span class="nf">get_enum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the enumerated type associated with the named column.</span>

<span class="sd">        If the column named colname (a string) exists and is of an enumerated</span>
<span class="sd">        type, the corresponding Enum instance (see :ref:`EnumClassDescr`) is</span>
<span class="sd">        returned. If it is not of an enumerated type, a TypeError is raised. If</span>
<span class="sd">        the column does not exist, a KeyError is raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_column</span><span class="p">(</span><span class="n">colname</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_colenums</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;column ``</span><span class="si">%s</span><span class="s2">`` of table ``</span><span class="si">%s</span><span class="s2">`` is not of an enumerated type&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">colname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">))</span></div>


<div class="viewcode-block" id="Table.col">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.col">[docs]</a>
    <span class="k">def</span> <span class="nf">col</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a column from the table.</span>

<span class="sd">        If a column called name exists in the table, it is read and returned as</span>
<span class="sd">        a NumPy object. If it does not exist, a KeyError is raised.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            narray = table.col(&#39;var2&#39;)</span>

<span class="sd">        That statement is equivalent to::</span>

<span class="sd">            narray = table.read(field=&#39;var2&#39;)</span>

<span class="sd">        Here you can see how this method can be used as a shorthand for the</span>
<span class="sd">        :meth:`Table.read` method.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">field</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="Table.__getitem__">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a row or a range of rows from the table.</span>

<span class="sd">        If key argument is an integer, the corresponding table row is returned</span>
<span class="sd">        as a record of the current flavor. If key is a slice, the range of rows</span>
<span class="sd">        determined by it is returned as a structured array of the current</span>
<span class="sd">        flavor.</span>

<span class="sd">        In addition, NumPy-style point selections are supported.  In</span>
<span class="sd">        particular, if key is a list of row coordinates, the set of rows</span>
<span class="sd">        determined by it is returned.  Furthermore, if key is an array of</span>
<span class="sd">        boolean values, only the coordinates where key is True are returned.</span>
<span class="sd">        Note that for the latter to work it is necessary that key list would</span>
<span class="sd">        contain exactly as many rows as the table has.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            record = table[4]</span>
<span class="sd">            recarray = table[4:1000:2]</span>
<span class="sd">            recarray = table[[4,1000]]   # only retrieves rows 4 and 1000</span>
<span class="sd">            recarray = table[[True, False, ..., True]]</span>

<span class="sd">        Those statements are equivalent to::</span>

<span class="sd">            record = table.read(start=4)[0]</span>
<span class="sd">            recarray = table.read(start=4, stop=1000, step=2)</span>
<span class="sd">            recarray = table.read_coordinates([4,1000])</span>
<span class="sd">            recarray = table.read_coordinates([True, False, ..., True])</span>

<span class="sd">        Here, you can see how indexing can be used as a shorthand for the</span>
<span class="sd">        :meth:`Table.read` and :meth:`Table.read_coordinates` methods.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_open</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">is_idx</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="c1"># Index out of range protection</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Index out of range&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># To support negative values</span>
                <span class="n">key</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span>
            <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span>
                <span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="c1"># Try with a boolean or point selection</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_coordinates</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid index or slice: </span><span class="si">{</span><span class="n">key</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Table.__setitem__">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.__setitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a row or a range of rows in the table.</span>

<span class="sd">        It takes different actions depending on the type of the *key*</span>
<span class="sd">        parameter: if it is an integer, the corresponding table row is</span>
<span class="sd">        set to *value* (a record or sequence capable of being converted</span>
<span class="sd">        to the table structure).  If *key* is a slice, the row slice</span>
<span class="sd">        determined by it is set to *value* (a record array or sequence</span>
<span class="sd">        capable of being converted to the table structure).</span>

<span class="sd">        In addition, NumPy-style point selections are supported.  In</span>
<span class="sd">        particular, if key is a list of row coordinates, the set of rows</span>
<span class="sd">        determined by it is set to value.  Furthermore, if key is an array of</span>
<span class="sd">        boolean values, only the coordinates where key is True are set to</span>
<span class="sd">        values from value.  Note that for the latter to work it is necessary</span>
<span class="sd">        that key list would contain exactly as many rows as the table has.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            # Modify just one existing row</span>
<span class="sd">            table[2] = [456,&#39;db2&#39;,1.2]</span>

<span class="sd">            # Modify two existing rows</span>
<span class="sd">            rows = np.rec.array(</span>
<span class="sd">                [[457,&#39;db1&#39;,1.2],[6,&#39;de2&#39;,1.3]], formats=&#39;i4,a3,f8&#39;</span>
<span class="sd">            )</span>
<span class="sd">            table[1:30:2] = rows             # modify a table slice</span>
<span class="sd">            table[[1,3]] = rows              # only modifies rows 1 and 3</span>
<span class="sd">            table[[True,False,True]] = rows  # only modifies rows 0 and 2</span>

<span class="sd">        Which is equivalent to::</span>

<span class="sd">            table.modify_rows(start=2, rows=[456,&#39;db2&#39;,1.2])</span>
<span class="sd">            rows = np.rec.array(</span>
<span class="sd">                [[457,&#39;db1&#39;,1.2],[6,&#39;de2&#39;,1.3]], formats=&#39;i4,a3,f8&#39;</span>
<span class="sd">            )</span>
<span class="sd">            table.modify_rows(start=1, stop=3, step=2, rows=rows)</span>
<span class="sd">            table.modify_coordinates([1,3,2], rows)</span>
<span class="sd">            table.modify_coordinates([True, False, True], rows)</span>

<span class="sd">        Here, you can see how indexing can be used as a shorthand for the</span>
<span class="sd">        :meth:`Table.modify_rows` and :meth:`Table.modify_coordinates`</span>
<span class="sd">        methods.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_open</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_check_writable</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">is_idx</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="c1"># Index out of range protection</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Index out of range&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># To support negative values</span>
                <span class="n">key</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modify_rows</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">value</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span>
                <span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modify_rows</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="c1"># Try with a boolean or point selection</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modify_coordinates</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid index or slice: </span><span class="si">{</span><span class="n">key</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_save_buffered_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wbufRA</span><span class="p">,</span> <span class="n">lenrows</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the indexes after a flushing of rows.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_open_append</span><span class="p">(</span><span class="n">wbufRA</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_append_records</span><span class="p">(</span><span class="n">lenrows</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_append</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unsaved_indexedrows</span> <span class="o">+=</span> <span class="n">lenrows</span>
            <span class="c1"># The table caches for indexed queries are dirty now</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dirtycache</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoindex</span><span class="p">:</span>
                <span class="c1"># Flush the unindexed rows</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flush_rows_to_index</span><span class="p">(</span><span class="n">_lastrow</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># All the columns are dirty now</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mark_columns_as_dirty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colpathnames</span><span class="p">)</span>

<div class="viewcode-block" id="Table.append">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.append">[docs]</a>
    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Append a sequence of rows to the end of the table.</span>

<span class="sd">        The rows argument may be any object which can be converted to</span>
<span class="sd">        a structured array compliant with the table structure</span>
<span class="sd">        (otherwise, a ValueError is raised).  This includes NumPy</span>
<span class="sd">        structured arrays, lists of tuples or array records, and a</span>
<span class="sd">        string or Python buffer.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            import tables as tb</span>

<span class="sd">            class Particle(tb.IsDescription):</span>
<span class="sd">                name        = tb.StringCol(16, pos=1) # 16-character String</span>
<span class="sd">                lati        = tb.IntCol(pos=2)        # integer</span>
<span class="sd">                longi       = tb.IntCol(pos=3)        # integer</span>
<span class="sd">                pressure    = tb.Float32Col(pos=4)  # float  (single-precision)</span>
<span class="sd">                temperature = tb.FloatCol(pos=5)    # double (double-precision)</span>

<span class="sd">            fileh = tb.open_file(&#39;test4.h5&#39;, mode=&#39;w&#39;)</span>
<span class="sd">            table = fileh.create_table(fileh.root, &#39;table&#39;, Particle,</span>
<span class="sd">                                       &quot;A table&quot;)</span>

<span class="sd">            # Append several rows in only one call</span>
<span class="sd">            table.append([(&quot;Particle:     10&quot;, 10, 0, 10 * 10, 10**2),</span>
<span class="sd">                          (&quot;Particle:     11&quot;, 11, -1, 11 * 11, 11**2),</span>
<span class="sd">                          (&quot;Particle:     12&quot;, 12, -2, 12 * 12, 12**2)])</span>
<span class="sd">            fileh.close()</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_open</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_check_writable</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunked</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HDF5ExtError</span><span class="p">(</span>
                <span class="s2">&quot;You cannot append rows to a non-chunked table.&quot;</span><span class="p">,</span> <span class="n">h5bt</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">)</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">_v_is_nested</span> <span class="ow">and</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># Shortcut for compliant arrays</span>
            <span class="c1"># (for some reason, not valid for nested types)</span>
            <span class="n">wbufRA</span> <span class="o">=</span> <span class="n">rows</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Try to convert the object into a recarray compliant with table</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">iflavor</span> <span class="o">=</span> <span class="n">flavor_of</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">iflavor</span> <span class="o">!=</span> <span class="s1">&#39;python&#39;</span><span class="p">:</span>
                    <span class="n">rows</span> <span class="o">=</span> <span class="n">array_as_internal</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">iflavor</span><span class="p">)</span>
                <span class="c1"># Works for Python structures and always copies the original,</span>
                <span class="c1"># so the resulting object is safe for in-place conversion.</span>
                <span class="n">wbufRA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_dtype</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>  <span class="c1"># XXX</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;rows parameter cannot be converted into a &quot;</span>
                                 <span class="s2">&quot;recarray object compliant with table &#39;</span><span class="si">%s</span><span class="s2">&#39;. &quot;</span>
                                 <span class="s2">&quot;The error was: &lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">exc</span><span class="p">))</span>
        <span class="n">lenrows</span> <span class="o">=</span> <span class="n">wbufRA</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># If the number of rows to append is zero, don&#39;t do anything else</span>
        <span class="k">if</span> <span class="n">lenrows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Save write buffer to disk</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_buffered_rows</span><span class="p">(</span><span class="n">wbufRA</span><span class="p">,</span> <span class="n">lenrows</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_conv_to_recarr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Try to convert the object into a recarray.&quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">iflavor</span> <span class="o">=</span> <span class="n">flavor_of</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">iflavor</span> <span class="o">!=</span> <span class="s1">&#39;python&#39;</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">array_as_internal</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">iflavor</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">obj</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
                <span class="c1"># To allow conversion of scalars (void type) into arrays.</span>
                <span class="c1"># See http://projects.scipy.org/scipy/numpy/ticket/315</span>
                <span class="c1"># for discussion on how to pass buffers to constructors</span>
                <span class="c1"># See also http://projects.scipy.org/scipy/numpy/ticket/348</span>
                <span class="n">recarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">obj</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Works for Python structures and always copies the original,</span>
                <span class="c1"># so the resulting object is safe for in-place conversion.</span>
                <span class="n">recarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_dtype</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>  <span class="c1"># XXX</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Object cannot be converted into a recarray &quot;</span>
                             <span class="s2">&quot;object compliant with table format &#39;</span><span class="si">%s</span><span class="s2">&#39;. &quot;</span>
                             <span class="s2">&quot;The error was: &lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">_v_nested_descr</span><span class="p">,</span> <span class="n">exc</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">recarr</span>

<div class="viewcode-block" id="Table.modify_coordinates">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.modify_coordinates">[docs]</a>
    <span class="k">def</span> <span class="nf">modify_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">rows</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Modify a series of rows in positions specified in coords.</span>

<span class="sd">        The values in the selected rows will be modified with the data given in</span>
<span class="sd">        rows.  This method returns the number of rows modified.</span>

<span class="sd">        The possible values for the rows argument are the same as in</span>
<span class="sd">        :meth:`Table.append`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">rows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>      <span class="c1"># Nothing to be done</span>
            <span class="k">return</span> <span class="n">SizeType</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Convert the coordinates to something expected by HDF5</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_point_selection</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

        <span class="n">lcoords</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">lcoords</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The value has not enough elements to fill-in &quot;</span>
                             <span class="s2">&quot;the specified range&quot;</span><span class="p">)</span>

        <span class="c1"># Convert rows into a recarray</span>
        <span class="n">recarr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_to_recarr</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Do the actual update of rows</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_elements</span><span class="p">(</span><span class="n">lcoords</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">recarr</span><span class="p">)</span>

        <span class="c1"># Redo the index if needed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colpathnames</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SizeType</span><span class="p">(</span><span class="n">lcoords</span><span class="p">)</span></div>


<div class="viewcode-block" id="Table.modify_rows">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.modify_rows">[docs]</a>
    <span class="k">def</span> <span class="nf">modify_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Modify a series of rows in the slice [start:stop:step].</span>

<span class="sd">        The values in the selected rows will be modified with the data given in</span>
<span class="sd">        rows.  This method returns the number of rows modified.  Should the</span>
<span class="sd">        modification exceed the length of the table, an IndexError is raised</span>
<span class="sd">        before changing data.</span>

<span class="sd">        The possible values for the rows argument are the same as in</span>
<span class="sd">        :meth:`Table.append`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">rows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>      <span class="c1"># Nothing to be done</span>
            <span class="k">return</span> <span class="n">SizeType</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;start&#39; must have a positive value.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;step&#39; must have a value greater or equal than 1.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># compute the stop value. start + len(rows)*step does not work</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;This modification will exceed the length of &quot;</span>
                             <span class="s2">&quot;the table. Giving up.&quot;</span><span class="p">)</span>
        <span class="c1"># Compute the number of rows to read.</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nrows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The value has different elements than the &quot;</span>
                             <span class="s2">&quot;specified range&quot;</span><span class="p">)</span>

        <span class="c1"># Convert rows into a recarray</span>
        <span class="n">recarr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_to_recarr</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>

        <span class="n">lenrows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">recarr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">+</span> <span class="n">lenrows</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;This modification will exceed the length of the &quot;</span>
                             <span class="s2">&quot;table. Giving up.&quot;</span><span class="p">)</span>

        <span class="c1"># Do the actual update</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_records</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">recarr</span><span class="p">)</span>

        <span class="c1"># Redo the index if needed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colpathnames</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SizeType</span><span class="p">(</span><span class="n">lenrows</span><span class="p">)</span></div>


<div class="viewcode-block" id="Table.modify_column">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.modify_column">[docs]</a>
    <span class="k">def</span> <span class="nf">modify_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">colname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Modify one single column in the row slice [start:stop:step].</span>

<span class="sd">        The colname argument specifies the name of the column in the</span>
<span class="sd">        table to be modified with the data given in column.  This</span>
<span class="sd">        method returns the number of rows modified.  Should the</span>
<span class="sd">        modification exceed the length of the table, an IndexError is</span>
<span class="sd">        raised before changing data.</span>

<span class="sd">        The *column* argument may be any object which can be converted</span>
<span class="sd">        to a (record) array compliant with the structure of the column</span>
<span class="sd">        to be modified (otherwise, a ValueError is raised).  This</span>
<span class="sd">        includes NumPy (record) arrays, lists of scalars, tuples or</span>
<span class="sd">        array records, and a string or Python buffer.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">colname</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The &#39;colname&#39; parameter must be a string.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_check_writable</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>      <span class="c1"># Nothing to be done</span>
            <span class="k">return</span> <span class="n">SizeType</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;start&#39; must have a positive value.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;step&#39; must have a value greater or equal than 1.&quot;</span><span class="p">)</span>
        <span class="c1"># Get the column format to be modified:</span>
        <span class="n">objcol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_column_instance</span><span class="p">(</span><span class="n">colname</span><span class="p">)</span>
        <span class="n">descr</span> <span class="o">=</span> <span class="p">[</span><span class="n">objcol</span><span class="o">.</span><span class="n">_v_parent</span><span class="o">.</span><span class="n">_v_nested_descr</span><span class="p">[</span><span class="n">objcol</span><span class="o">.</span><span class="n">_v_pos</span><span class="p">]]</span>
        <span class="c1"># Try to convert the column object into a NumPy ndarray</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># If the column is a recarray (or kind of), convert into ndarray</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">column</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;V&#39;</span><span class="p">:</span>
                <span class="n">column</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">descr</span><span class="p">)</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Make sure the result is always a *copy* of the original,</span>
                <span class="c1"># so the resulting object is safe for in-place conversion.</span>
                <span class="n">iflavor</span> <span class="o">=</span> <span class="n">flavor_of</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
                <span class="n">column</span> <span class="o">=</span> <span class="n">array_as_internal</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">iflavor</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>  <span class="c1"># XXX</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;column parameter cannot be converted into a &quot;</span>
                             <span class="s2">&quot;ndarray object compliant with specified column &quot;</span>
                             <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39;. The error was: &lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">column</span><span class="p">),</span> <span class="n">exc</span><span class="p">))</span>

        <span class="c1"># Get rid of single-dimensional dimensions</span>
        <span class="n">column</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">column</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
            <span class="c1"># Oops, stripped off to much dimensions</span>
            <span class="n">column</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>

        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># compute the stop value. start + len(rows)*step does not work</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">column</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;This modification will exceed the length of &quot;</span>
                             <span class="s2">&quot;the table. Giving up.&quot;</span><span class="p">)</span>
        <span class="c1"># Compute the number of rows to read.</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">column</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nrows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The value has not enough elements to fill-in &quot;</span>
                             <span class="s2">&quot;the specified range&quot;</span><span class="p">)</span>
        <span class="c1"># Now, read the original values:</span>
        <span class="n">mod_recarr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="c1"># Modify the appropriate column in the original recarray</span>
        <span class="n">mod_col</span> <span class="o">=</span> <span class="n">get_nested_field</span><span class="p">(</span><span class="n">mod_recarr</span><span class="p">,</span> <span class="n">colname</span><span class="p">)</span>
        <span class="n">mod_col</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">column</span>
        <span class="c1"># save this modified rows in table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_records</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">mod_recarr</span><span class="p">)</span>
        <span class="c1"># Redo the index if needed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reindex</span><span class="p">([</span><span class="n">colname</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">SizeType</span><span class="p">(</span><span class="n">nrows</span><span class="p">)</span></div>


<div class="viewcode-block" id="Table.modify_columns">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.modify_columns">[docs]</a>
    <span class="k">def</span> <span class="nf">modify_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Modify a series of columns in the row slice [start:stop:step].</span>

<span class="sd">        The names argument specifies the names of the columns in the</span>
<span class="sd">        table to be modified with the data given in columns.  This</span>
<span class="sd">        method returns the number of rows modified.  Should the</span>
<span class="sd">        modification exceed the length of the table, an IndexError</span>
<span class="sd">        is raised before changing data.</span>

<span class="sd">        The columns argument may be any object which can be converted</span>
<span class="sd">        to a structured array compliant with the structure of the</span>
<span class="sd">        columns to be modified (otherwise, a ValueError is raised).</span>
<span class="sd">        This includes NumPy structured arrays, lists of tuples or array</span>
<span class="sd">        records, and a string or Python buffer.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The &#39;names&#39; parameter must be a list of strings.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Nothing to be done</span>
            <span class="k">return</span> <span class="n">SizeType</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;start&#39; must have a positive value.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;step&#39; must have a value greater or &quot;</span>
                             <span class="s2">&quot;equal than 1.&quot;</span><span class="p">)</span>
        <span class="n">descr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">colname</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">objcol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_column_instance</span><span class="p">(</span><span class="n">colname</span><span class="p">)</span>
            <span class="n">descr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">objcol</span><span class="o">.</span><span class="n">_v_parent</span><span class="o">.</span><span class="n">_v_nested_descr</span><span class="p">[</span><span class="n">objcol</span><span class="o">.</span><span class="n">_v_pos</span><span class="p">])</span>
            <span class="c1"># descr.append(objcol._v_parent._v_dtype[objcol._v_pos])</span>
        <span class="c1"># Try to convert the columns object into a recarray</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Make sure the result is always a *copy* of the original,</span>
            <span class="c1"># so the resulting object is safe for in-place conversion.</span>
            <span class="n">iflavor</span> <span class="o">=</span> <span class="n">flavor_of</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">iflavor</span> <span class="o">!=</span> <span class="s1">&#39;python&#39;</span><span class="p">:</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="n">array_as_internal</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">iflavor</span><span class="p">)</span>
                <span class="n">recarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">descr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">recarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">fromarrays</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">descr</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>  <span class="c1"># XXX</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;columns parameter cannot be converted into a &quot;</span>
                             <span class="s2">&quot;recarray object compliant with table &#39;</span><span class="si">%s</span><span class="s2">&#39;. &quot;</span>
                             <span class="s2">&quot;The error was: &lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">exc</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># compute the stop value. start + len(rows)*step does not work</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">recarray</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;This modification will exceed the length of &quot;</span>
                             <span class="s2">&quot;the table. Giving up.&quot;</span><span class="p">)</span>
        <span class="c1"># Compute the number of rows to read.</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">recarray</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nrows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The value has not enough elements to fill-in &quot;</span>
                             <span class="s2">&quot;the specified range&quot;</span><span class="p">)</span>
        <span class="c1"># Now, read the original values:</span>
        <span class="n">mod_recarr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="c1"># Modify the appropriate columns in the original recarray</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">recarray</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
            <span class="n">mod_col</span> <span class="o">=</span> <span class="n">get_nested_field</span><span class="p">(</span><span class="n">mod_recarr</span><span class="p">,</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">mod_col</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">recarray</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="c1"># save this modified rows in table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_records</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">mod_recarr</span><span class="p">)</span>
        <span class="c1"># Redo the index if needed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reindex</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SizeType</span><span class="p">(</span><span class="n">nrows</span><span class="p">)</span></div>


<div class="viewcode-block" id="Table.flush_rows_to_index">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.flush_rows_to_index">[docs]</a>
    <span class="k">def</span> <span class="nf">flush_rows_to_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_lastrow</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add remaining rows in buffers to non-dirty indexes.</span>

<span class="sd">        This can be useful when you have chosen non-automatic indexing</span>
<span class="sd">        for the table (see the :attr:`Table.autoindex` property in</span>
<span class="sd">        :class:`Table`) and you want to update the indexes on it.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rowsadded</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexed</span><span class="p">:</span>
            <span class="c1"># Update the number of unsaved indexed rows</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexedrows</span>
            <span class="n">nrows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unsaved_indexedrows</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">colname</span><span class="p">,</span> <span class="n">colindexed</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colindexed</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">colindexed</span><span class="p">:</span>
                    <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">_g_col</span><span class="p">(</span><span class="n">colname</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">nrows</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">col</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">dirty</span><span class="p">:</span>
                        <span class="n">rowsadded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_rows_to_index</span><span class="p">(</span>
                            <span class="n">colname</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">nrows</span><span class="p">,</span> <span class="n">_lastrow</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unsaved_indexedrows</span> <span class="o">-=</span> <span class="n">rowsadded</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indexedrows</span> <span class="o">+=</span> <span class="n">rowsadded</span>
        <span class="k">return</span> <span class="n">rowsadded</span></div>


    <span class="k">def</span> <span class="nf">_add_rows_to_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colname</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">nrows</span><span class="p">,</span> <span class="n">lastrow</span><span class="p">,</span> <span class="n">update</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add more elements to the existing index.&quot;&quot;&quot;</span>

        <span class="c1"># This method really belongs to Column, but since it makes extensive</span>
        <span class="c1"># use of the table, it gets dangerous when closing the file, since the</span>
        <span class="c1"># column may be accessing a table which is being destroyed.</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">_g_col</span><span class="p">(</span><span class="n">colname</span><span class="p">)</span><span class="o">.</span><span class="n">index</span>
        <span class="n">slicesize</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">slicesize</span>
        <span class="c1"># The next loop does not rely on xrange so that it can</span>
        <span class="c1"># deal with long ints (i.e. more than 32-bit integers)</span>
        <span class="c1"># This allows to index columns with more than 2**31 rows</span>
        <span class="c1"># F. Alted 2005-05-09</span>
        <span class="n">startLR</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">sorted</span><span class="o">.</span><span class="n">nrows</span> <span class="o">*</span> <span class="n">slicesize</span>
        <span class="n">indexedrows</span> <span class="o">=</span> <span class="n">startLR</span> <span class="o">-</span> <span class="n">start</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">nrows</span> <span class="o">-</span> <span class="n">slicesize</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">startLR</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
            <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_read</span><span class="p">(</span><span class="n">startLR</span><span class="p">,</span> <span class="n">startLR</span> <span class="o">+</span> <span class="n">slicesize</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">colname</span><span class="p">)],</span>
                <span class="n">update</span><span class="o">=</span><span class="n">update</span><span class="p">)</span>
            <span class="n">indexedrows</span> <span class="o">+=</span> <span class="n">slicesize</span>
            <span class="n">startLR</span> <span class="o">+=</span> <span class="n">slicesize</span>
        <span class="c1"># index the remaining rows in last row</span>
        <span class="k">if</span> <span class="n">lastrow</span> <span class="ow">and</span> <span class="n">startLR</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">:</span>
            <span class="n">index</span><span class="o">.</span><span class="n">append_last_row</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_read</span><span class="p">(</span><span class="n">startLR</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">colname</span><span class="p">)],</span>
                <span class="n">update</span><span class="o">=</span><span class="n">update</span><span class="p">)</span>
            <span class="n">indexedrows</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span> <span class="o">-</span> <span class="n">startLR</span>
        <span class="k">return</span> <span class="n">indexedrows</span>

<div class="viewcode-block" id="Table.remove_rows">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.remove_rows">[docs]</a>
    <span class="k">def</span> <span class="nf">remove_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove a range of rows in the table.</span>

<span class="sd">        If only start is supplied, that row and all following will be deleted.</span>
<span class="sd">        If a range is supplied, i.e. both the start and stop parameters are</span>
<span class="sd">        passed, all the rows in the range are removed.</span>

<span class="sd">        .. versionchanged:: 3.0</span>
<span class="sd">           The start, stop and step parameters now behave like in slice.</span>

<span class="sd">        .. seealso:: remove_row()</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int</span>
<span class="sd">            Sets the starting row to be removed. It accepts negative values</span>
<span class="sd">            meaning that the count starts from the end.  A value of 0 means the</span>
<span class="sd">            first row.</span>
<span class="sd">        stop : int</span>
<span class="sd">            Sets the last row to be removed to stop-1, i.e. the end point is</span>
<span class="sd">            omitted (in the Python range() tradition). Negative values are also</span>
<span class="sd">            accepted. If None all rows after start will be removed.</span>
<span class="sd">        step : int</span>
<span class="sd">            The step size between rows to remove.</span>

<span class="sd">            .. versionadded:: 3.0</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Removing rows from 5 to 10 (excluded)::</span>

<span class="sd">            t.remove_rows(5, 10)</span>

<span class="sd">        Removing all rows starting from the 10th::</span>

<span class="sd">            t.remove_rows(10)</span>

<span class="sd">        Removing the 6th row::</span>

<span class="sd">            t.remove_rows(6, 7)</span>

<span class="sd">        .. note::</span>

<span class="sd">            removing a single row can be done using the specific</span>
<span class="sd">            :meth:`remove_row` method.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_rows</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="c1"># remove_rows is a invalidating index operation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colpathnames</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SizeType</span><span class="p">(</span><span class="n">nrows</span><span class="p">)</span></div>


<div class="viewcode-block" id="Table.remove_row">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.remove_row">[docs]</a>
    <span class="k">def</span> <span class="nf">remove_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes a row from the table.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">            The index of the row to remove.</span>


<span class="sd">        .. versionadded:: 3.0</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Remove row 15::</span>

<span class="sd">            table.remove_row(15)</span>

<span class="sd">        Which is equivalent to::</span>

<span class="sd">            table.remove_rows(15, 16)</span>

<span class="sd">        .. warning::</span>

<span class="sd">            This is not equivalent to::</span>

<span class="sd">                table.remove_rows(15)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">remove_rows</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_g_update_dependent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_g_update_dependent</span><span class="p">()</span>

        <span class="c1"># Update the new path in columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">_g_update_table_location</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Update the new path in the Row instance, if cached.  Fixes #224.</span>
        <span class="k">if</span> <span class="s1">&#39;row&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;row&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tableextension</span><span class="o">.</span><span class="n">Row</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_g_move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newparent</span><span class="p">,</span> <span class="n">newname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Move this node in the hierarchy.</span>

<span class="sd">        This overloads the Node._g_move() method.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">itgpathname</span> <span class="o">=</span> <span class="n">_index_pathname_of</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># First, move the table to the new location.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_g_move</span><span class="p">(</span><span class="n">newparent</span><span class="p">,</span> <span class="n">newname</span><span class="p">)</span>

        <span class="c1"># Then move the associated index group (if any).</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">itgroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_get_node</span><span class="p">(</span><span class="n">itgpathname</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">NoSuchNodeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newigroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_parent</span>
            <span class="n">newiname</span> <span class="o">=</span> <span class="n">_index_name_of</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">itgroup</span><span class="o">.</span><span class="n">_g_move</span><span class="p">(</span><span class="n">newigroup</span><span class="p">,</span> <span class="n">newiname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_g_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Remove the associated index group (if any).</span>
        <span class="n">itgpathname</span> <span class="o">=</span> <span class="n">_index_pathname_of</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">itgroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_get_node</span><span class="p">(</span><span class="n">itgpathname</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">NoSuchNodeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">itgroup</span><span class="o">.</span><span class="n">_f_remove</span><span class="p">(</span><span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indexed</span> <span class="o">=</span> <span class="kc">False</span>   <span class="c1"># there are indexes no more</span>

        <span class="c1"># Remove the leaf itself from the hierarchy.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_g_remove</span><span class="p">(</span><span class="n">recursive</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_column_indexing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colpathname</span><span class="p">,</span> <span class="n">indexed</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mark the referred column as indexed or non-indexed.&quot;&quot;&quot;</span>

        <span class="n">colindexed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colindexed</span>
        <span class="n">isindexed</span><span class="p">,</span> <span class="n">wasindexed</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">indexed</span><span class="p">),</span> <span class="n">colindexed</span><span class="p">[</span><span class="n">colpathname</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">isindexed</span> <span class="o">==</span> <span class="n">wasindexed</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c1"># indexing state is unchanged</span>

        <span class="c1"># Changing the set of indexed columns invalidates the condition cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_condition_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">colindexed</span><span class="p">[</span><span class="n">colpathname</span><span class="p">]</span> <span class="o">=</span> <span class="n">isindexed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexed</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">colindexed</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>  <span class="c1"># this is an OR :)</span>

    <span class="k">def</span> <span class="nf">_mark_columns_as_dirty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colnames</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mark column indexes in `colnames` as dirty.&quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">colnames</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexed</span><span class="p">:</span>
            <span class="n">colindexed</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colindexed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
            <span class="c1"># Mark the proper indexes as dirty</span>
            <span class="k">for</span> <span class="n">colname</span> <span class="ow">in</span> <span class="n">colnames</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">colindexed</span><span class="p">[</span><span class="n">colname</span><span class="p">]:</span>
                    <span class="n">col</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="n">_g_col</span><span class="p">(</span><span class="n">colname</span><span class="p">)</span>
                    <span class="n">col</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">dirty</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colnames</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Re-index columns in `colnames` if automatic indexing is true.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexed</span><span class="p">:</span>
            <span class="n">colindexed</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colindexed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
            <span class="n">colstoindex</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Mark the proper indexes as dirty</span>
            <span class="k">for</span> <span class="n">colname</span> <span class="ow">in</span> <span class="n">colnames</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">colindexed</span><span class="p">[</span><span class="n">colname</span><span class="p">]:</span>
                    <span class="n">col</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="n">_g_col</span><span class="p">(</span><span class="n">colname</span><span class="p">)</span>
                    <span class="n">col</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">dirty</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">colstoindex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">colname</span><span class="p">)</span>
            <span class="c1"># Now, re-index the dirty ones</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoindex</span> <span class="ow">and</span> <span class="n">colstoindex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_do_reindex</span><span class="p">(</span><span class="n">dirty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># The table caches for indexed queries are dirty now</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dirtycache</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_do_reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirty</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Common code for `reindex()` and `reindex_dirty()`.&quot;&quot;&quot;</span>

        <span class="n">indexedrows</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">colname</span><span class="p">,</span> <span class="n">colindexed</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colindexed</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">colindexed</span><span class="p">:</span>
                <span class="n">indexcol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">_g_col</span><span class="p">(</span><span class="n">colname</span><span class="p">)</span>
                <span class="n">indexedrows</span> <span class="o">=</span> <span class="n">indexcol</span><span class="o">.</span><span class="n">_do_reindex</span><span class="p">(</span><span class="n">dirty</span><span class="p">)</span>
        <span class="c1"># Update counters in case some column has been updated</span>
        <span class="k">if</span> <span class="n">indexedrows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indexedrows</span> <span class="o">=</span> <span class="n">indexedrows</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unsaved_indexedrows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span> <span class="o">-</span> <span class="n">indexedrows</span>

        <span class="k">return</span> <span class="n">SizeType</span><span class="p">(</span><span class="n">indexedrows</span><span class="p">)</span>

<div class="viewcode-block" id="Table.reindex">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.reindex">[docs]</a>
    <span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Recompute all the existing indexes in the table.</span>

<span class="sd">        This can be useful when you suspect that, for any reason, the</span>
<span class="sd">        index information for columns is no longer valid and want to</span>
<span class="sd">        rebuild the indexes on it.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_do_reindex</span><span class="p">(</span><span class="n">dirty</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="Table.reindex_dirty">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.reindex_dirty">[docs]</a>
    <span class="k">def</span> <span class="nf">reindex_dirty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Recompute the existing indexes in table, *if* they are dirty.</span>

<span class="sd">        This can be useful when you have set :attr:`Table.autoindex`</span>
<span class="sd">        (see :class:`Table`) to false for the table and you want to</span>
<span class="sd">        update the indexes after a invalidating index operation</span>
<span class="sd">        (:meth:`Table.remove_rows`, for example).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_do_reindex</span><span class="p">(</span><span class="n">dirty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_g_copy_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">object</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">sortby</span><span class="p">,</span> <span class="n">checkCSI</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy rows from self to object&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sortby</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_g_copy_rows_optim</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">lenbuf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrowsinbuf</span>
        <span class="n">absstep</span> <span class="o">=</span> <span class="n">step</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">absstep</span> <span class="o">=</span> <span class="o">-</span><span class="n">step</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">sortby</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_sortby_csi</span><span class="p">(</span><span class="n">sortby</span><span class="p">,</span> <span class="n">checkCSI</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">start2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">absstep</span> <span class="o">*</span> <span class="n">lenbuf</span><span class="p">):</span>
            <span class="n">stop2</span> <span class="o">=</span> <span class="n">start2</span> <span class="o">+</span> <span class="n">absstep</span> <span class="o">*</span> <span class="n">lenbuf</span>
            <span class="k">if</span> <span class="n">stop2</span> <span class="o">&gt;</span> <span class="n">stop</span><span class="p">:</span>
                <span class="n">stop2</span> <span class="o">=</span> <span class="n">stop</span>
            <span class="c1"># The next &#39;if&#39; is not needed, but it doesn&#39;t bother either</span>
            <span class="k">if</span> <span class="n">sortby</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rows</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">start2</span><span class="p">:</span><span class="n">stop2</span><span class="p">:</span><span class="n">step</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">start2</span><span class="p">:</span><span class="n">stop2</span><span class="p">:</span><span class="n">step</span><span class="p">]</span>
                <span class="n">rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_coordinates</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="c1"># Save the records on disk</span>
            <span class="nb">object</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_g_copy_rows_optim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">object</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy rows from self to object (optimized version)&quot;&quot;&quot;</span>

        <span class="n">nrowsinbuf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrowsinbuf</span>
        <span class="nb">object</span><span class="o">.</span><span class="n">_open_append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_iobuf</span><span class="p">)</span>
        <span class="n">nrowsdest</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">nrows</span>
        <span class="k">for</span> <span class="n">start2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">*</span> <span class="n">nrowsinbuf</span><span class="p">):</span>
            <span class="c1"># Save the records on disk</span>
            <span class="n">stop2</span> <span class="o">=</span> <span class="n">start2</span> <span class="o">+</span> <span class="n">step</span> <span class="o">*</span> <span class="n">nrowsinbuf</span>
            <span class="k">if</span> <span class="n">stop2</span> <span class="o">&gt;</span> <span class="n">stop</span><span class="p">:</span>
                <span class="n">stop2</span> <span class="o">=</span> <span class="n">stop</span>
            <span class="c1"># Optimized version (it saves some conversions)</span>
            <span class="n">nrows</span> <span class="o">=</span> <span class="p">((</span><span class="n">stop2</span> <span class="o">-</span> <span class="n">start2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">step</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="o">.</span><span class="n">_fill_col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_iobuf</span><span class="p">,</span> <span class="n">start2</span><span class="p">,</span> <span class="n">stop2</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="c1"># The output buffer is created anew,</span>
            <span class="c1"># so the operation is safe to in-place conversion.</span>
            <span class="nb">object</span><span class="o">.</span><span class="n">_append_records</span><span class="p">(</span><span class="n">nrows</span><span class="p">)</span>
            <span class="n">nrowsdest</span> <span class="o">+=</span> <span class="n">nrows</span>
        <span class="nb">object</span><span class="o">.</span><span class="n">_close_append</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_g_prop_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate index in `other` table for every indexed column here.&quot;&quot;&quot;</span>

        <span class="n">oldcols</span><span class="p">,</span> <span class="n">newcols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colinstances</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">colinstances</span>
        <span class="k">for</span> <span class="n">colname</span> <span class="ow">in</span> <span class="n">newcols</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">oldcols</span><span class="p">[</span><span class="n">colname</span><span class="p">],</span> <span class="n">Column</span><span class="p">)):</span>
                <span class="n">oldcolindexed</span> <span class="o">=</span> <span class="n">oldcols</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span><span class="o">.</span><span class="n">is_indexed</span>
                <span class="k">if</span> <span class="n">oldcolindexed</span><span class="p">:</span>
                    <span class="n">oldcolindex</span> <span class="o">=</span> <span class="n">oldcols</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
                    <span class="n">newcol</span> <span class="o">=</span> <span class="n">newcols</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span>
                    <span class="n">newcol</span><span class="o">.</span><span class="n">create_index</span><span class="p">(</span>
                        <span class="n">kind</span><span class="o">=</span><span class="n">oldcolindex</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="n">optlevel</span><span class="o">=</span><span class="n">oldcolindex</span><span class="o">.</span><span class="n">optlevel</span><span class="p">,</span>
                        <span class="n">filters</span><span class="o">=</span><span class="n">oldcolindex</span><span class="o">.</span><span class="n">filters</span><span class="p">,</span> <span class="n">tmp_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_g_copy_with_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span>
                           <span class="n">title</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">chunkshape</span><span class="p">,</span> <span class="n">_log</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Private part of Leaf.copy() for each kind of leaf.&quot;&quot;&quot;</span>

        <span class="c1"># Get the private args for the Table flavor of copy()</span>
        <span class="n">sortby</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;sortby&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">propindexes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;propindexes&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">checkCSI</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;checkCSI&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Compute the correct indices.</span>
        <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_range_read</span><span class="p">(</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">warn_negstep</span><span class="o">=</span><span class="n">sortby</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># And the number of final rows</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">))</span>
        <span class="c1"># Create the new table and copy the selected data.</span>
        <span class="n">newtable</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                         <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">,</span> <span class="n">expectedrows</span><span class="o">=</span><span class="n">nrows</span><span class="p">,</span>
                         <span class="n">chunkshape</span><span class="o">=</span><span class="n">chunkshape</span><span class="p">,</span>
                         <span class="n">_log</span><span class="o">=</span><span class="n">_log</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_g_copy_rows</span><span class="p">(</span><span class="n">newtable</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">sortby</span><span class="p">,</span> <span class="n">checkCSI</span><span class="p">)</span>
        <span class="n">nbytes</span> <span class="o">=</span> <span class="n">newtable</span><span class="o">.</span><span class="n">nrows</span> <span class="o">*</span> <span class="n">newtable</span><span class="o">.</span><span class="n">rowsize</span>
        <span class="c1"># Generate equivalent indexes in the new table, if required.</span>
        <span class="k">if</span> <span class="n">propindexes</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_g_prop_indexes</span><span class="p">(</span><span class="n">newtable</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">newtable</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">)</span>

    <span class="c1"># This overloading of copy is needed here in order to document</span>
    <span class="c1"># the additional keywords for the Table case.</span>
<div class="viewcode-block" id="Table.copy">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Table.copy">[docs]</a>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newparent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">newname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">createparents</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy this table and return the new one.</span>

<span class="sd">        This method has the behavior and keywords described in</span>
<span class="sd">        :meth:`Leaf.copy`.  Moreover, it recognises the following additional</span>
<span class="sd">        keyword arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sortby</span>
<span class="sd">            If specified, and sortby corresponds to a column with an index,</span>
<span class="sd">            then the copy will be sorted by this index.  If you want to ensure</span>
<span class="sd">            a fully sorted order, the index must be a CSI one.  A reverse</span>
<span class="sd">            sorted copy can be achieved by specifying a negative value for the</span>
<span class="sd">            step keyword.  If sortby is omitted or None, the original table</span>
<span class="sd">            order is used.</span>
<span class="sd">        checkCSI</span>
<span class="sd">            If true and a CSI index does not exist for the sortby column, an</span>
<span class="sd">            error will be raised.  If false (the default), it does nothing.</span>
<span class="sd">            You can use this flag in order to explicitly check for the</span>
<span class="sd">            existence of a CSI index.</span>
<span class="sd">        propindexes</span>
<span class="sd">            If true, the existing indexes in the source table are propagated</span>
<span class="sd">            (created) to the new one.  If false (the default), the indexes are</span>
<span class="sd">            not propagated.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
            <span class="n">newparent</span><span class="p">,</span> <span class="n">newname</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">createparents</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flush the table buffers.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_iswritable</span><span class="p">():</span>
            <span class="c1"># Flush rows that remains to be appended</span>
            <span class="k">if</span> <span class="s1">&#39;row&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="o">.</span><span class="n">_flush_buffered_rows</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoindex</span><span class="p">:</span>
                <span class="c1"># Flush any unindexed row</span>
                <span class="n">rowsadded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flush_rows_to_index</span><span class="p">(</span><span class="n">_lastrow</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">rowsadded</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexedrows</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span> \
                    <span class="p">(</span><span class="s2">&quot;internal error: the number of indexed rows (</span><span class="si">%d</span><span class="s2">) &quot;</span>
                     <span class="s2">&quot;and rows in the table (</span><span class="si">%d</span><span class="s2">) is not equal; &quot;</span>
                     <span class="s2">&quot;please report this to the authors.&quot;</span>
                     <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexedrows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirtyindexes</span><span class="p">:</span>
                    <span class="c1"># Finally, re-index any dirty column</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reindex_dirty</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_g_pre_kill_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Code to be called before killing the node.&quot;&quot;&quot;</span>

        <span class="c1"># Flush the buffers before to clean-up them</span>
        <span class="c1"># self.flush()</span>
        <span class="c1"># It seems that flushing during the __del__ phase is a sure receipt for</span>
        <span class="c1"># bringing all kind of problems:</span>
        <span class="c1"># 1. Illegal Instruction</span>
        <span class="c1"># 2. Malloc(): trying to call free() twice</span>
        <span class="c1"># 3. Bus Error</span>
        <span class="c1"># 4. Segmentation fault</span>
        <span class="c1"># So, the best would be doing *nothing* at all in this __del__ phase.</span>
        <span class="c1"># As a consequence, the I/O will not be cleaned until a call to</span>
        <span class="c1"># Table.flush() would be done. This could lead to a potentially large</span>
        <span class="c1"># memory consumption.</span>
        <span class="c1"># NOTE: The user should make a call to Table.flush() whenever he has</span>
        <span class="c1">#       finished working with his table.</span>
        <span class="c1"># I&#39;ve added a Performance warning in order to compel the user to</span>
        <span class="c1"># call self.flush() before the table is being preempted.</span>
        <span class="c1"># F. Alted 2006-08-03</span>
        <span class="k">if</span> <span class="p">((</span><span class="s1">&#39;row&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="o">.</span><span class="n">_get_unsaved_nrows</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indexed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoindex</span> <span class="ow">and</span>
             <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unsaved_indexedrows</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirtyindexes</span><span class="p">))):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">((</span><span class="s2">&quot;table ``</span><span class="si">%s</span><span class="s2">`` is being preempted from alive nodes &quot;</span>
                           <span class="s2">&quot;without its buffers being flushed or with some &quot;</span>
                           <span class="s2">&quot;index being dirty.  This may lead to very &quot;</span>
                           <span class="s2">&quot;ineficient use of resources and even to fatal &quot;</span>
                           <span class="s2">&quot;errors in certain situations.  Please do a call &quot;</span>
                           <span class="s2">&quot;to the .flush() or .reindex_dirty() methods on &quot;</span>
                           <span class="s2">&quot;this table before start using other nodes.&quot;</span><span class="p">)</span>
                          <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">),</span> <span class="n">PerformanceWarning</span><span class="p">)</span>
        <span class="c1"># Get rid of the IO buffers (if they have been created at all)</span>
        <span class="n">mydict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="k">if</span> <span class="s1">&#39;_v_iobuf&#39;</span> <span class="ow">in</span> <span class="n">mydict</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">mydict</span><span class="p">[</span><span class="s1">&#39;_v_iobuf&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;_v_wdflts&#39;</span> <span class="ow">in</span> <span class="n">mydict</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">mydict</span><span class="p">[</span><span class="s1">&#39;_v_wdflts&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_f_close</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_isopen</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c1"># the node is already closed</span>

        <span class="c1"># .. note::</span>
        <span class="c1">#</span>
        <span class="c1">#   As long as ``Table`` objects access their indices on closing,</span>
        <span class="c1">#   ``File.close()`` will need to make *two separate passes*</span>
        <span class="c1">#   to first close ``Table`` objects and then ``Index`` hierarchies.</span>
        <span class="c1">#</span>

        <span class="c1"># Flush right now so the row object does not get in the middle.</span>
        <span class="k">if</span> <span class="n">flush</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="c1"># Some warnings can be issued after calling `self._g_set_location()`</span>
        <span class="c1"># in `self.__init__()`.  If warnings are turned into exceptions,</span>
        <span class="c1"># `self._g_post_init_hook` may not be called and `self.cols` not set.</span>
        <span class="c1"># One example of this is</span>
        <span class="c1"># ``test_create.createTestCase.test05_maxFieldsExceeded()``.</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
        <span class="k">if</span> <span class="n">cols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cols</span><span class="o">.</span><span class="n">_g_close</span><span class="p">()</span>

        <span class="c1"># Clean address cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clean_chunk_addrs</span><span class="p">()</span>

        <span class="c1"># Close myself as a leaf.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_f_close</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This provides column metainfo in addition to standard __str__&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexed</span><span class="p">:</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="si">%s</span>
<span class="s2">  description := </span><span class="si">%r</span>
<span class="s2">  byteorder := </span><span class="si">%r</span>
<span class="s2">  chunkshape := </span><span class="si">%r</span>
<span class="s2">  autoindex := </span><span class="si">%r</span>
<span class="s2">  colindexes := </span><span class="si">%r</span><span class="s2">&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">format</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">byteorder</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">chunkshape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoindex</span><span class="p">,</span>
                             <span class="n">_ColIndexes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colindexes</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="si">%s</span>
<span class="s2">  description := </span><span class="si">%r</span>
<span class="s2">  byteorder := </span><span class="si">%r</span>
<span class="s2">  chunkshape := </span><span class="si">%r</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> \
                <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">byteorder</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunkshape</span><span class="p">)</span></div>



<div class="viewcode-block" id="Cols">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Cols">[docs]</a>
<span class="k">class</span> <span class="nc">Cols</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Container for columns in a table or nested column.</span>

<span class="sd">    This class is used as an *accessor* to the columns in a table or nested</span>
<span class="sd">    column.  It supports the *natural naming* convention, so that you can</span>
<span class="sd">    access the different columns as attributes which lead to Column instances</span>
<span class="sd">    (for non-nested columns) or other Cols instances (for nested columns).</span>

<span class="sd">    For instance, if table.cols is a Cols instance with a column named col1</span>
<span class="sd">    under it, the later can be accessed as table.cols.col1. If col1 is nested</span>
<span class="sd">    and contains a col2 column, this can be accessed as table.cols.col1.col2</span>
<span class="sd">    and so on. Because of natural naming, the names of members start with</span>
<span class="sd">    special prefixes, like in the Group class (see :ref:`GroupClassDescr`).</span>

<span class="sd">    Like the Column class (see :ref:`ColumnClassDescr`), Cols supports item</span>
<span class="sd">    access to read and write ranges of values in the table or nested column.</span>


<span class="sd">    .. rubric:: Cols attributes</span>

<span class="sd">    .. attribute:: _v_colnames</span>

<span class="sd">        A list of the names of the columns hanging directly</span>
<span class="sd">        from the associated table or nested column.  The order of</span>
<span class="sd">        the names matches the order of their respective columns in</span>
<span class="sd">        the containing table.</span>

<span class="sd">    .. attribute:: _v_colpathnames</span>

<span class="sd">        A list of the pathnames of all the columns under the</span>
<span class="sd">        associated table or nested column (in preorder).  If it does</span>
<span class="sd">        not contain nested columns, this is exactly the same as the</span>
<span class="sd">        :attr:`Cols._v_colnames` attribute.</span>

<span class="sd">    .. attribute:: _v_desc</span>

<span class="sd">        The associated Description instance (see</span>
<span class="sd">        :ref:`DescriptionClassDescr`).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_v_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The parent Table instance (see :ref:`TableClassDescr`).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v__tableFile</span><span class="o">.</span><span class="n">_get_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v__tablePath</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">desc</span><span class="p">):</span>
        <span class="n">myDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="n">myDict</span><span class="p">[</span><span class="s1">&#39;_v__tableFile&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">_v_file</span>
        <span class="n">myDict</span><span class="p">[</span><span class="s1">&#39;_v__tablePath&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">_v_pathname</span>
        <span class="n">myDict</span><span class="p">[</span><span class="s1">&#39;_v_desc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span>
        <span class="n">myDict</span><span class="p">[</span><span class="s1">&#39;_v_colnames&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span><span class="o">.</span><span class="n">_v_names</span>
        <span class="n">myDict</span><span class="p">[</span><span class="s1">&#39;_v_colpathnames&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">_v_pathnames</span>
        <span class="c1"># Put the column in the local dictionary</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">desc</span><span class="o">.</span><span class="n">_v_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">desc</span><span class="o">.</span><span class="n">_v_types</span><span class="p">:</span>
                <span class="n">myDict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">desc</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">myDict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Cols</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">desc</span><span class="o">.</span><span class="n">_v_colobjects</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_g_update_table_location</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Updates the location information about the associated `table`.&quot;&quot;&quot;</span>

        <span class="n">myDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="n">myDict</span><span class="p">[</span><span class="s1">&#39;_v__tableFile&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">_v_file</span>
        <span class="n">myDict</span><span class="p">[</span><span class="s1">&#39;_v__tablePath&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">_v_pathname</span>

        <span class="c1"># Update the locations in individual columns.</span>
        <span class="k">for</span> <span class="n">colname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_colnames</span><span class="p">:</span>
            <span class="n">myDict</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span><span class="o">.</span><span class="n">_g_update_table_location</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>

<div class="viewcode-block" id="Cols.__len__">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Cols.__len__">[docs]</a>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the number of top level columns in table.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_colnames</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cols._f_col">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Cols._f_col">[docs]</a>
    <span class="k">def</span> <span class="nf">_f_col</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get an accessor to the column colname.</span>

<span class="sd">        This method returns a Column instance (see :ref:`ColumnClassDescr`) if</span>
<span class="sd">        the requested column is not nested, and a Cols instance (see</span>
<span class="sd">        :ref:`ColsClassDescr`) if it is.  You may use full column pathnames in</span>
<span class="sd">        colname.</span>

<span class="sd">        Calling cols._f_col(&#39;col1/col2&#39;) is equivalent to using cols.col1.col2.</span>
<span class="sd">        However, the first syntax is more intended for programmatic use.  It is</span>
<span class="sd">        also better if you want to access columns with names that are not valid</span>
<span class="sd">        Python identifiers.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">colname</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Parameter can only be an string. You passed &quot;</span>
                            <span class="s2">&quot;object: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">colname</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">colname</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span>
             <span class="n">colname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_colpathnames</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">colname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_colnames</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">((</span><span class="s2">&quot;Cols accessor ``</span><span class="si">%s</span><span class="s2">.cols</span><span class="si">%s</span><span class="s2">`` does not have a &quot;</span>
                            <span class="s2">&quot;column named ``</span><span class="si">%s</span><span class="s2">``&quot;</span><span class="p">)</span>
                           <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v__tablePath</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_desc</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">,</span>
                              <span class="n">colname</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g_col</span><span class="p">(</span><span class="n">colname</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_g_col</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Like `self._f_col()` but it does not check arguments.&quot;&quot;&quot;</span>

        <span class="c1"># Get the Column or Description object</span>
        <span class="n">inames</span> <span class="o">=</span> <span class="n">colname</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">iname</span> <span class="ow">in</span> <span class="n">inames</span><span class="p">:</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">iname</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">cols</span>

<div class="viewcode-block" id="Cols.__getitem__">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Cols.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a row or a range of rows from a table or nested column.</span>

<span class="sd">        If key argument is an integer, the corresponding nested type row is</span>
<span class="sd">        returned as a record of the current flavor. If key is a slice, the</span>
<span class="sd">        range of rows determined by it is returned as a structured array of the</span>
<span class="sd">        current flavor.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            record = table.cols[4]  # equivalent to table[4]</span>
<span class="sd">            recarray = table.cols.Info[4:1000:2]</span>

<span class="sd">        Those statements are equivalent to::</span>

<span class="sd">            nrecord = table.read(start=4)[0]</span>
<span class="sd">            nrecarray = table.read(start=4, stop=1000, step=2).field(&#39;Info&#39;)</span>

<span class="sd">        Here you can see how a mix of natural naming, indexing and slicing can</span>
<span class="sd">        be used as shorthands for the :meth:`Table.read` method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_table</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">nrows</span>
        <span class="k">if</span> <span class="n">is_idx</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="c1"># Index out of range protection</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;=</span> <span class="n">nrows</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Index out of range&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># To support negative values</span>
                <span class="n">key</span> <span class="o">+=</span> <span class="n">nrows</span>
            <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">colgroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_desc</span><span class="o">.</span><span class="n">_v_pathname</span>
            <span class="k">if</span> <span class="n">colgroup</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>  <span class="c1"># The root group</span>
                <span class="k">return</span> <span class="n">table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">crecord</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">crecord</span><span class="p">[</span><span class="n">colgroup</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span>
                <span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
            <span class="n">colgroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_desc</span><span class="o">.</span><span class="n">_v_pathname</span>
            <span class="k">if</span> <span class="n">colgroup</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>  <span class="c1"># The root group</span>
                <span class="k">return</span> <span class="n">table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">crecarray</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">crecarray</span><span class="p">,</span> <span class="s2">&quot;field&quot;</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">crecarray</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">colgroup</span><span class="p">)</span>  <span class="c1"># RecArray case</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">get_nested_field</span><span class="p">(</span><span class="n">crecarray</span><span class="p">,</span> <span class="n">colgroup</span><span class="p">)</span>  <span class="c1"># numpy case</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid index or slice: </span><span class="si">{</span><span class="n">key</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cols.__setitem__">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Cols.__setitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a row or a range of rows in a table or nested column.</span>

<span class="sd">        If key argument is an integer, the corresponding row is set to</span>
<span class="sd">        value. If key is a slice, the range of rows determined by it is set to</span>
<span class="sd">        value.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            table.cols[4] = record</span>
<span class="sd">            table.cols.Info[4:1000:2] = recarray</span>

<span class="sd">        Those statements are equivalent to::</span>

<span class="sd">            table.modify_rows(4, rows=record)</span>
<span class="sd">            table.modify_column(4, 1000, 2, colname=&#39;Info&#39;, column=recarray)</span>

<span class="sd">        Here you can see how a mix of natural naming, indexing and slicing</span>
<span class="sd">        can be used as shorthands for the :meth:`Table.modify_rows` and</span>
<span class="sd">        :meth:`Table.modify_column` methods.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_table</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">nrows</span>
        <span class="k">if</span> <span class="n">is_idx</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="c1"># Index out of range protection</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;=</span> <span class="n">nrows</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Index out of range&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># To support negative values</span>
                <span class="n">key</span> <span class="o">+=</span> <span class="n">nrows</span>
            <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span>
                <span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid index or slice: </span><span class="si">{</span><span class="n">key</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Actually modify the correct columns</span>
        <span class="n">colgroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_desc</span><span class="o">.</span><span class="n">_v_pathname</span>
        <span class="k">if</span> <span class="n">colgroup</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>  <span class="c1"># The root group</span>
            <span class="n">table</span><span class="o">.</span><span class="n">modify_rows</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">table</span><span class="o">.</span><span class="n">modify_column</span><span class="p">(</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">colname</span><span class="o">=</span><span class="n">colgroup</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_g_close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># First, close the columns (ie possible indices open)</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_colnames</span><span class="p">:</span>
            <span class="n">colobj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g_col</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">colobj</span><span class="p">,</span> <span class="n">Column</span><span class="p">):</span>
                <span class="n">colobj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="c1"># Delete the reference to column</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">colobj</span><span class="o">.</span><span class="n">_g_close</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The string representation for this object.&quot;&quot;&quot;</span>

        <span class="c1"># The pathname</span>
        <span class="n">descpathname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_desc</span><span class="o">.</span><span class="n">_v_pathname</span>
        <span class="k">if</span> <span class="n">descpathname</span><span class="p">:</span>
            <span class="n">descpathname</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">descpathname</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_v__tablePath</span><span class="si">}</span><span class="s2">.cols</span><span class="si">{</span><span class="n">descpathname</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">), &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_colnames</span><span class="p">)</span><span class="si">}</span><span class="s2"> columns&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A detailed string representation for this object.&quot;&quot;&quot;</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">!s}</span><span class="s1">&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_colnames</span><span class="p">:</span>
            <span class="c1"># Get this class name</span>
            <span class="n">classname</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="c1"># The type</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_desc</span><span class="o">.</span><span class="n">_v_dtypes</span><span class="p">:</span>
                <span class="n">tcol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_desc</span><span class="o">.</span><span class="n">_v_dtypes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="c1"># The shape for this column</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_table</span><span class="o">.</span><span class="n">nrows</span><span class="p">,)</span> <span class="o">+</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_v_desc</span><span class="o">.</span><span class="n">_v_dtypes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tcol</span> <span class="o">=</span> <span class="s2">&quot;Description&quot;</span>
                <span class="c1"># Description doesn&#39;t have a shape currently</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="p">()</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">classname</span><span class="si">}{</span><span class="n">shape</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">tcol</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span></div>



<div class="viewcode-block" id="Column">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Column">[docs]</a>
<span class="k">class</span> <span class="nc">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Accessor for a non-nested column in a table.</span>

<span class="sd">    Each instance of this class is associated with one *non-nested* column of a</span>
<span class="sd">    table. These instances are mainly used to read and write data from the</span>
<span class="sd">    table columns using item access (like the Cols class - see</span>
<span class="sd">    :ref:`ColsClassDescr`), but there are a few other associated methods to</span>
<span class="sd">    deal with indexes.</span>

<span class="sd">    .. rubric:: Column attributes</span>

<span class="sd">    .. attribute:: descr</span>

<span class="sd">        The Description (see :ref:`DescriptionClassDescr`) instance of the</span>
<span class="sd">        parent table or nested column.</span>

<span class="sd">    .. attribute:: name</span>

<span class="sd">        The name of the associated column.</span>

<span class="sd">    .. attribute:: pathname</span>

<span class="sd">        The complete pathname of the associated column (the same as</span>
<span class="sd">        Column.name if the column is not inside a nested column).</span>

<span class="sd">    .. attribute:: attrs</span>

<span class="sd">        Column attributes (see :ref:`ColClassDescr`).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    table</span>
<span class="sd">        The parent table instance</span>
<span class="sd">    name</span>
<span class="sd">        The name of the column that is associated with this object</span>
<span class="sd">    descr</span>
<span class="sd">        The parent description object</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@lazyattr</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The NumPy dtype that most closely matches this column.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">descr</span><span class="o">.</span><span class="n">_v_dtypes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">base</span>  <span class="c1"># Get rid of shape info</span>

    <span class="nd">@lazyattr</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The PyTables type of the column (a string).&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">descr</span><span class="o">.</span><span class="n">_v_types</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The parent Table instance (see :ref:`TableClassDescr`).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_table_file</span><span class="o">.</span><span class="n">_get_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_table_path</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The Index instance (see :ref:`IndexClassDescr`) associated with this</span>
<span class="sd">        column (None if the column is not indexed).&quot;&quot;&quot;</span>
        <span class="n">indexPath</span> <span class="o">=</span> <span class="n">_index_pathname_of_column_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_table_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_table_file</span><span class="o">.</span><span class="n">_get_node</span><span class="p">(</span><span class="n">indexPath</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">NodeError</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># The column is not indexed</span>
        <span class="k">return</span> <span class="n">index</span>

    <span class="nd">@lazyattr</span>
    <span class="k">def</span> <span class="nf">_itemtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">descr</span><span class="o">.</span><span class="n">_v_dtypes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The shape of this column.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">nrows</span><span class="p">,)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">descr</span><span class="o">.</span><span class="n">_v_dtypes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_indexed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;True if the column is indexed, false otherwise.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">maindim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;&quot;The dimension along which iterators work. Its value is 0 (i.e. the</span>
<span class="sd">        first dimension).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">descr</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_table_file</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">_v_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_table_path</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">_v_pathname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The name of the associated column.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span> <span class="o">=</span> <span class="n">descr</span><span class="o">.</span><span class="n">_v_colobjects</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">_v_pathname</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The complete pathname of the associated column (the same as</span>
<span class="sd">        Column.name if the column is not inside a nested column).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descr</span> <span class="o">=</span> <span class="n">descr</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The Description (see :ref:`DescriptionClassDescr`) instance of the</span>
<span class="sd">        parent table or nested column.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span> <span class="o">=</span> <span class="n">ColumnAttributeSet</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_g_update_table_location</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Updates the location information about the associated `table`.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_table_file</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">_v_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_table_path</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">_v_pathname</span>

<div class="viewcode-block" id="Column.__len__">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Column.__len__">[docs]</a>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the number of elements in the column.</span>

<span class="sd">        This matches the length in rows of the parent table.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">nrows</span></div>


<div class="viewcode-block" id="Column.__getitem__">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Column.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a row or a range of rows from a column.</span>

<span class="sd">        If key argument is an integer, the corresponding element in the column</span>
<span class="sd">        is returned as an object of the current flavor.  If key is a slice, the</span>
<span class="sd">        range of elements determined by it is returned as an array of the</span>
<span class="sd">        current flavor.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            print(&quot;Column handlers:&quot;)</span>
<span class="sd">            for name in table.colnames:</span>
<span class="sd">                print(table.cols._f_col(name))</span>
<span class="sd">                print(&quot;Select table.cols.name[1]--&gt;&quot;, table.cols.name[1])</span>
<span class="sd">                print(&quot;Select table.cols.name[1:2]--&gt;&quot;, table.cols.name[1:2])</span>
<span class="sd">                print(&quot;Select table.cols.name[:]--&gt;&quot;, table.cols.name[:])</span>
<span class="sd">                print(&quot;Select table.cols._f_col(&#39;name&#39;)[:]--&gt;&quot;,</span>
<span class="sd">                                                table.cols._f_col(&#39;name&#39;)[:])</span>

<span class="sd">        The output of this for a certain arbitrary table is::</span>

<span class="sd">            Column handlers:</span>
<span class="sd">            /table.cols.name (Column(), string, idx=None)</span>
<span class="sd">            /table.cols.lati (Column(), int32, idx=None)</span>
<span class="sd">            /table.cols.longi (Column(), int32, idx=None)</span>
<span class="sd">            /table.cols.vector (Column(2,), int32, idx=None)</span>
<span class="sd">            /table.cols.matrix2D (Column(2, 2), float64, idx=None)</span>
<span class="sd">            Select table.cols.name[1]--&gt; Particle:     11</span>
<span class="sd">            Select table.cols.name[1:2]--&gt; [&#39;Particle:     11&#39;]</span>
<span class="sd">            Select table.cols.name[:]--&gt; [&#39;Particle:     10&#39;</span>
<span class="sd">             &#39;Particle:     11&#39; &#39;Particle:     12&#39;</span>
<span class="sd">             &#39;Particle:     13&#39; &#39;Particle:     14&#39;]</span>
<span class="sd">            Select table.cols._f_col(&#39;name&#39;)[:]--&gt; [&#39;Particle:     10&#39;</span>
<span class="sd">             &#39;Particle:     11&#39; &#39;Particle:     12&#39;</span>
<span class="sd">             &#39;Particle:     13&#39; &#39;Particle:     14&#39;]</span>

<span class="sd">        See the :file:`examples/table2.py` file for a more complete example.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span>

        <span class="c1"># Generalized key support not there yet, but at least allow</span>
        <span class="c1"># for a tuple with one single element (the main dimension).</span>
        <span class="c1"># (key,) --&gt; key</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">is_idx</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="c1"># Index out of range protection</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;=</span> <span class="n">table</span><span class="o">.</span><span class="n">nrows</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Index out of range&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># To support negative values</span>
                <span class="n">key</span> <span class="o">+=</span> <span class="n">table</span><span class="o">.</span><span class="n">nrows</span>
            <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span>
                <span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; key type is not valid in this context&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate through all items in the column.&quot;&quot;&quot;</span>

        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span>
        <span class="n">itemsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="n">nrowsinbuf</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;IO_BUFFER_SIZE&#39;</span><span class="p">]</span> <span class="o">//</span> <span class="n">itemsize</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nrowsinbuf</span><span class="p">,</span> <span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_itemtype</span><span class="p">)</span>
        <span class="n">max_row</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">start_row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">nrowsinbuf</span><span class="p">):</span>
            <span class="n">end_row</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start_row</span> <span class="o">+</span> <span class="n">nrowsinbuf</span><span class="p">,</span> <span class="n">max_row</span><span class="p">)</span>
            <span class="n">buf_slice</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">end_row</span> <span class="o">-</span> <span class="n">start_row</span><span class="p">]</span>
            <span class="n">table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">start_row</span><span class="p">,</span> <span class="n">end_row</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">,</span>
                       <span class="n">out</span><span class="o">=</span><span class="n">buf_slice</span><span class="p">)</span>
            <span class="k">yield from</span> <span class="n">buf_slice</span>

<div class="viewcode-block" id="Column.__setitem__">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Column.__setitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a row or a range of rows in a column.</span>

<span class="sd">        If key argument is an integer, the corresponding element is set to</span>
<span class="sd">        value.  If key is a slice, the range of elements determined by it is</span>
<span class="sd">        set to value.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            # Modify row 1</span>
<span class="sd">            table.cols.col1[1] = -1</span>

<span class="sd">            # Modify rows 1 and 3</span>
<span class="sd">            table.cols.col1[1::2] = [2,3]</span>

<span class="sd">        Which is equivalent to::</span>

<span class="sd">            # Modify row 1</span>
<span class="sd">            table.modify_columns(start=1, columns=[[-1]], names=[&#39;col1&#39;])</span>

<span class="sd">            # Modify rows 1 and 3</span>
<span class="sd">            columns = np.rec.fromarrays([[2,3]], formats=&#39;i4&#39;)</span>
<span class="sd">            table.modify_columns(start=1, step=2, columns=columns,</span>
<span class="sd">                                 names=[&#39;col1&#39;])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span>
        <span class="n">table</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_check_writable</span><span class="p">()</span>

        <span class="c1"># Generalized key support not there yet, but at least allow</span>
        <span class="c1"># for a tuple with one single element (the main dimension).</span>
        <span class="c1"># (key,) --&gt; key</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">is_idx</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="c1"># Index out of range protection</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;=</span> <span class="n">table</span><span class="o">.</span><span class="n">nrows</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Index out of range&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># To support negative values</span>
                <span class="n">key</span> <span class="o">+=</span> <span class="n">table</span><span class="o">.</span><span class="n">nrows</span>
            <span class="k">return</span> <span class="n">table</span><span class="o">.</span><span class="n">modify_column</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                                       <span class="p">[[</span><span class="n">value</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span>
                <span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">table</span><span class="o">.</span><span class="n">modify_column</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span>
                                       <span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Non-valid index or slice: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span></div>


<div class="viewcode-block" id="Column.create_index">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Column.create_index">[docs]</a>
    <span class="k">def</span> <span class="nf">create_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">optlevel</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;medium&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">tmp_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_blocksizes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_testmode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">_verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an index for this column.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            In some situations it is useful to get a completely sorted</span>
<span class="sd">            index (CSI).  For those cases, it is best to use the</span>
<span class="sd">            :meth:`Column.create_csindex` method instead.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        optlevel : int</span>
<span class="sd">            The optimization level for building the index.  The levels ranges</span>
<span class="sd">            from 0 (no optimization) up to 9 (maximum optimization).  Higher</span>
<span class="sd">            levels of optimization mean better chances for reducing the entropy</span>
<span class="sd">            of the index at the price of using more CPU, memory and I/O</span>
<span class="sd">            resources for creating the index.</span>
<span class="sd">        kind : str</span>
<span class="sd">            The kind of the index to be built.  It can take the &#39;ultralight&#39;,</span>
<span class="sd">            &#39;light&#39;, &#39;medium&#39; or &#39;full&#39; values.  Lighter kinds (&#39;ultralight&#39;</span>
<span class="sd">            and &#39;light&#39;) mean that the index takes less space on disk, but will</span>
<span class="sd">            perform queries slower.  Heavier kinds (&#39;medium&#39; and &#39;full&#39;) mean</span>
<span class="sd">            better chances for reducing the entropy of the index (increasing</span>
<span class="sd">            the query speed) at the price of using more disk space as well as</span>
<span class="sd">            more CPU, memory and I/O resources for creating the index.</span>

<span class="sd">            Note that selecting a full kind with an optlevel of 9 (the maximum)</span>
<span class="sd">            guarantees the creation of an index with zero entropy, that is, a</span>
<span class="sd">            completely sorted index (CSI) - provided that the number of rows in</span>
<span class="sd">            the table does not exceed the 2**48 figure (that is more than 100</span>
<span class="sd">            trillions of rows).  See :meth:`Column.create_csindex` method for a</span>
<span class="sd">            more direct way to create a CSI index.</span>
<span class="sd">        filters : Filters</span>
<span class="sd">            Specify the Filters instance used to compress the index.  If None,</span>
<span class="sd">            default index filters will be used (currently, zlib level 1 with</span>
<span class="sd">            shuffling).</span>
<span class="sd">        tmp_dir</span>
<span class="sd">            When kind is other than &#39;ultralight&#39;, a temporary file is created</span>
<span class="sd">            during the index build process.  You can use the tmp_dir argument</span>
<span class="sd">            to specify the directory for this temporary file.  The default is</span>
<span class="sd">            to create it in the same directory as the file containing the</span>
<span class="sd">            original table.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">kinds</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ultralight&#39;</span><span class="p">,</span> <span class="s1">&#39;light&#39;</span><span class="p">,</span> <span class="s1">&#39;medium&#39;</span><span class="p">,</span> <span class="s1">&#39;full&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kinds</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Kind must have any of these values: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">kinds</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optlevel</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">optlevel</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">optlevel</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Optimization level must be an integer in the &quot;</span>
                             <span class="s2">&quot;range 0-9&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filters</span> <span class="o">=</span> <span class="n">default_index_filters</span>
        <span class="k">if</span> <span class="n">tmp_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmp_dir</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_table_file</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">Path</span><span class="p">(</span><span class="n">tmp_dir</span><span class="p">)</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Temporary directory &#39;</span><span class="si">{</span><span class="n">tmp_dir</span><span class="si">}</span><span class="s2">&#39; does not exist&quot;</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_blocksizes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_blocksizes</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">_blocksizes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;_blocksizes must be a tuple with exactly 4 &quot;</span>
                             <span class="s2">&quot;elements&quot;</span><span class="p">)</span>
        <span class="n">idxrows</span> <span class="o">=</span> <span class="n">_column__create_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">optlevel</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span>
                                        <span class="n">tmp_dir</span><span class="p">,</span> <span class="n">_blocksizes</span><span class="p">,</span> <span class="n">_verbose</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SizeType</span><span class="p">(</span><span class="n">idxrows</span><span class="p">)</span></div>


<div class="viewcode-block" id="Column.create_csindex">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Column.create_csindex">[docs]</a>
    <span class="k">def</span> <span class="nf">create_csindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmp_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">_blocksizes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_testmode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a completely sorted index (CSI) for this column.</span>

<span class="sd">        This method guarantees the creation of an index with zero entropy, that</span>
<span class="sd">        is, a completely sorted index (CSI) -- provided that the number of rows</span>
<span class="sd">        in the table does not exceed the 2**48 figure (that is more than 100</span>
<span class="sd">        trillions of rows).  A CSI index is needed for some table methods (like</span>
<span class="sd">        :meth:`Table.itersorted` or :meth:`Table.read_sorted`) in order to</span>
<span class="sd">        ensure completely sorted results.</span>

<span class="sd">        For the meaning of filters and tmp_dir arguments see</span>
<span class="sd">        :meth:`Column.create_index`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is equivalent to</span>
<span class="sd">        Column.create_index(optlevel=9, kind=&#39;full&#39;, ...).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_index</span><span class="p">(</span>
            <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">optlevel</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">,</span> <span class="n">tmp_dir</span><span class="o">=</span><span class="n">tmp_dir</span><span class="p">,</span>
            <span class="n">_blocksizes</span><span class="o">=</span><span class="n">_blocksizes</span><span class="p">,</span> <span class="n">_testmode</span><span class="o">=</span><span class="n">_testmode</span><span class="p">,</span> <span class="n">_verbose</span><span class="o">=</span><span class="n">_verbose</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_do_reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirty</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Common code for reindex() and reindex_dirty() codes.&quot;&quot;&quot;</span>

        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>
        <span class="n">dodirty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">dirty</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">index</span><span class="o">.</span><span class="n">dirty</span><span class="p">:</span>
            <span class="n">dodirty</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dodirty</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_table_file</span><span class="o">.</span><span class="n">_check_writable</span><span class="p">()</span>
            <span class="c1"># Get the old index parameters</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">kind</span>
            <span class="n">optlevel</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">optlevel</span>
            <span class="n">filters</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">filters</span>
            <span class="c1"># We *need* to tell the index that it is going to be undirty.</span>
            <span class="c1"># This is needed here so as to unnail() the condition cache.</span>
            <span class="n">index</span><span class="o">.</span><span class="n">dirty</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># Delete the existing Index</span>
            <span class="n">index</span><span class="o">.</span><span class="n">_f_remove</span><span class="p">()</span>
            <span class="c1"># Create a new Index with the previous parameters</span>
            <span class="k">return</span> <span class="n">SizeType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">create_index</span><span class="p">(</span>
                <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">optlevel</span><span class="o">=</span><span class="n">optlevel</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SizeType</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># The column is not intended for indexing</span>

<div class="viewcode-block" id="Column.reindex">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Column.reindex">[docs]</a>
    <span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Recompute the index associated with this column.</span>

<span class="sd">        This can be useful when you suspect that, for any reason,</span>
<span class="sd">        the index information is no longer valid and you want to rebuild it.</span>

<span class="sd">        This method does nothing if the column is not indexed.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_do_reindex</span><span class="p">(</span><span class="n">dirty</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="Column.reindex_dirty">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Column.reindex_dirty">[docs]</a>
    <span class="k">def</span> <span class="nf">reindex_dirty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Recompute the associated index only if it is dirty.</span>

<span class="sd">        This can be useful when you have set :attr:`Table.autoindex` to false</span>
<span class="sd">        for the table and you want to update the column&#39;s index after an</span>
<span class="sd">        invalidating index operation (like :meth:`Table.remove_rows`).</span>

<span class="sd">        This method does nothing if the column is not indexed.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_do_reindex</span><span class="p">(</span><span class="n">dirty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="Column.remove_index">
<a class="viewcode-back" href="../../usersguide/libref/structured_storage.html#tables.Column.remove_index">[docs]</a>
    <span class="k">def</span> <span class="nf">remove_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove the index associated with this column.</span>

<span class="sd">        This method does nothing if the column is not indexed. The removed</span>
<span class="sd">        index can be created again by calling the :meth:`Column.create_index`</span>
<span class="sd">        method.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_table_file</span><span class="o">.</span><span class="n">_check_writable</span><span class="p">()</span>

        <span class="c1"># Remove the index if existing.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>
            <span class="n">index</span><span class="o">.</span><span class="n">_f_remove</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">_set_column_indexing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Close this column.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The string representation for this object.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_table_path</span><span class="si">}</span><span class="s2">.cols.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;.&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">descr</span><span class="o">.</span><span class="n">_v_types</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="si">}</span><span class="s2">, idx=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A detailed string representation for this object.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@lazyattr</span>
    <span class="k">def</span> <span class="nf">_v_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">descr</span><span class="o">.</span><span class="n">_v_colobjects</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">_v_pos</span>

    <span class="nd">@lazyattr</span>
    <span class="k">def</span> <span class="nf">_v_col_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">descr</span><span class="o">.</span><span class="n">_v_colobjects</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">_v_col_attrs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_attrs</span></div>



<span class="k">class</span> <span class="nc">ColumnAttributeSet</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;_v_tableattrs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">attrs</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;_v_fieldindex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">_v_pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;_v_column_reference&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>

        <span class="c1"># Check if this column has _v_col_attrs set and translate them into</span>
        <span class="c1"># the table attribute format</span>
        <span class="k">for</span> <span class="n">col_attr_key</span><span class="p">,</span> <span class="n">col_attr_val</span> <span class="ow">in</span> <span class="n">column</span><span class="o">.</span><span class="n">_v_col_attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">col_attr_key</span><span class="p">,</span> <span class="n">col_attr_val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">issystemcolumnname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks whether a key is a reserved attribute name, or should be passed through.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;_v_tableattrs&#39;</span><span class="p">,</span> <span class="s1">&#39;_v_fieldindex&#39;</span><span class="p">,</span> <span class="s1">&#39;_v_column_reference&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prefixes a key with a special pattern for storing with table attributes&quot;&quot;&quot;</span>
        <span class="n">field_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;_v_fieldindex&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="s1">&#39;FIELD_</span><span class="si">%i</span><span class="s1">_ATTR_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">field_index</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieves a PyTables attribute for this column&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">issystemcolumnname</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_tableattrs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prefix</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets a PyTables attribute for this column&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">issystemcolumnname</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_tableattrs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prefix</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A dictionary-like interface for __getattr__&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">issystemcolumnname</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_tableattrs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_prefix</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A dictionary-like interface for __setattr__&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">issystemcolumnname</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_tableattrs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_prefix</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deletes the attribute for this column&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">issystemcolumnname</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Deleting system attributes is prohibited&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_tableattrs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prefix</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A dictionary-like interface for __delattr__&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">issystemcolumnname</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Deleting system attributes is prohibited&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_tableattrs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_prefix</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_f_rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oldattrname</span><span class="p">,</span> <span class="n">newattrname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rename an attribute from oldattrname to newattrname.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">oldattrname</span> <span class="o">==</span> <span class="n">newattrname</span><span class="p">:</span>
            <span class="c1"># Do nothing</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">issystemcolumnname</span><span class="p">(</span><span class="n">oldattrname</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Renaming system attributes is prohibited&#39;</span><span class="p">)</span>

        <span class="c1"># First, fetch the value of the oldattrname</span>
        <span class="n">attrvalue</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oldattrname</span><span class="p">)</span>

        <span class="c1"># Now, create the new attribute</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newattrname</span><span class="p">,</span> <span class="n">attrvalue</span><span class="p">)</span>

        <span class="c1"># Finally, remove the old attribute</span>
        <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oldattrname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_f_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy attributes to another column&quot;&quot;&quot;</span>

        <span class="c1"># Is there a better way to do this?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">Column</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;destination object is not a column: </span><span class="si">{</span><span class="n">where</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">where</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the list of attributes for this column&quot;&quot;&quot;</span>
        <span class="n">col_prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prefix</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_prefix</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="n">length</span><span class="p">:]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_tableattrs</span><span class="o">.</span><span class="n">_v_attrnames</span> <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">col_prefix</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns whether a key is in the attribute set&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The string representation for this object.&quot;&quot;&quot;</span>

        <span class="n">pathname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_tableattrs</span><span class="o">.</span><span class="n">_v__nodepath</span>
        <span class="n">classname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_column_reference</span><span class="p">()</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>  <span class="c1"># self._v_tableattrs._v_node.__class__.__name__</span>
        <span class="n">attrnumber</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">columnname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_column_reference</span><span class="p">()</span><span class="o">.</span><span class="n">name</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pathname</span><span class="si">}</span><span class="s2">.cols.</span><span class="si">{</span><span class="n">columnname</span><span class="si">}</span><span class="s2">._v_attrs (</span><span class="si">{</span><span class="n">classname</span><span class="si">}</span><span class="s2">), </span><span class="si">{</span><span class="n">attrnumber</span><span class="si">}</span><span class="s2"> attributes&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A detailed string representation for this object.&quot;&quot;&quot;</span>

        <span class="c1"># print additional info only if there are attributes to show</span>
        <span class="n">attrnames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">attrnames</span><span class="p">:</span>
            <span class="n">rep</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s1"> := </span><span class="si">{</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">attr</span><span class="p">)</span><span class="si">!r}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrnames</span><span class="p">]</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">!s}</span><span class="s2">:</span><span class="se">\n</span><span class="s2">   [&quot;</span> <span class="o">+</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">    &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rep</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2011â€“2023, PyTables maintainers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>