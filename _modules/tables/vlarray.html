<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tables.vlarray &mdash; PyTables 3.7.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
 
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-111342564-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-111342564-1');
</script>


</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html">
            <img src="../../_static/logo-pytables-small.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                3.7.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../usersguide/index.html">Userâ€™s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cookbook/index.html">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../other_material.html">Other Material</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../MIGRATING_TO_3.x.html">Migrating from 2.x to 3.x</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../downloads.html">Downloads</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release_notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../project_pointers.html">Project pointers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev_team.html">Development Team</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PyTables</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>tables.vlarray</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tables.vlarray</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Here is defined the VLArray class.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">hdf5extension</span>
<span class="kn">from</span> <span class="nn">.atom</span> <span class="kn">import</span> <span class="n">ObjectAtom</span><span class="p">,</span> <span class="n">VLStringAtom</span><span class="p">,</span> <span class="n">VLUnicodeAtom</span>
<span class="kn">from</span> <span class="nn">.flavor</span> <span class="kn">import</span> <span class="n">internal_to_flavor</span>
<span class="kn">from</span> <span class="nn">.leaf</span> <span class="kn">import</span> <span class="n">Leaf</span><span class="p">,</span> <span class="n">calc_chunksize</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">convert_to_np_atom</span><span class="p">,</span> <span class="n">convert_to_np_atom2</span><span class="p">,</span> <span class="n">idx2long</span><span class="p">,</span> <span class="n">correct_byteorder</span><span class="p">,</span>
    <span class="n">SizeType</span><span class="p">,</span> <span class="n">is_idx</span><span class="p">,</span> <span class="n">lazyattr</span><span class="p">)</span>


<span class="c1"># default version for VLARRAY objects</span>
<span class="c1"># obversion = &quot;1.0&quot;    # initial version</span>
<span class="c1"># obversion = &quot;1.0&quot;    # add support for complex datatypes</span>
<span class="c1"># obversion = &quot;1.1&quot;    # This adds support for time datatypes.</span>
<span class="c1"># obversion = &quot;1.2&quot;    # This adds support for enumerated datatypes.</span>
<span class="c1"># obversion = &quot;1.3&quot;     # Introduced &#39;PSEUDOATOM&#39; attribute.</span>
<span class="n">obversion</span> <span class="o">=</span> <span class="s2">&quot;1.4&quot;</span>    <span class="c1"># Numeric and numarray flavors are gone.</span>


<div class="viewcode-block" id="VLArray"><a class="viewcode-back" href="../../usersguide/libref/homogenous_storage.html#tables.VLArray">[docs]</a><span class="k">class</span> <span class="nc">VLArray</span><span class="p">(</span><span class="n">hdf5extension</span><span class="o">.</span><span class="n">VLArray</span><span class="p">,</span> <span class="n">Leaf</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents variable length (ragged) arrays in an HDF5 file.</span>

<span class="sd">    Instances of this class represent array objects in the object tree</span>
<span class="sd">    with the property that their rows can have a *variable* number of</span>
<span class="sd">    homogeneous elements, called *atoms*. Like Table datasets (see</span>
<span class="sd">    :ref:`TableClassDescr`), variable length arrays can have only one</span>
<span class="sd">    dimension, and the elements (atoms) of their rows can be fully</span>
<span class="sd">    multidimensional.</span>

<span class="sd">    When reading a range of rows from a VLArray, you will *always* get</span>
<span class="sd">    a Python list of objects of the current flavor (each of them for a</span>
<span class="sd">    row), which may have different lengths.</span>

<span class="sd">    This class provides methods to write or read data to or from</span>
<span class="sd">    variable length array objects in the file. Note that it also</span>
<span class="sd">    inherits all the public attributes and methods that Leaf (see</span>
<span class="sd">    :ref:`LeafClassDescr`) already provides.</span>

<span class="sd">    .. note::</span>

<span class="sd">          VLArray objects also support compression although compression</span>
<span class="sd">          is only performed on the data structures used internally by</span>
<span class="sd">          the HDF5 to take references of the location of the variable</span>
<span class="sd">          length data. Data itself (the raw data) are not compressed</span>
<span class="sd">          or filtered.</span>

<span class="sd">          Please refer to the `VLTypes Technical Note</span>
<span class="sd">          &lt;https://support.hdfgroup.org/HDF5/doc/TechNotes/VLTypes.html&gt;`_</span>
<span class="sd">          for more details on the topic.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parentnode</span>
<span class="sd">        The parent :class:`Group` object.</span>
<span class="sd">    name : str</span>
<span class="sd">        The name of this node in its parent group.</span>
<span class="sd">    atom</span>
<span class="sd">        An `Atom` instance representing the *type* and *shape* of the atomic</span>
<span class="sd">        objects to be saved.</span>
<span class="sd">    title</span>
<span class="sd">        A description for this node (it sets the ``TITLE`` HDF5 attribute on</span>
<span class="sd">        disk).</span>
<span class="sd">    filters</span>
<span class="sd">        An instance of the `Filters` class that provides information about the</span>
<span class="sd">        desired I/O filters to be applied during the life of this object.</span>
<span class="sd">    expectedrows</span>
<span class="sd">        A user estimate about the number of row elements that will</span>
<span class="sd">        be added to the growable dimension in the `VLArray` node.</span>
<span class="sd">        If not provided, the default value is ``EXPECTED_ROWS_VLARRAY``</span>
<span class="sd">        (see ``tables/parameters.py``).  If you plan to create either</span>
<span class="sd">        a much smaller or a much bigger `VLArray` try providing a guess;</span>
<span class="sd">        this will optimize the HDF5 B-Tree creation and management</span>
<span class="sd">        process time and the amount of memory used.</span>

<span class="sd">        .. versionadded:: 3.0</span>

<span class="sd">    chunkshape</span>
<span class="sd">        The shape of the data chunk to be read or written in a single HDF5 I/O</span>
<span class="sd">        operation.  Filters are applied to those chunks of data.  The</span>
<span class="sd">        dimensionality of `chunkshape` must be 1.  If ``None``, a sensible</span>
<span class="sd">        value is calculated (which is recommended).</span>
<span class="sd">    byteorder</span>
<span class="sd">        The byteorder of the data *on disk*, specified as &#39;little&#39; or &#39;big&#39;.</span>
<span class="sd">        If this is not specified, the byteorder is that of the platform.</span>

<span class="sd">    track_times</span>
<span class="sd">        Whether time data associated with the leaf are recorded (object</span>
<span class="sd">        access time, raw data modification time, metadata change time, object</span>
<span class="sd">        birth time); default True.  Semantics of these times depend on their</span>
<span class="sd">        implementation in the HDF5 library: refer to documentation of the</span>
<span class="sd">        H5O_info_t data structure.  As of HDF5 1.8.15, only ctime (metadata</span>
<span class="sd">        change time) is implemented.</span>

<span class="sd">        .. versionadded:: 3.4.3</span>


<span class="sd">    .. versionchanged:: 3.0</span>
<span class="sd">       *parentNode* renamed into *parentnode*.</span>

<span class="sd">    .. versionchanged:: 3.0</span>
<span class="sd">       The *expectedsizeinMB* parameter has been replaced by *expectedrows*.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    See below a small example of the use of the VLArray class.  The code is</span>
<span class="sd">    available in :file:`examples/vlarray1.py`::</span>

<span class="sd">        import numpy as np</span>
<span class="sd">        import tables as tb</span>

<span class="sd">        # Create a VLArray:</span>
<span class="sd">        fileh = tb.open_file(&#39;vlarray1.h5&#39;, mode=&#39;w&#39;)</span>
<span class="sd">        vlarray = fileh.create_vlarray(</span>
<span class="sd">            fileh.root,</span>
<span class="sd">            &#39;vlarray1&#39;,</span>
<span class="sd">            tb.Int32Atom(shape=()),</span>
<span class="sd">            &quot;ragged array of ints&quot;,</span>
<span class="sd">            filters=tb.Filters(1))</span>

<span class="sd">        # Append some (variable length) rows:</span>
<span class="sd">        vlarray.append(np.array([5, 6]))</span>
<span class="sd">        vlarray.append(np.array([5, 6, 7]))</span>
<span class="sd">        vlarray.append([5, 6, 9, 8])</span>

<span class="sd">        # Now, read it through an iterator:</span>
<span class="sd">        print(&#39;--&gt;&#39;, vlarray.title)</span>
<span class="sd">        for x in vlarray:</span>
<span class="sd">            print(&#39;%s[%d]--&gt; %s&#39; % (vlarray.name, vlarray.nrow, x))</span>

<span class="sd">        # Now, do the same with native Python strings.</span>
<span class="sd">        vlarray2 = fileh.create_vlarray(</span>
<span class="sd">            fileh.root,</span>
<span class="sd">            &#39;vlarray2&#39;,</span>
<span class="sd">            tb.StringAtom(itemsize=2),</span>
<span class="sd">            &quot;ragged array of strings&quot;,</span>
<span class="sd">            filters=tb.Filters(1))</span>
<span class="sd">        vlarray2.flavor = &#39;python&#39;</span>

<span class="sd">        # Append some (variable length) rows:</span>
<span class="sd">        print(&#39;--&gt;&#39;, vlarray2.title)</span>
<span class="sd">        vlarray2.append([&#39;5&#39;, &#39;66&#39;])</span>
<span class="sd">        vlarray2.append([&#39;5&#39;, &#39;6&#39;, &#39;77&#39;])</span>
<span class="sd">        vlarray2.append([&#39;5&#39;, &#39;6&#39;, &#39;9&#39;, &#39;88&#39;])</span>

<span class="sd">        # Now, read it through an iterator:</span>
<span class="sd">        for x in vlarray2:</span>
<span class="sd">            print(&#39;%s[%d]--&gt; %s&#39; % (vlarray2.name, vlarray2.nrow, x))</span>

<span class="sd">        # Close the file.</span>
<span class="sd">        fileh.close()</span>

<span class="sd">    The output for the previous script is something like::</span>

<span class="sd">        --&gt; ragged array of ints</span>
<span class="sd">        vlarray1[0]--&gt; [5 6]</span>
<span class="sd">        vlarray1[1]--&gt; [5 6 7]</span>
<span class="sd">        vlarray1[2]--&gt; [5 6 9 8]</span>
<span class="sd">        --&gt; ragged array of strings</span>
<span class="sd">        vlarray2[0]--&gt; [&#39;5&#39;, &#39;66&#39;]</span>
<span class="sd">        vlarray2[1]--&gt; [&#39;5&#39;, &#39;6&#39;, &#39;77&#39;]</span>
<span class="sd">        vlarray2[2]--&gt; [&#39;5&#39;, &#39;6&#39;, &#39;9&#39;, &#39;88&#39;]</span>


<span class="sd">    .. rubric:: VLArray attributes</span>

<span class="sd">    The instance variables below are provided in addition to those in</span>
<span class="sd">    Leaf (see :ref:`LeafClassDescr`).</span>

<span class="sd">    .. attribute:: atom</span>

<span class="sd">        An Atom (see :ref:`AtomClassDescr`)</span>
<span class="sd">        instance representing the *type* and</span>
<span class="sd">        *shape* of the atomic objects to be</span>
<span class="sd">        saved. You may use a *pseudo-atom* for</span>
<span class="sd">        storing a serialized object or variable length string per row.</span>

<span class="sd">    .. attribute:: flavor</span>

<span class="sd">        The type of data object read from this leaf.</span>

<span class="sd">        Please note that when reading several rows of VLArray data,</span>
<span class="sd">        the flavor only applies to the *components* of the returned</span>
<span class="sd">        Python list, not to the list itself.</span>

<span class="sd">    .. attribute:: nrow</span>

<span class="sd">        On iterators, this is the index of the current row.</span>

<span class="sd">    .. attribute:: nrows</span>

<span class="sd">        The current number of rows in the array.</span>

<span class="sd">    .. attribute:: extdim</span>

<span class="sd">       The index of the enlargeable dimension (always 0 for vlarrays).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Class identifier.</span>
    <span class="n">_c_classid</span> <span class="o">=</span> <span class="s1">&#39;VLARRAY&#39;</span>

    <span class="nd">@lazyattr</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The NumPy ``dtype`` that most closely matches this array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The shape of the stored array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">,)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size_on_disk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The HDF5 library does not include a function to determine size_on_disk</span>
<span class="sd">        for variable-length arrays.  Accessing this attribute will raise a</span>
<span class="sd">        NotImplementedError.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;size_on_disk not implemented for VLArrays&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size_in_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The size of this array&#39;s data in bytes when it is fully loaded</span>
<span class="sd">        into memory.</span>

<span class="sd">        .. note::</span>

<span class="sd">            When data is stored in a VLArray using the ObjectAtom type,</span>
<span class="sd">            it is first serialized using pickle, and then converted to</span>
<span class="sd">            a NumPy array suitable for storage in an HDF5 file.</span>
<span class="sd">            This attribute will return the size of that NumPy</span>
<span class="sd">            representation.  If you wish to know the size of the Python</span>
<span class="sd">            objects after they are loaded from disk, you can use this</span>
<span class="sd">            `ActiveState recipe</span>
<span class="sd">            &lt;http://code.activestate.com/recipes/577504/&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_memory_size</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parentnode</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                 <span class="n">filters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">expectedrows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">chunkshape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">track_times</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_v_version</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;The object version of this array.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_v_new</span> <span class="o">=</span> <span class="n">new</span> <span class="o">=</span> <span class="n">atom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Is this the first time the node has been created?&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_v_new_title</span> <span class="o">=</span> <span class="n">title</span>
        <span class="sd">&quot;&quot;&quot;New title for this node.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_v_new_filters</span> <span class="o">=</span> <span class="n">filters</span>
        <span class="sd">&quot;&quot;&quot;New filter properties for this array.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">expectedrows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">expectedrows</span> <span class="o">=</span> <span class="n">parentnode</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;EXPECTED_ROWS_VLARRAY&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_expectedrows</span> <span class="o">=</span> <span class="n">expectedrows</span>
        <span class="sd">&quot;&quot;&quot;The expected number of rows to be stored in the array.</span>

<span class="sd">        .. versionadded:: 3.0</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_v_chunkshape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Private storage for the `chunkshape` property of Leaf.&quot;&quot;&quot;</span>

        <span class="c1"># Miscellaneous iteration rubbish.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Starting row for the current iteration.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_stop</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Stopping row for the current iteration.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_step</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Step size for the current iteration.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_nrowsread</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Number of rows read up to the current state of iteration.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_startb</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Starting row for current buffer.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_stopb</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Stopping row for current buffer. &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_row</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Current row in iterators (sentinel).&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="sd">&quot;&quot;&quot;Whether we are in the middle of an iteration or not (sentinel).&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">listarr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Current buffer in iterators.&quot;&quot;&quot;</span>

        <span class="c1"># Documented (*public*) attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="n">atom</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An Atom (see :ref:`AtomClassDescr`) instance representing the</span>
<span class="sd">        *type* and *shape* of the atomic objects to be saved. You may</span>
<span class="sd">        use a *pseudo-atom* for storing a serialized object or</span>
<span class="sd">        variable length string per row.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nrow</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;On iterators, this is the index of the current row.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;The current number of rows in the array.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">extdim</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># VLArray only have one dimension currently</span>
        <span class="sd">&quot;&quot;&quot;The index of the enlargeable dimension (always 0 for vlarrays).&quot;&quot;&quot;</span>

        <span class="c1"># Check the chunkshape parameter</span>
        <span class="k">if</span> <span class="n">new</span> <span class="ow">and</span> <span class="n">chunkshape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunkshape</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
                <span class="n">chunkshape</span> <span class="o">=</span> <span class="p">(</span><span class="n">chunkshape</span><span class="p">,)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">chunkshape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">chunkshape</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;`chunkshape` parameter must be an integer or sequence &quot;</span>
                    <span class="s2">&quot;and you passed a </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">chunkshape</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunkshape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`chunkshape` rank (length) must be 1: </span><span class="si">%r</span><span class="s2">&quot;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="n">chunkshape</span><span class="p">,))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_chunkshape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">SizeType</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">chunkshape</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parentnode</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span>
                         <span class="n">byteorder</span><span class="p">,</span> <span class="n">_log</span><span class="p">,</span> <span class="n">track_times</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_g_post_init_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_g_post_init_hook</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nrowsinbuf</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># maybe enough for most applications</span>

    <span class="c1"># This is too specific for moving it into Leaf</span>
    <span class="k">def</span> <span class="nf">_calc_chunkshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expectedrows</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the size for the HDF5 chunk.&quot;&quot;&quot;</span>

        <span class="c1"># For computing the chunkshape for HDF5 VL types, we have to</span>
        <span class="c1"># choose the itemsize of the *each* element of the atom and</span>
        <span class="c1"># not the size of the entire atom.  I don&#39;t know why this</span>
        <span class="c1"># should be like this, perhaps I should report this to the</span>
        <span class="c1"># HDF5 list.</span>
        <span class="c1"># F. Alted 2006-11-23</span>
        <span class="c1"># elemsize = self.atom.atomsize()</span>
        <span class="n">elemsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basesize</span>

        <span class="c1"># AV 2013-05-03</span>
        <span class="c1"># This is just a quick workaround tha allows to change the API for</span>
        <span class="c1"># PyTables 3.0 release and remove the expected_mb parameter.</span>
        <span class="c1"># The algorithm for computing the chunkshape should be rewritten as</span>
        <span class="c1"># requested by gh-35.</span>
        <span class="n">expected_mb</span> <span class="o">=</span> <span class="n">expectedrows</span> <span class="o">*</span> <span class="n">elemsize</span> <span class="o">/</span> <span class="mi">1024</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="n">chunksize</span> <span class="o">=</span> <span class="n">calc_chunksize</span><span class="p">(</span><span class="n">expected_mb</span><span class="p">)</span>

        <span class="c1"># Set the chunkshape</span>
        <span class="n">chunkshape</span> <span class="o">=</span> <span class="n">chunksize</span> <span class="o">//</span> <span class="n">elemsize</span>
        <span class="c1"># Safeguard against itemsizes being extremely large</span>
        <span class="k">if</span> <span class="n">chunkshape</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">chunkshape</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">SizeType</span><span class="p">(</span><span class="n">chunkshape</span><span class="p">),)</span>

    <span class="k">def</span> <span class="nf">_g_create</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a variable length array (ragged array).&quot;&quot;&quot;</span>

        <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_version</span> <span class="o">=</span> <span class="n">obversion</span>
        <span class="c1"># Check for zero dims in atom shape (not allowed in VLArrays)</span>
        <span class="n">zerodims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">zerodims</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;When creating VLArrays, none of the dimensions &quot;</span>
                             <span class="s2">&quot;of the Atom instance can be zero.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">):</span>  <span class="c1"># it is a pseudo-atom</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_atomicdtype</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">dtype</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_atomicsize</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_basesize</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_atomicdtype</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">dtype</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_atomicsize</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_basesize</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atomictype</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atomicshape</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Compute the optimal chunkshape, if needed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_chunkshape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_chunkshape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_chunkshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_expectedrows</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span> <span class="o">=</span> <span class="n">SizeType</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>     <span class="c1"># No rows at creation time</span>

        <span class="c1"># Correct the byteorder if needed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">byteorder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">=</span> <span class="n">correct_byteorder</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span><span class="p">)</span>

        <span class="c1"># After creating the vlarray, ``self._v_objectid`` needs to be</span>
        <span class="c1"># set because it is needed for setting attributes afterwards.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_objectid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_new_title</span><span class="p">)</span>

        <span class="c1"># Add an attribute in case we have a pseudo-atom so that we</span>
        <span class="c1"># can retrieve the proper class after a re-opening operation.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">):</span>  <span class="c1"># it is a pseudo-atom</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">PSEUDOATOM</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">kind</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_objectid</span>

    <span class="k">def</span> <span class="nf">_g_open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the metadata info for an array in file.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_v_objectid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_chunkshape</span><span class="p">,</span> <span class="n">atom</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_open_array</span><span class="p">()</span>

        <span class="c1"># Check if the atom can be a PseudoAtom</span>
        <span class="k">if</span> <span class="s2">&quot;PSEUDOATOM&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">PSEUDOATOM</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;vlstring&#39;</span><span class="p">:</span>
                <span class="n">atom</span> <span class="o">=</span> <span class="n">VLStringAtom</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;vlunicode&#39;</span><span class="p">:</span>
                <span class="n">atom</span> <span class="o">=</span> <span class="n">VLUnicodeAtom</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;object&#39;</span><span class="p">:</span>
                <span class="n">atom</span> <span class="o">=</span> <span class="n">ObjectAtom</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;pseudo-atom name ``</span><span class="si">%s</span><span class="s2">`` not known.&quot;</span> <span class="o">%</span> <span class="n">kind</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">format_version</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span>
            <span class="n">flavor1x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">FLAVOR</span>
            <span class="k">if</span> <span class="n">flavor1x</span> <span class="o">==</span> <span class="s2">&quot;VLString&quot;</span><span class="p">:</span>
                <span class="n">atom</span> <span class="o">=</span> <span class="n">VLStringAtom</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">flavor1x</span> <span class="o">==</span> <span class="s2">&quot;Object&quot;</span><span class="p">:</span>
                <span class="n">atom</span> <span class="o">=</span> <span class="n">ObjectAtom</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="n">atom</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_objectid</span>

    <span class="k">def</span> <span class="nf">_getnobjects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nparr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of objects in a NumPy array.&quot;&quot;&quot;</span>

        <span class="c1"># Check for zero dimensionality array</span>
        <span class="n">zerodims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nparr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">zerodims</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># No objects to be added</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">nparr</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">atom_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">shapelen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nparr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom_shape</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">atomshapelen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">atom_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">shape</span><span class="p">,)</span>
            <span class="n">atomshapelen</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">diflen</span> <span class="o">=</span> <span class="n">shapelen</span> <span class="o">-</span> <span class="n">atomshapelen</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="o">==</span> <span class="n">atom_shape</span><span class="p">:</span>
            <span class="n">nobjects</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">diflen</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">shape</span><span class="p">[</span><span class="n">diflen</span><span class="p">:]</span> <span class="o">==</span> <span class="n">atom_shape</span><span class="p">):</span>
            <span class="c1"># Check if the leading dimensions are all ones</span>
            <span class="c1"># if shape[:diflen-1] == (1,)*(diflen-1):</span>
            <span class="c1">#    nobjects = shape[diflen-1]</span>
            <span class="c1">#    shape = shape[diflen:]</span>
            <span class="c1"># It&#39;s better to accept only inputs with the exact dimensionality</span>
            <span class="c1"># i.e. a dimensionality only 1 element larger than atom</span>
            <span class="n">nobjects</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="n">atom_shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="ow">and</span> <span class="n">shapelen</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Case where shape = (N,) and shape_atom = 1 or (1,)</span>
            <span class="n">nobjects</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The object &#39;</span><span class="si">%s</span><span class="s2">&#39; is composed of elements with &quot;</span>
                             <span class="s2">&quot;shape &#39;</span><span class="si">%s</span><span class="s2">&#39;, which is not compatible with the &quot;</span>
                             <span class="s2">&quot;atom shape (&#39;</span><span class="si">%s</span><span class="s2">&#39;).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nparr</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">atom_shape</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">nobjects</span>

<div class="viewcode-block" id="VLArray.get_enum"><a class="viewcode-back" href="../../usersguide/libref/homogenous_storage.html#tables.VLArray.get_enum">[docs]</a>    <span class="k">def</span> <span class="nf">get_enum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the enumerated type associated with this array.</span>

<span class="sd">        If this array is of an enumerated type, the corresponding Enum instance</span>
<span class="sd">        (see :ref:`EnumClassDescr`) is returned. If it is not of an enumerated</span>
<span class="sd">        type, a TypeError is raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s1">&#39;enum&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;array ``</span><span class="si">%s</span><span class="s2">`` is not of an enumerated type&quot;</span>
                            <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_pathname</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">enum</span></div>

<div class="viewcode-block" id="VLArray.append"><a class="viewcode-back" href="../../usersguide/libref/homogenous_storage.html#tables.VLArray.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a sequence of data to the end of the dataset.</span>

<span class="sd">        This method appends the objects in the sequence to a *single row* in</span>
<span class="sd">        this array. The type and shape of individual objects must be compliant</span>
<span class="sd">        with the atoms in the array. In the case of serialized objects and</span>
<span class="sd">        variable length strings, the object or string to append is itself the</span>
<span class="sd">        sequence.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_open</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_check_writable</span><span class="p">()</span>

        <span class="c1"># Prepare the sequence to convert it into a NumPy object</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">):</span>  <span class="c1"># it is a pseudo-atom</span>
            <span class="n">sequence</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">toarray</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>
            <span class="n">statom</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">base</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c1"># fastest check in most cases</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument is not a sequence&quot;</span><span class="p">)</span>
            <span class="n">statom</span> <span class="o">=</span> <span class="n">atom</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># The sequence needs to be copied to make the operation safe</span>
            <span class="c1"># to in-place conversion.</span>
            <span class="n">nparr</span> <span class="o">=</span> <span class="n">convert_to_np_atom2</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">statom</span><span class="p">)</span>
            <span class="n">nobjects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getnobjects</span><span class="p">(</span><span class="n">nparr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nobjects</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">nparr</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_append</span><span class="p">(</span><span class="n">nparr</span><span class="p">,</span> <span class="n">nobjects</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span> <span class="o">+=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="VLArray.iterrows"><a class="viewcode-back" href="../../usersguide/libref/homogenous_storage.html#tables.VLArray.iterrows">[docs]</a>    <span class="k">def</span> <span class="nf">iterrows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over the rows of the array.</span>

<span class="sd">        This method returns an iterator yielding an object of the current</span>
<span class="sd">        flavor for each selected row in the array.</span>

<span class="sd">        If a range is not supplied, *all the rows* in the array are iterated</span>
<span class="sd">        upon. You can also use the :meth:`VLArray.__iter__` special method for</span>
<span class="sd">        that purpose.  If you only want to iterate over a given *range of rows*</span>
<span class="sd">        in the array, you may use the start, stop and step parameters.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            for row in vlarray.iterrows(step=4):</span>
<span class="sd">                print(&#39;%s[%d]--&gt; %s&#39; % (vlarray.name, vlarray.nrow, row))</span>

<span class="sd">        .. versionchanged:: 3.0</span>
<span class="sd">           If the *start* parameter is provided and *stop* is None then the</span>
<span class="sd">           array is iterated from *start* to the last line.</span>
<span class="sd">           In PyTables &lt; 3.0 only one element was returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_loop</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="VLArray.__iter__"><a class="viewcode-back" href="../../usersguide/libref/homogenous_storage.html#tables.VLArray.__iter__">[docs]</a>    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over the rows of the array.</span>

<span class="sd">        This is equivalent to calling :meth:`VLArray.iterrows` with default</span>
<span class="sd">        arguments, i.e. it iterates over *all the rows* in the array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            result = [row for row in vlarray]</span>

<span class="sd">        Which is equivalent to::</span>

<span class="sd">            result = [row for row in vlarray.iterrows()]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init</span><span class="p">:</span>
            <span class="c1"># If the iterator is called directly, assign default variables</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_step</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1"># and initialize the loop</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_loop</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="k">def</span> <span class="nf">_init_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialization for the __iter__ iterator.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_nrowsread</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_startb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_row</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>   <span class="c1"># Sentinel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Sentinel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nrow</span> <span class="o">=</span> <span class="n">SizeType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">)</span>    <span class="c1"># row number</span>

<div class="viewcode-block" id="VLArray.__next__"><a class="viewcode-back" href="../../usersguide/libref/homogenous_storage.html#tables.VLArray.__next__">[docs]</a>    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the next element of the array during an iteration.</span>

<span class="sd">        The element is returned as a list of objects of the current</span>
<span class="sd">        flavor.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nrowsread</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>        <span class="c1"># end of iteration</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Read a chunk of rows</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrowsinbuf</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_stopb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_startb</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrowsinbuf</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">listarr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_startb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stopb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_row</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_startb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stopb</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_row</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nrow</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nrowsread</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">listarr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_row</span><span class="p">]</span></div>

<div class="viewcode-block" id="VLArray.__getitem__"><a class="viewcode-back" href="../../usersguide/libref/homogenous_storage.html#tables.VLArray.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a row or a range of rows from the array.</span>

<span class="sd">        If key argument is an integer, the corresponding array row is returned</span>
<span class="sd">        as an object of the current flavor.  If key is a slice, the range of</span>
<span class="sd">        rows determined by it is returned as a list of objects of the current</span>
<span class="sd">        flavor.</span>

<span class="sd">        In addition, NumPy-style point selections are supported.  In</span>
<span class="sd">        particular, if key is a list of row coordinates, the set of rows</span>
<span class="sd">        determined by it is returned.  Furthermore, if key is an array of</span>
<span class="sd">        boolean values, only the coordinates where key is True are returned.</span>
<span class="sd">        Note that for the latter to work it is necessary that key list would</span>
<span class="sd">        contain exactly as many rows as the array has.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            a_row = vlarray[4]</span>
<span class="sd">            a_list = vlarray[4:1000:2]</span>
<span class="sd">            a_list2 = vlarray[[0,2]]   # get list of coords</span>
<span class="sd">            a_list3 = vlarray[[0,-2]]  # negative values accepted</span>
<span class="sd">            a_list4 = vlarray[numpy.array([True,...,False])]  # array of bools</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_open</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">is_idx</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="c1"># Index out of range protection</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Index out of range&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># To support negative values</span>
                <span class="n">key</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span>
            <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span>
                <span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="c1"># Try with a boolean or point selection</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_point_selection</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_coordinates</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid index or slice: </span><span class="si">{</span><span class="n">key</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_assign_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assign the `values` to the positions stated in `coords`.&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nrow</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;First index out of range&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nrow</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># To support negative values</span>
                <span class="n">nrow</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span>
            <span class="n">object_</span> <span class="o">=</span> <span class="n">value</span>
            <span class="c1"># Prepare the object to convert it into a NumPy object</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">):</span>  <span class="c1"># it is a pseudo-atom</span>
                <span class="n">object_</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">toarray</span><span class="p">(</span><span class="n">object_</span><span class="p">)</span>
                <span class="n">statom</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">base</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">statom</span> <span class="o">=</span> <span class="n">atom</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">convert_to_np_atom</span><span class="p">(</span><span class="n">object_</span><span class="p">,</span> <span class="n">statom</span><span class="p">)</span>
            <span class="n">nobjects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getnobjects</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="c1"># Get the previous value</span>
            <span class="n">nrow</span> <span class="o">=</span> <span class="n">idx2long</span><span class="p">(</span>
                <span class="n">nrow</span><span class="p">)</span>   <span class="c1"># To convert any possible numpy scalar value</span>
            <span class="n">nparr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_array</span><span class="p">(</span><span class="n">nrow</span><span class="p">,</span> <span class="n">nrow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nobjects</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nparr</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nobjects</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Length of value (</span><span class="si">%s</span><span class="s2">) is larger than number &quot;</span>
                                 <span class="s2">&quot;of elements in row (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">),</span>
                                                              <span class="n">nobjects</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nparr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>  <span class="c1"># XXX</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Value parameter:</span><span class="se">\n</span><span class="s2">&#39;</span><span class="si">%r</span><span class="s2">&#39;</span><span class="se">\n</span><span class="s2">&quot;</span>
                                 <span class="s2">&quot;cannot be converted into an array object &quot;</span>
                                 <span class="s2">&quot;compliant vlarray[</span><span class="si">%s</span><span class="s2">] row: </span><span class="se">\n</span><span class="s2">&#39;</span><span class="si">%r</span><span class="s2">&#39;</span><span class="se">\n</span><span class="s2">&quot;</span>
                                 <span class="s2">&quot;The error was: &lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span>
                                                          <span class="n">nparr</span><span class="p">[:],</span> <span class="n">exc</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">nparr</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_modify</span><span class="p">(</span><span class="n">nrow</span><span class="p">,</span> <span class="n">nparr</span><span class="p">,</span> <span class="n">nobjects</span><span class="p">)</span>

<div class="viewcode-block" id="VLArray.__setitem__"><a class="viewcode-back" href="../../usersguide/libref/homogenous_storage.html#tables.VLArray.__setitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set a row, or set of rows, in the array.</span>

<span class="sd">        It takes different actions depending on the type of the *key*</span>
<span class="sd">        parameter: if it is an integer, the corresponding table row is</span>
<span class="sd">        set to *value* (a record or sequence capable of being converted</span>
<span class="sd">        to the table structure).  If *key* is a slice, the row slice</span>
<span class="sd">        determined by it is set to *value* (a record array or sequence</span>
<span class="sd">        of rows capable of being converted to the table structure).</span>

<span class="sd">        In addition, NumPy-style point selections are supported.  In</span>
<span class="sd">        particular, if key is a list of row coordinates, the set of rows</span>
<span class="sd">        determined by it is set to value.  Furthermore, if key is an array of</span>
<span class="sd">        boolean values, only the coordinates where key is True are set to</span>
<span class="sd">        values from value.  Note that for the latter to work it is necessary</span>
<span class="sd">        that key list would contain exactly as many rows as the table has.</span>

<span class="sd">        .. note::</span>

<span class="sd">            When updating the rows of a VLArray object which uses a</span>
<span class="sd">            pseudo-atom, there is a problem: you can only update values</span>
<span class="sd">            with *exactly* the same size in bytes than the original row.</span>
<span class="sd">            This is very difficult to meet with object pseudo-atoms,</span>
<span class="sd">            because :mod:`pickle` applied on a Python object does not</span>
<span class="sd">            guarantee to return the same number of bytes than over another</span>
<span class="sd">            object, even if they are of the same class.</span>
<span class="sd">            This effectively limits the kinds of objects than can be</span>
<span class="sd">            updated in variable-length arrays.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            vlarray[0] = vlarray[0] * 2 + 3</span>
<span class="sd">            vlarray[99] = arange(96) * 2 + 3</span>

<span class="sd">            # Negative values for the index are supported.</span>
<span class="sd">            vlarray[-99] = vlarray[5] * 2 + 3</span>
<span class="sd">            vlarray[1:30:2] = list_of_rows</span>
<span class="sd">            vlarray[[1,3]] = new_1_and_3_rows</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_open</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_file</span><span class="o">.</span><span class="n">_check_writable</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">is_idx</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="c1"># If key is not a sequence, convert to it</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_range</span><span class="p">(</span>
                <span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="c1"># Try with a boolean or point selection</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_point_selection</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid index or slice: </span><span class="si">{</span><span class="n">key</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Do the assignment row by row</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_values</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>

    <span class="c1"># Accessor for the _read_array method in superclass</span>
<div class="viewcode-block" id="VLArray.read"><a class="viewcode-back" href="../../usersguide/libref/homogenous_storage.html#tables.VLArray.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get data in the array as a list of objects of the current flavor.</span>

<span class="sd">        Please note that, as the lengths of the different rows are variable,</span>
<span class="sd">        the returned value is a *Python list* (not an array of the current</span>
<span class="sd">        flavor), with as many entries as specified rows in the range</span>
<span class="sd">        parameters.</span>

<span class="sd">        The start, stop and step parameters can be used to select only a</span>
<span class="sd">        *range of rows* in the array.  Their meanings are the same as in</span>
<span class="sd">        the built-in range() Python function, except that negative values</span>
<span class="sd">        of step are not allowed yet. Moreover, if only start is specified,</span>
<span class="sd">        then stop will be set to start + 1. If you do not specify neither</span>
<span class="sd">        start nor stop, then *all the rows* in the array are selected.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_open</span><span class="p">()</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_range_read</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">stop</span><span class="p">:</span>
            <span class="n">listarr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">listarr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_array</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

        <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">):</span>  <span class="c1"># it is a pseudo-atom</span>
            <span class="n">outlistarr</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">listarr</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Convert the list to the right flavor</span>
            <span class="n">flavor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flavor</span>
            <span class="n">outlistarr</span> <span class="o">=</span> <span class="p">[</span><span class="n">internal_to_flavor</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">flavor</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">listarr</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">outlistarr</span></div>

    <span class="k">def</span> <span class="nf">_read_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read rows specified in `coords`.&quot;&quot;&quot;</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">coord</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">rows</span>

    <span class="k">def</span> <span class="nf">_g_copy_with_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span>
                           <span class="n">title</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">chunkshape</span><span class="p">,</span> <span class="n">_log</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Private part of Leaf.copy() for each kind of leaf.&quot;&quot;&quot;</span>

        <span class="c1"># Build the new VLArray object</span>
        <span class="nb">object</span> <span class="o">=</span> <span class="n">VLArray</span><span class="p">(</span>
            <span class="n">group</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">,</span>
            <span class="n">expectedrows</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_expectedrows</span><span class="p">,</span> <span class="n">chunkshape</span><span class="o">=</span><span class="n">chunkshape</span><span class="p">,</span>
            <span class="n">_log</span><span class="o">=</span><span class="n">_log</span><span class="p">)</span>

        <span class="c1"># Now, fill the new vlarray with values from the old one</span>
        <span class="c1"># This is not buffered because we cannot forsee the length</span>
        <span class="c1"># of each record. So, the safest would be a copy row by row.</span>
        <span class="c1"># In the future, some analysis can be done in order to buffer</span>
        <span class="c1"># the copy process.</span>
        <span class="n">nrowsinbuf</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_range_read</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="c1"># Optimized version (no conversions, no type and shape checks, etc...)</span>
        <span class="n">nrowscopied</span> <span class="o">=</span> <span class="n">SizeType</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">nbytes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">):</span>  <span class="c1"># it is a pseudo-atom</span>
            <span class="n">atomsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">atomsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">size</span>
        <span class="k">for</span> <span class="n">start2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">*</span> <span class="n">nrowsinbuf</span><span class="p">):</span>
            <span class="c1"># Save the records on disk</span>
            <span class="n">stop2</span> <span class="o">=</span> <span class="n">start2</span> <span class="o">+</span> <span class="n">step</span> <span class="o">*</span> <span class="n">nrowsinbuf</span>
            <span class="k">if</span> <span class="n">stop2</span> <span class="o">&gt;</span> <span class="n">stop</span><span class="p">:</span>
                <span class="n">stop2</span> <span class="o">=</span> <span class="n">stop</span>
            <span class="n">nparr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_array</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start2</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop2</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nobjects</span> <span class="o">=</span> <span class="n">nparr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="nb">object</span><span class="o">.</span><span class="n">_append</span><span class="p">(</span><span class="n">nparr</span><span class="p">,</span> <span class="n">nobjects</span><span class="p">)</span>
            <span class="n">nbytes</span> <span class="o">+=</span> <span class="n">nobjects</span> <span class="o">*</span> <span class="n">atomsize</span>
            <span class="n">nrowscopied</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">object</span><span class="o">.</span><span class="n">nrows</span> <span class="o">=</span> <span class="n">nrowscopied</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This provides more metainfo in addition to standard __str__&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"></span>
<span class="s2">  atom = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="si">!r}</span><span class="s2"></span>
<span class="s2">  byteorder = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">byteorder</span><span class="si">!r}</span><span class="s2"></span>
<span class="s2">  nrows = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="si">}</span><span class="s2"></span>
<span class="s2">  flavor = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">flavor</span><span class="si">!r}</span><span class="s2">&quot;&quot;&quot;</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2011â€“2021, PyTables maintainers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>